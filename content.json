{"meta":{"title":"jhfuture","subtitle":"","description":"持续奔赴热爱","author":"jhfuture","url":"https://jhfuture.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-07-23T14:50:15.957Z","updated":"2022-07-22T15:46:36.028Z","comments":false,"path":"/404.html","permalink":"https://jhfuture.github.io/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-07-22T15:46:36.030Z","updated":"2022-07-22T15:46:36.030Z","comments":true,"path":"links/index.html","permalink":"https://jhfuture.github.io/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-07-23T04:26:55.741Z","updated":"2022-07-23T04:26:55.741Z","comments":false,"path":"about/index.html","permalink":"https://jhfuture.github.io/about/index.html","excerpt":"","text":"这是一个简单的经验分享和笔记记录博客，欢迎你的到来 ——————2022/7/23@jhfuture"},{"title":"书单","date":"2022-07-22T15:46:36.029Z","updated":"2022-07-22T15:46:36.029Z","comments":false,"path":"books/index.html","permalink":"https://jhfuture.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-22T15:46:36.030Z","updated":"2022-07-22T15:46:36.030Z","comments":false,"path":"categories/index.html","permalink":"https://jhfuture.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-07-23T16:45:35.111Z","updated":"2022-07-23T16:45:35.081Z","comments":true,"path":"css/default.min.css","permalink":"https://jhfuture.github.io/css/default.min.css","excerpt":"","text":"/** * Minified by jsDelivr using clean-css v4.1.11. * Original file: /npm/gitment@0.0.3/style/default.css * * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files */ .gitment-container{font-family:sans-serif;font-size:14px;line-height:1.5;color:#333;word-wrap:break-word}.gitment-container *{box-sizing:border-box}.gitment-container :disabled{cursor:not-allowed}.gitment-container a,.gitment-container a:visited{cursor:pointer;text-decoration:none}.gitment-container a:hover{text-decoration:underline}.gitment-container .gitment-hidden{display:none}.gitment-container .gitment-spinner-icon{fill:#333;-webkit-animation:gitment-spin 1s steps(12) infinite;animation:gitment-spin 1s steps(12) infinite}@-webkit-keyframes gitment-spin{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes gitment-spin{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.gitment-root-container{margin:19px 0}.gitment-header-container{margin:19px 0}.gitment-comment-like-btn,.gitment-header-like-btn{cursor:pointer}.gitment-comment-like-btn{float:right}.gitment-comment-like-btn.liked{color:#f44336}.gitment-header-like-btn svg{vertical-align:middle;height:30px}.gitment-comment-like-btn svg{vertical-align:middle;height:20px}.gitment-comment-like-btn.liked svg,.gitment-header-like-btn.liked svg{fill:#f44336}a.gitment-header-issue-link,a.gitment-header-issue-link:visited{float:right;line-height:30px;color:#666}a.gitment-header-issue-link:hover{color:#666}.gitment-comments-empty,.gitment-comments-error,.gitment-comments-loading{text-align:center;margin:50px 0}.gitment-comments-list{list-style:none;padding-left:0;margin:0 0 38px}.gitment-comment,.gitment-editor-container{position:relative;min-height:60px;padding-left:60px;margin:19px 0}.gitment-comment-avatar,.gitment-editor-avatar{float:left;margin-left:-60px}.gitment-comment-avatar,.gitment-comment-avatar-img,.gitment-editor-avatar svg,.gitment-editor-avatar-img{width:44px;height:44px;border-radius:3px}.gitment-editor-avatar .gitment-github-icon{fill:#fff;background-color:#333}.gitment-comment-main,.gitment-editor-main{position:relative;border:1px solid #cfd8dc;border-radius:0}.gitment-comment-main::after,.gitment-comment-main::before,.gitment-editor-main::after,.gitment-editor-main::before{position:absolute;top:11px;left:-16px;display:block;width:0;height:0;pointer-events:none;content:\"\";border-color:transparent;border-style:solid solid outset}.gitment-comment-main::before,.gitment-editor-main::before{border-width:8px;border-right-color:#cfd8dc}.gitment-comment-main::after,.gitment-editor-main::after{margin-top:1px;margin-left:2px;border-width:7px;border-right-color:#fff}.gitment-comment-header{margin:12px 15px;color:#666;background-color:#fff;border-radius:3px}.gitment-editor-header{padding:0;margin:0;border-bottom:1px solid #cfd8dc}a.gitment-comment-name,a.gitment-comment-name:visited{font-weight:600;color:#666}.gitment-editor-tabs{margin-bottom:-1px;margin-left:-1px}.gitment-editor-tab{display:inline-block;padding:11px 12px;font-size:14px;line-height:20px;color:#666;text-decoration:none;background-color:transparent;border-width:0 1px;border-style:solid;border-color:transparent;border-radius:0;white-space:nowrap;cursor:pointer;user-select:none;outline:0}.gitment-editor-tab.gitment-selected{color:#333;background-color:#fff;border-color:#cfd8dc}.gitment-editor-login{float:right;margin-top:-30px;margin-right:15px}a.gitment-editor-login-link,a.gitment-editor-login-link:visited,a.gitment-footer-project-link,a.gitment-footer-project-link:visited{color:#2196f3}a.gitment-editor-logout-link,a.gitment-editor-logout-link:visited{color:#666}a.gitment-editor-logout-link:hover{color:#2196f3;text-decoration:none}.gitment-comment-body{position:relative;margin:12px 15px;overflow:hidden;border-radius:3px}.gitment-comment-body-folded{cursor:pointer}.gitment-comment-body-folded::before{display:block!important;content:\"\";position:absolute;width:100%;left:0;top:0;bottom:50px;pointer-events:none;background:-webkit-linear-gradient(top,rgba(255,255,255,0),rgba(255,255,255,.9));background:linear-gradient(180deg,rgba(255,255,255,0),rgba(255,255,255,.9))}.gitment-comment-body-folded::after{display:block!important;content:\"Click to Expand\"!important;text-align:center;color:#666;position:absolute;width:100%;height:50px;line-height:50px;left:0;bottom:0;pointer-events:none;background:rgba(255,255,255,.9)}.gitment-editor-body{margin:0}.gitment-comment-body>:first-child,.gitment-editor-preview>:first-child{margin-top:0!important}.gitment-comment-body>:last-child,.gitment-editor-preview>:last-child{margin-bottom:0!important}.gitment-editor-body textarea{display:block;width:100%;min-height:150px;max-height:500px;padding:16px;resize:vertical;max-width:100%;margin:0;font-size:14px;line-height:1.6;background-color:#fff;color:#333;vertical-align:middle;border:none;border-radius:0;outline:0;box-shadow:none;overflow:visible}.gitment-editor-body textarea:focus{background-color:#fff}.gitment-editor-preview{min-height:150px;padding:16px;background-color:transparent;width:100%;font-size:14px;line-height:1.5;word-wrap:break-word}.gitment-editor-footer{padding:0;margin-top:10px}.gitment-editor-footer::after{display:table;clear:both;content:\"\"}a.gitment-editor-footer-tip{display:inline-block;padding-top:10px;font-size:12px;color:#666}a.gitment-editor-footer-tip:hover{color:#2196f3;text-decoration:none}.gitment-comments-pagination{list-style:none;text-align:right;border-radius:0;margin:-19px 0 19px 0}.gitment-comments-page-item{display:inline-block;cursor:pointer;border:1px solid #cfd8dc;margin-left:-1px;padding:.25rem .5rem}.gitment-comments-page-item:hover{background-color:#f5f5f5}.gitment-comments-page-item.gitment-selected{background-color:#f5f5f5}.gitment-comments-init-btn,.gitment-editor-submit{color:#fff;background-color:#00bcd4;position:relative;display:inline-block;padding:7px 13px;font-size:14px;font-weight:600;line-height:20px;white-space:nowrap;vertical-align:middle;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-size:110% 110%;border:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.gitment-comments-init-btn:hover,.gitment-editor-submit:hover{background-color:#00acc1}.gitment-comments-init-btn:disabled,.gitment-editor-submit:disabled{color:rgba(255,255,255,.75);background-color:#4dd0e1;box-shadow:none}.gitment-editor-submit{float:right}.gitment-footer-container{margin-top:30px;margin-bottom:20px;text-align:right;font-size:12px}.gitment-markdown{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;line-height:1.5;color:#333;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\";font-size:16px;line-height:1.5;word-wrap:break-word}.gitment-markdown .pl-c{color:#969896}.gitment-markdown .pl-c1,.gitment-markdown .pl-s .pl-v{color:#0086b3}.gitment-markdown .pl-e,.gitment-markdown .pl-en{color:#795da3}.gitment-markdown .pl-s .pl-s1,.gitment-markdown .pl-smi{color:#333}.gitment-markdown .pl-ent{color:#63a35c}.gitment-markdown .pl-k{color:#a71d5d}.gitment-markdown .pl-pds,.gitment-markdown .pl-s,.gitment-markdown .pl-s .pl-pse .pl-s1,.gitment-markdown .pl-sr,.gitment-markdown .pl-sr .pl-cce,.gitment-markdown .pl-sr .pl-sra,.gitment-markdown .pl-sr .pl-sre{color:#183691}.gitment-markdown .pl-smw,.gitment-markdown .pl-v{color:#ed6a43}.gitment-markdown .pl-bu{color:#b52a1d}.gitment-markdown .pl-ii{color:#f8f8f8;background-color:#b52a1d}.gitment-markdown .pl-c2{color:#f8f8f8;background-color:#b52a1d}.gitment-markdown .pl-c2::before{content:\"^M\"}.gitment-markdown .pl-sr .pl-cce{font-weight:700;color:#63a35c}.gitment-markdown .pl-ml{color:#693a17}.gitment-markdown .pl-mh,.gitment-markdown .pl-mh .pl-en,.gitment-markdown .pl-ms{font-weight:700;color:#1d3e81}.gitment-markdown .pl-mq{color:teal}.gitment-markdown .pl-mi{font-style:italic;color:#333}.gitment-markdown .pl-mb{font-weight:700;color:#333}.gitment-markdown .pl-md{color:#bd2c00;background-color:#ffecec}.gitment-markdown .pl-mi1{color:#55a532;background-color:#eaffea}.gitment-markdown .pl-mc{color:#ef9700;background-color:#ffe3b4}.gitment-markdown .pl-mi2{color:#d8d8d8;background-color:grey}.gitment-markdown .pl-mdr{font-weight:700;color:#795da3}.gitment-markdown .pl-mo{color:#1d3e81}.gitment-markdown .pl-ba{color:#595e62}.gitment-markdown .pl-sg{color:silver}.gitment-markdown .pl-corl{text-decoration:underline;color:#183691}.gitment-markdown .octicon{display:inline-block;vertical-align:text-top;fill:currentColor}.gitment-markdown a{background-color:transparent;-webkit-text-decoration-skip:objects}.gitment-markdown a:active,.gitment-markdown a:hover{outline-width:0}.gitment-markdown strong{font-weight:inherit}.gitment-markdown strong{font-weight:bolder}.gitment-markdown h1{font-size:2em;margin:.67em 0}.gitment-markdown img{border-style:none}.gitment-markdown svg:not(:root){overflow:hidden}.gitment-markdown code,.gitment-markdown kbd,.gitment-markdown pre{font-family:monospace,monospace;font-size:1em}.gitment-markdown hr{box-sizing:content-box;height:0;overflow:visible}.gitment-markdown input{font:inherit;margin:0}.gitment-markdown input{overflow:visible}.gitment-markdown [type=checkbox]{box-sizing:border-box;padding:0}.gitment-markdown *{box-sizing:border-box}.gitment-markdown input{font-family:inherit;font-size:inherit;line-height:inherit}.gitment-markdown a{color:#0366d6;text-decoration:none}.gitment-markdown a:hover{text-decoration:underline}.gitment-markdown strong{font-weight:600}.gitment-markdown hr{height:0;margin:15px 0;overflow:hidden;background:0 0;border:0;border-bottom:1px solid #dfe2e5}.gitment-markdown hr::before{display:table;content:\"\"}.gitment-markdown hr::after{display:table;clear:both;content:\"\"}.gitment-markdown table{border-spacing:0;border-collapse:collapse}.gitment-markdown td,.gitment-markdown th{padding:0}.gitment-markdown h1,.gitment-markdown h2,.gitment-markdown h3,.gitment-markdown h4,.gitment-markdown h5,.gitment-markdown h6{margin-top:0;margin-bottom:0}.gitment-markdown h1{font-size:32px;font-weight:600}.gitment-markdown h2{font-size:24px;font-weight:600}.gitment-markdown h3{font-size:20px;font-weight:600}.gitment-markdown h4{font-size:16px;font-weight:600}.gitment-markdown h5{font-size:14px;font-weight:600}.gitment-markdown h6{font-size:12px;font-weight:600}.gitment-markdown p{margin-top:0;margin-bottom:10px}.gitment-markdown blockquote{margin:0}.gitment-markdown ol,.gitment-markdown ul{padding-left:0;margin-top:0;margin-bottom:0}.gitment-markdown ol ol,.gitment-markdown ul ol{list-style-type:lower-roman}.gitment-markdown ol ol ol,.gitment-markdown ol ul ol,.gitment-markdown ul ol ol,.gitment-markdown ul ul ol{list-style-type:lower-alpha}.gitment-markdown dd{margin-left:0}.gitment-markdown code{font-family:SFMono-Regular,Consolas,\"Liberation Mono\",Menlo,Courier,monospace;font-size:12px}.gitment-markdown pre{margin-top:0;margin-bottom:0;font:12px SFMono-Regular,Consolas,\"Liberation Mono\",Menlo,Courier,monospace}.gitment-markdown .octicon{vertical-align:text-bottom}.gitment-markdown .pl-0{padding-left:0!important}.gitment-markdown .pl-1{padding-left:4px!important}.gitment-markdown .pl-2{padding-left:8px!important}.gitment-markdown .pl-3{padding-left:16px!important}.gitment-markdown .pl-4{padding-left:24px!important}.gitment-markdown .pl-5{padding-left:32px!important}.gitment-markdown .pl-6{padding-left:40px!important}.gitment-markdown::before{display:table;content:\"\"}.gitment-markdown::after{display:table;clear:both;content:\"\"}.gitment-markdown>:first-child{margin-top:0!important}.gitment-markdown>:last-child{margin-bottom:0!important}.gitment-markdown a:not([href]){color:inherit;text-decoration:none}.gitment-markdown .anchor{float:left;padding-right:4px;margin-left:-20px;line-height:1}.gitment-markdown .anchor:focus{outline:0}.gitment-markdown blockquote,.gitment-markdown dl,.gitment-markdown ol,.gitment-markdown p,.gitment-markdown pre,.gitment-markdown table,.gitment-markdown ul{margin-top:0;margin-bottom:16px}.gitment-markdown hr{height:.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0}.gitment-markdown blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}.gitment-markdown blockquote>:first-child{margin-top:0}.gitment-markdown blockquote>:last-child{margin-bottom:0}.gitment-markdown kbd{display:inline-block;padding:3px 5px;font-size:11px;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:solid 1px #c6cbd1;border-bottom-color:#959da5;border-radius:0;box-shadow:inset 0 -1px 0 #959da5}.gitment-markdown h1,.gitment-markdown h2,.gitment-markdown h3,.gitment-markdown h4,.gitment-markdown h5,.gitment-markdown h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}.gitment-markdown h1 .octicon-link,.gitment-markdown h2 .octicon-link,.gitment-markdown h3 .octicon-link,.gitment-markdown h4 .octicon-link,.gitment-markdown h5 .octicon-link,.gitment-markdown h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}.gitment-markdown h1:hover .anchor,.gitment-markdown h2:hover .anchor,.gitment-markdown h3:hover .anchor,.gitment-markdown h4:hover .anchor,.gitment-markdown h5:hover .anchor,.gitment-markdown h6:hover .anchor{text-decoration:none}.gitment-markdown h1:hover .anchor .octicon-link,.gitment-markdown h2:hover .anchor .octicon-link,.gitment-markdown h3:hover .anchor .octicon-link,.gitment-markdown h4:hover .anchor .octicon-link,.gitment-markdown h5:hover .anchor .octicon-link,.gitment-markdown h6:hover .anchor .octicon-link{visibility:visible}.gitment-markdown h1{padding-bottom:.3em;font-size:2em;border-bottom:1px solid #eaecef}.gitment-markdown h2{padding-bottom:.3em;font-size:1.5em;border-bottom:1px solid #eaecef}.gitment-markdown h3{font-size:1.25em}.gitment-markdown h4{font-size:1em}.gitment-markdown h5{font-size:.875em}.gitment-markdown h6{font-size:.85em;color:#6a737d}.gitment-markdown ol,.gitment-markdown ul{padding-left:2em}.gitment-markdown ol ol,.gitment-markdown ol ul,.gitment-markdown ul ol,.gitment-markdown ul ul{margin-top:0;margin-bottom:0}.gitment-markdown li>p{margin-top:16px}.gitment-markdown li+li{margin-top:.25em}.gitment-markdown dl{padding:0}.gitment-markdown dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}.gitment-markdown dl dd{padding:0 16px;margin-bottom:16px}.gitment-markdown table{display:block;width:100%;overflow:auto}.gitment-markdown table th{font-weight:600}.gitment-markdown table td,.gitment-markdown table th{padding:6px 13px;border:1px solid #dfe2e5}.gitment-markdown table tr{background-color:#fff;border-top:1px solid #c6cbd1}.gitment-markdown table tr:nth-child(2n){background-color:#f5f5f5}.gitment-markdown img{max-width:100%;box-sizing:content-box;background-color:#fff}.gitment-markdown code{padding:0;padding-top:.2em;padding-bottom:.2em;margin:0;font-size:85%;background-color:rgba(27,31,35,.05);border-radius:0}.gitment-markdown code::after,.gitment-markdown code::before{letter-spacing:-.2em;content:\"\\00a0\"}.gitment-markdown pre{word-wrap:normal}.gitment-markdown pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}.gitment-markdown .highlight{margin-bottom:16px}.gitment-markdown .highlight pre{margin-bottom:0;word-break:normal}.gitment-markdown .highlight pre,.gitment-markdown pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f5f5f5;border-radius:0}.gitment-markdown pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.gitment-markdown pre code::after,.gitment-markdown pre code::before{content:normal}.gitment-markdown .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}.gitment-markdown kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,\"Liberation Mono\",Menlo,Courier,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fcfcfc;border:solid 1px #c6cbd1;border-bottom-color:#959da5;border-radius:0;box-shadow:inset 0 -1px 0 #959da5}.gitment-markdown :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}.gitment-markdown .task-list-item{list-style-type:none}.gitment-markdown .task-list-item+.task-list-item{margin-top:3px}.gitment-markdown .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}.gitment-markdown hr{border-bottom-color:#eee} /*# sourceMappingURL=/sm/639ed8f6ce9860cee680b54e5bb438ea5615f047cc55ce44cd67eb145917131c.map */"},{"title":"","date":"2022-07-23T16:48:12.645Z","updated":"2022-07-23T16:48:12.618Z","comments":true,"path":"css/gitalk.min.css","permalink":"https://jhfuture.github.io/css/gitalk.min.css","excerpt":"","text":"/** * Minified by jsDelivr using clean-css v4.2.0. * Original file: /npm/gitalk@1.4.0/dist/gitalk.css * * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files */ @font-face{font-family:octicons-link;src:url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff')}.markdown-body{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;line-height:1.5;color:#24292e;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\";font-size:16px;line-height:1.5;word-wrap:break-word}.markdown-body .pl-c{color:#6a737d}.markdown-body .pl-c1,.markdown-body .pl-s .pl-v{color:#005cc5}.markdown-body .pl-e,.markdown-body .pl-en{color:#6f42c1}.markdown-body .pl-s .pl-s1,.markdown-body .pl-smi{color:#24292e}.markdown-body .pl-ent{color:#22863a}.markdown-body .pl-k{color:#d73a49}.markdown-body .pl-pds,.markdown-body .pl-s,.markdown-body .pl-s .pl-pse .pl-s1,.markdown-body .pl-sr,.markdown-body .pl-sr .pl-cce,.markdown-body .pl-sr .pl-sra,.markdown-body .pl-sr .pl-sre{color:#032f62}.markdown-body .pl-smw,.markdown-body .pl-v{color:#e36209}.markdown-body .pl-bu{color:#b31d28}.markdown-body .pl-ii{color:#fafbfc;background-color:#b31d28}.markdown-body .pl-c2{color:#fafbfc;background-color:#d73a49}.markdown-body .pl-c2::before{content:\"^M\"}.markdown-body .pl-sr .pl-cce{font-weight:700;color:#22863a}.markdown-body .pl-ml{color:#735c0f}.markdown-body .pl-mh,.markdown-body .pl-mh .pl-en,.markdown-body .pl-ms{font-weight:700;color:#005cc5}.markdown-body .pl-mi{font-style:italic;color:#24292e}.markdown-body .pl-mb{font-weight:700;color:#24292e}.markdown-body .pl-md{color:#b31d28;background-color:#ffeef0}.markdown-body .pl-mi1{color:#22863a;background-color:#f0fff4}.markdown-body .pl-mc{color:#e36209;background-color:#ffebda}.markdown-body .pl-mi2{color:#f6f8fa;background-color:#005cc5}.markdown-body .pl-mdr{font-weight:700;color:#6f42c1}.markdown-body .pl-ba{color:#586069}.markdown-body .pl-sg{color:#959da5}.markdown-body .pl-corl{text-decoration:underline;color:#032f62}.markdown-body .octicon{display:inline-block;vertical-align:text-top;fill:currentColor}.markdown-body a{background-color:transparent;-webkit-text-decoration-skip:objects}.markdown-body a:active,.markdown-body a:hover{outline-width:0}.markdown-body strong{font-weight:inherit}.markdown-body strong{font-weight:bolder}.markdown-body h1{font-size:2em;margin:.67em 0}.markdown-body img{border-style:none}.markdown-body svg:not(:root){overflow:hidden}.markdown-body code,.markdown-body kbd,.markdown-body pre{font-family:monospace,monospace;font-size:1em}.markdown-body hr{-webkit-box-sizing:content-box;box-sizing:content-box;height:0;overflow:visible}.markdown-body input{font:inherit;margin:0}.markdown-body input{overflow:visible}.markdown-body [type=checkbox]{-webkit-box-sizing:border-box;box-sizing:border-box;padding:0}.markdown-body *{-webkit-box-sizing:border-box;box-sizing:border-box}.markdown-body input{font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body a{color:#0366d6;text-decoration:none}.markdown-body a:hover{text-decoration:underline}.markdown-body strong{font-weight:600}.markdown-body hr{height:0;margin:15px 0;overflow:hidden;background:0 0;border:0;border-bottom:1px solid #dfe2e5}.markdown-body hr::before{display:table;content:\"\"}.markdown-body hr::after{display:table;clear:both;content:\"\"}.markdown-body table{border-spacing:0;border-collapse:collapse}.markdown-body td,.markdown-body th{padding:0}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:0;margin-bottom:0}.markdown-body h1{font-size:32px;font-weight:600}.markdown-body h2{font-size:24px;font-weight:600}.markdown-body h3{font-size:20px;font-weight:600}.markdown-body h4{font-size:16px;font-weight:600}.markdown-body h5{font-size:14px;font-weight:600}.markdown-body h6{font-size:12px;font-weight:600}.markdown-body p{margin-top:0;margin-bottom:10px}.markdown-body blockquote{margin:0}.markdown-body ol,.markdown-body ul{padding-left:0;margin-top:0;margin-bottom:0}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ol ol ol,.markdown-body ol ul ol,.markdown-body ul ol ol,.markdown-body ul ul ol{list-style-type:lower-alpha}.markdown-body dd{margin-left:0}.markdown-body code{font-family:SFMono-Regular,Consolas,\"Liberation Mono\",Menlo,Courier,monospace;font-size:12px}.markdown-body pre{margin-top:0;margin-bottom:0;font:12px SFMono-Regular,Consolas,\"Liberation Mono\",Menlo,Courier,monospace}.markdown-body .octicon{vertical-align:text-bottom}.markdown-body .pl-0{padding-left:0!important}.markdown-body .pl-1{padding-left:4px!important}.markdown-body .pl-2{padding-left:8px!important}.markdown-body .pl-3{padding-left:16px!important}.markdown-body .pl-4{padding-left:24px!important}.markdown-body .pl-5{padding-left:32px!important}.markdown-body .pl-6{padding-left:40px!important}.markdown-body::before{display:table;content:\"\"}.markdown-body::after{display:table;clear:both;content:\"\"}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body .anchor{float:left;padding-right:4px;margin-left:-20px;line-height:1}.markdown-body .anchor:focus{outline:0}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-top:0;margin-bottom:16px}.markdown-body hr{height:.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0}.markdown-body blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body kbd{display:inline-block;padding:3px 5px;font-size:11px;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:solid 1px #c6cbd1;border-bottom-color:#959da5;border-radius:3px;-webkit-box-shadow:inset 0 -1px 0 #959da5;box-shadow:inset 0 -1px 0 #959da5}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body h1{padding-bottom:.3em;font-size:2em;border-bottom:1px solid #eaecef}.markdown-body h2{padding-bottom:.3em;font-size:1.5em;border-bottom:1px solid #eaecef}.markdown-body h3{font-size:1.25em}.markdown-body h4{font-size:1em}.markdown-body h5{font-size:.875em}.markdown-body h6{font-size:.85em;color:#6a737d}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:0;margin-bottom:0}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}.markdown-body dl dd{padding:0 16px;margin-bottom:16px}.markdown-body table{display:block;width:100%;overflow:auto}.markdown-body table th{font-weight:600}.markdown-body table td,.markdown-body table th{padding:6px 13px;border:1px solid #dfe2e5}.markdown-body table tr{background-color:#fff;border-top:1px solid #c6cbd1}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body img{max-width:100%;-webkit-box-sizing:content-box;box-sizing:content-box;background-color:#fff}.markdown-body code{padding:0;padding-top:.2em;padding-bottom:.2em;margin:0;font-size:85%;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code::after,.markdown-body code::before{letter-spacing:-.2em;content:\"\\A0\"}.markdown-body pre{word-wrap:normal}.markdown-body pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}.markdown-body pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.markdown-body pre code::after,.markdown-body pre code::before{content:normal}.markdown-body .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}.markdown-body kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,\"Liberation Mono\",Menlo,Courier,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:solid 1px #d1d5da;border-bottom-color:#c6cbd1;border-radius:3px;-webkit-box-shadow:inset 0 -1px 0 #c6cbd1;box-shadow:inset 0 -1px 0 #c6cbd1}.markdown-body :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item+.task-list-item{margin-top:3px}.markdown-body .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}.markdown-body hr{border-bottom-color:#eee}.gt-container{-webkit-box-sizing:border-box;box-sizing:border-box;font-size:16px}.gt-container *{-webkit-box-sizing:border-box;box-sizing:border-box}.gt-container a{color:#6190e8}.gt-container a:hover{color:#81a6ed;border-color:#81a6ed}.gt-container a.is--active{color:#333;cursor:default!important}.gt-container a.is--active:hover{color:#333}.gt-container .hide{display:none!important}.gt-container .gt-svg{display:inline-block;width:1em;height:1em;vertical-align:sub}.gt-container .gt-svg svg{width:100%;height:100%;fill:#6190e8}.gt-container .gt-ico{display:inline-block}.gt-container .gt-ico-text{margin-left:.3125em}.gt-container .gt-ico-github .gt-svg{width:100%;height:100%}.gt-container .gt-ico-github svg{fill:inherit}.gt-container .gt-spinner{position:relative}.gt-container .gt-spinner::before{content:'';-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;top:3px;width:.75em;height:.75em;margin-top:-.1875em;margin-left:-.375em;border-radius:50%;border:1px solid #fff;border-top-color:#6190e8;-webkit-animation:gt-kf-rotate .6s linear infinite;animation:gt-kf-rotate .6s linear infinite}.gt-container .gt-loader{position:relative;border:1px solid #999;-webkit-animation:ease gt-kf-rotate 1.5s infinite;animation:ease gt-kf-rotate 1.5s infinite;display:inline-block;font-style:normal;width:1.75em;height:1.75em;line-height:1.75em;border-radius:50%}.gt-container .gt-loader:before{content:'';position:absolute;display:block;top:0;left:50%;margin-top:-.1875em;margin-left:-.1875em;width:.375em;height:.375em;background-color:#999;border-radius:50%}.gt-container .gt-avatar{display:inline-block;width:3.125em;height:3.125em}@media (max-width:479px){.gt-container .gt-avatar{width:2em;height:2em}}.gt-container .gt-avatar img{width:100%;height:auto;border-radius:3px}.gt-container .gt-avatar-github{width:3em;height:3em}@media (max-width:479px){.gt-container .gt-avatar-github{width:1.875em;height:1.875em}}.gt-container .gt-btn{padding:.75em 1.25em;display:inline-block;line-height:1;text-decoration:none;white-space:nowrap;cursor:pointer;border:1px solid #6190e8;border-radius:5px;background-color:#6190e8;color:#fff;outline:0;font-size:.75em}.gt-container .gt-btn-text{font-weight:400}.gt-container .gt-btn-loading{position:relative;margin-left:.5em;display:inline-block;width:.75em;height:1em;vertical-align:top}.gt-container .gt-btn.is--disable{cursor:not-allowed;opacity:.5}.gt-container .gt-btn-login{margin-right:0}.gt-container .gt-btn-preview{background-color:#fff;color:#6190e8}.gt-container .gt-btn-preview:hover{background-color:#f2f2f2;border-color:#81a6ed}.gt-container .gt-btn-public:hover{background-color:#81a6ed;border-color:#81a6ed}.gt-container .gt-error{text-align:center;margin:.625em;color:#ff3860}.gt-container .gt-initing{padding:1.25em 0;text-align:center}.gt-container .gt-initing-text{margin:.625em auto;font-size:92%}.gt-container .gt-no-init{padding:1.25em 0;text-align:center}.gt-container .gt-link{border-bottom:1px dotted #6190e8}.gt-container .gt-link-counts,.gt-container .gt-link-project{text-decoration:none}.gt-container .gt-meta{margin:1.25em 0;padding:1em 0;position:relative;border-bottom:1px solid #e9e9e9;font-size:1em;position:relative;z-index:10}.gt-container .gt-meta:after,.gt-container .gt-meta:before{content:\" \";display:table}.gt-container .gt-meta:after{clear:both}.gt-container .gt-counts{margin:0 .625em 0 0}.gt-container .gt-user{float:right;margin:0;font-size:92%}.gt-container .gt-user-pic{width:16px;height:16px;vertical-align:top;margin-right:.5em}.gt-container .gt-user-inner{display:inline-block;cursor:pointer}.gt-container .gt-user .gt-ico{margin:0 0 0 .3125em}.gt-container .gt-user .gt-ico svg{fill:inherit}.gt-container .gt-user .is--poping .gt-ico svg{fill:#6190e8}.gt-container .gt-version{color:#a1a1a1;margin-left:.375em}.gt-container .gt-copyright{margin:0 .9375em .5em;border-top:1px solid #e9e9e9;padding-top:.5em}.gt-container .gt-popup{position:absolute;right:0;top:2.375em;background:#fff;display:inline-block;border:1px solid #e9e9e9;padding:.625em 0;font-size:.875em;letter-spacing:.5px}.gt-container .gt-popup .gt-action{cursor:pointer;display:block;margin:.5em 0;padding:0 1.125em;position:relative;text-decoration:none}.gt-container .gt-popup .gt-action.is--active:before{content:'';width:.25em;height:.25em;background:#6190e8;position:absolute;left:.5em;top:.4375em}.gt-container .gt-header{position:relative;display:-webkit-box;display:-ms-flexbox;display:flex}.gt-container .gt-header-comment{-webkit-box-flex:1;-ms-flex:1;flex:1;margin-left:1.25em}@media (max-width:479px){.gt-container .gt-header-comment{margin-left:.875em}}.gt-container .gt-header-textarea{padding:.75em;display:block;-webkit-box-sizing:border-box;box-sizing:border-box;width:100%;min-height:5.125em;max-height:15em;border-radius:5px;border:1px solid rgba(0,0,0,.1);font-size:.875em;word-wrap:break-word;resize:vertical;background-color:#f6f6f6;outline:0;-webkit-transition:all .25s ease;transition:all .25s ease}.gt-container .gt-header-textarea:hover{background-color:#fbfbfb}.gt-container .gt-header-preview{padding:.75em;border-radius:5px;border:1px solid rgba(0,0,0,.1);background-color:#f6f6f6}.gt-container .gt-header-controls{position:relative;margin:.75em 0 0}.gt-container .gt-header-controls:after,.gt-container .gt-header-controls:before{content:\" \";display:table}.gt-container .gt-header-controls:after{clear:both}@media (max-width:479px){.gt-container .gt-header-controls{margin:0}}.gt-container .gt-header-controls-tip{font-size:.875em;color:#6190e8;text-decoration:none;vertical-align:sub}@media (max-width:479px){.gt-container .gt-header-controls-tip{display:none}}.gt-container .gt-header-controls .gt-btn{float:right;margin-left:1.25em}@media (max-width:479px){.gt-container .gt-header-controls .gt-btn{float:none;width:100%;margin:.75em 0 0}}.gt-container:after{content:'';position:fixed;bottom:100%;left:0;right:0;top:0;opacity:0}.gt-container.gt-input-focused{position:relative}.gt-container.gt-input-focused:after{content:'';position:fixed;bottom:0;left:0;right:0;top:0;background:#000;opacity:.6;-webkit-transition:opacity .3s,bottom 0s;transition:opacity .3s,bottom 0s;z-index:9999}.gt-container.gt-input-focused .gt-header-comment{z-index:10000}.gt-container .gt-comments{padding-top:1.25em}.gt-container .gt-comments-null{text-align:center}.gt-container .gt-comments-controls{margin:1.25em 0;text-align:center}.gt-container .gt-comment{position:relative;padding:.625em 0;display:-webkit-box;display:-ms-flexbox;display:flex}.gt-container .gt-comment-content{-webkit-box-flex:1;-ms-flex:1;flex:1;margin-left:1.25em;padding:.75em 1em;background-color:#f9f9f9;overflow:auto;-webkit-transition:all ease .25s;transition:all ease .25s}.gt-container .gt-comment-content:hover{-webkit-box-shadow:0 .625em 3.75em 0 #f4f4f4;box-shadow:0 .625em 3.75em 0 #f4f4f4}@media (max-width:479px){.gt-container .gt-comment-content{margin-left:.875em;padding:.625em .75em}}.gt-container .gt-comment-header{margin-bottom:.5em;font-size:.875em;position:relative}.gt-container .gt-comment-username{font-weight:500;color:#6190e8;text-decoration:none}.gt-container .gt-comment-username:hover{text-decoration:underline}.gt-container .gt-comment-text{margin-left:.5em;color:#a1a1a1}.gt-container .gt-comment-date{margin-left:.5em;color:#a1a1a1}.gt-container .gt-comment-edit,.gt-container .gt-comment-like,.gt-container .gt-comment-reply{position:absolute;height:1.375em}.gt-container .gt-comment-edit:hover,.gt-container .gt-comment-like:hover,.gt-container .gt-comment-reply:hover{cursor:pointer}.gt-container .gt-comment-like{top:0;right:2em}.gt-container .gt-comment-edit,.gt-container .gt-comment-reply{top:0;right:0}.gt-container .gt-comment-body{color:#333!important}.gt-container .gt-comment-admin .gt-comment-content{background-color:#f6f9fe}@-webkit-keyframes gt-kf-rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes gt-kf-rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}} /*# sourceMappingURL=/sm/4d2f55c5b23fd6c85c904869012024ff527166b5727905728041c3e560dbe383.map */"},{"title":"","date":"2022-07-23T16:46:02.434Z","updated":"2022-07-23T16:46:02.399Z","comments":true,"path":"css/jquery.fancybox.min.css","permalink":"https://jhfuture.github.io/css/jquery.fancybox.min.css","excerpt":"","text":"body.compensate-for-scrollbar{overflow:hidden}.fancybox-active{height:auto}.fancybox-is-hidden{left:-9999px;margin:0;position:absolute!important;top:-9999px;visibility:hidden}.fancybox-container{-webkit-backface-visibility:hidden;backface-visibility:hidden;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;height:100%;left:0;position:fixed;-webkit-tap-highlight-color:transparent;top:0;-webkit-transform:translateZ(0);transform:translateZ(0);width:100%;z-index:99992}.fancybox-container *{box-sizing:border-box}.fancybox-bg,.fancybox-inner,.fancybox-outer,.fancybox-stage{bottom:0;left:0;position:absolute;right:0;top:0}.fancybox-outer{-webkit-overflow-scrolling:touch;overflow-y:auto}.fancybox-bg{background:#1e1e1e;opacity:0;transition-duration:inherit;transition-property:opacity;transition-timing-function:cubic-bezier(.47,0,.74,.71)}.fancybox-is-open .fancybox-bg{opacity:.87;transition-timing-function:cubic-bezier(.22,.61,.36,1)}.fancybox-caption,.fancybox-infobar,.fancybox-navigation .fancybox-button,.fancybox-toolbar{direction:ltr;opacity:0;position:absolute;transition:opacity .25s,visibility 0s linear .25s;visibility:hidden;z-index:99997}.fancybox-show-caption .fancybox-caption,.fancybox-show-infobar .fancybox-infobar,.fancybox-show-nav .fancybox-navigation .fancybox-button,.fancybox-show-toolbar .fancybox-toolbar{opacity:1;transition:opacity .25s,visibility 0s;visibility:visible}.fancybox-infobar{color:#ccc;font-size:13px;-webkit-font-smoothing:subpixel-antialiased;height:44px;left:0;line-height:44px;min-width:44px;mix-blend-mode:difference;padding:0 10px;pointer-events:none;text-align:center;top:0;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.fancybox-toolbar{right:0;top:0}.fancybox-stage{direction:ltr;overflow:visible;-webkit-transform:translateZ(0);z-index:99994}.fancybox-is-open .fancybox-stage{overflow:hidden}.fancybox-slide{-webkit-backface-visibility:hidden;backface-visibility:hidden;display:none;height:100%;left:0;outline:none;overflow:auto;-webkit-overflow-scrolling:touch;padding:44px;position:absolute;text-align:center;top:0;transition-property:opacity,-webkit-transform;transition-property:transform,opacity;transition-property:transform,opacity,-webkit-transform;white-space:normal;width:100%;z-index:99994}.fancybox-slide:before{content:\"\";display:inline-block;height:100%;margin-right:-.25em;vertical-align:middle;width:0}.fancybox-is-sliding .fancybox-slide,.fancybox-slide--current,.fancybox-slide--next,.fancybox-slide--previous{display:block}.fancybox-slide--next{z-index:99995}.fancybox-slide--image{overflow:visible;padding:44px 0}.fancybox-slide--image:before{display:none}.fancybox-slide--html{padding:6px 6px 0}.fancybox-slide--iframe{padding:44px 44px 0}.fancybox-content{background:#fff;display:inline-block;margin:0 0 6px;max-width:100%;overflow:auto;padding:0;padding:24px;position:relative;text-align:left;vertical-align:middle}.fancybox-slide--image .fancybox-content{-webkit-animation-timing-function:cubic-bezier(.5,0,.14,1);animation-timing-function:cubic-bezier(.5,0,.14,1);-webkit-backface-visibility:hidden;backface-visibility:hidden;background:transparent;background-repeat:no-repeat;background-size:100% 100%;left:0;margin:0;max-width:none;overflow:visible;padding:0;position:absolute;top:0;-webkit-transform-origin:top left;transform-origin:top left;transition-property:opacity,-webkit-transform;transition-property:transform,opacity;transition-property:transform,opacity,-webkit-transform;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:99995}.fancybox-can-zoomOut .fancybox-content{cursor:zoom-out}.fancybox-can-zoomIn .fancybox-content{cursor:zoom-in}.fancybox-can-drag .fancybox-content{cursor:-webkit-grab;cursor:grab}.fancybox-is-dragging .fancybox-content{cursor:-webkit-grabbing;cursor:grabbing}.fancybox-container [data-selectable=true]{cursor:text}.fancybox-image,.fancybox-spaceball{background:transparent;border:0;height:100%;left:0;margin:0;max-height:none;max-width:none;padding:0;position:absolute;top:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:100%}.fancybox-spaceball{z-index:1}.fancybox-slide--html .fancybox-content{margin-bottom:6px}.fancybox-slide--iframe .fancybox-content,.fancybox-slide--map .fancybox-content,.fancybox-slide--video .fancybox-content{height:100%;margin:0;overflow:visible;padding:0;width:100%}.fancybox-slide--video .fancybox-content{background:#000}.fancybox-slide--map .fancybox-content{background:#e5e3df}.fancybox-slide--iframe .fancybox-content{background:#fff;height:calc(100% - 44px);margin-bottom:44px}.fancybox-iframe,.fancybox-video{background:transparent;border:0;height:100%;margin:0;overflow:hidden;padding:0;width:100%}.fancybox-iframe{vertical-align:top}.fancybox-error{background:#fff;cursor:default;max-width:400px;padding:40px;width:100%}.fancybox-error p{color:#444;font-size:16px;line-height:20px;margin:0;padding:0}.fancybox-button{background:rgba(30,30,30,.6);border:0;border-radius:0;cursor:pointer;display:inline-block;height:44px;margin:0;outline:none;padding:10px;transition:color .2s;vertical-align:top;width:44px}.fancybox-button,.fancybox-button:link,.fancybox-button:visited{color:#ccc}.fancybox-button:focus,.fancybox-button:hover{color:#fff}.fancybox-button.disabled,.fancybox-button.disabled:hover,.fancybox-button[disabled],.fancybox-button[disabled]:hover{color:#888;cursor:default}.fancybox-button svg{display:block;overflow:visible;position:relative;shape-rendering:geometricPrecision}.fancybox-button svg path{fill:transparent;stroke:currentColor;stroke-linejoin:round;stroke-width:3}.fancybox-button--pause svg path:nth-child(1),.fancybox-button--play svg path:nth-child(2){display:none}.fancybox-button--play svg path,.fancybox-button--share svg path,.fancybox-button--thumbs svg path{fill:currentColor}.fancybox-button--share svg path{stroke-width:1}.fancybox-navigation .fancybox-button{height:38px;opacity:0;padding:6px;position:absolute;top:50%;width:38px}.fancybox-show-nav .fancybox-navigation .fancybox-button{transition:opacity .25s,visibility 0s,color .25s}.fancybox-navigation .fancybox-button:after{content:\"\";left:-25px;padding:50px;position:absolute;top:-25px}.fancybox-navigation .fancybox-button--arrow_left{left:6px}.fancybox-navigation .fancybox-button--arrow_right{right:6px}.fancybox-close-small{background:transparent;border:0;border-radius:0;color:#555;cursor:pointer;height:44px;margin:0;padding:6px;position:absolute;right:0;top:0;width:44px;z-index:10}.fancybox-close-small svg{fill:transparent;opacity:.8;stroke:currentColor;stroke-width:1.5;transition:stroke .1s}.fancybox-close-small:focus{outline:none}.fancybox-close-small:hover svg{opacity:1}.fancybox-slide--iframe .fancybox-close-small,.fancybox-slide--image .fancybox-close-small,.fancybox-slide--video .fancybox-close-small{color:#ccc;padding:5px;right:-12px;top:-44px}.fancybox-slide--iframe .fancybox-close-small:hover svg,.fancybox-slide--image .fancybox-close-small:hover svg,.fancybox-slide--video .fancybox-close-small:hover svg{background:transparent;color:#fff}.fancybox-is-scaling .fancybox-close-small,.fancybox-is-zoomable.fancybox-can-drag .fancybox-close-small{display:none}.fancybox-caption{bottom:0;color:#fff;font-size:14px;font-weight:400;left:0;line-height:1.5;padding:25px 44px;right:0}.fancybox-caption:before{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAEtCAQAAABjBcL7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAHRJREFUKM+Vk8EOgDAIQ0vj/3+xBw8qIZZueFnIKC90MCAI8DlrkHGeqqGIU6lVigrBtpCWqeRWoHDNqs0F7VNVBVxmHRlvoVqjaYkdnDIaivH2HqZ5+oZj3JUzWB+cOz4G48Bg+tsJ/tqu4dLC/4Xb+0GcF5BwBC0AA53qAAAAAElFTkSuQmCC);background-repeat:repeat-x;background-size:contain;bottom:0;content:\"\";display:block;left:0;pointer-events:none;position:absolute;right:0;top:-25px;z-index:-1}.fancybox-caption:after{border-bottom:1px solid hsla(0,0%,100%,.3);content:\"\";display:block;left:44px;position:absolute;right:44px;top:0}.fancybox-caption a,.fancybox-caption a:link,.fancybox-caption a:visited{color:#ccc;text-decoration:none}.fancybox-caption a:hover{color:#fff;text-decoration:underline}.fancybox-loading{-webkit-animation:a .8s infinite linear;animation:a .8s infinite linear;background:transparent;border:6px solid hsla(0,0%,39%,.5);border-radius:100%;border-top-color:#fff;height:60px;left:50%;margin:-30px 0 0 -30px;opacity:.6;padding:0;position:absolute;top:50%;width:60px;z-index:99999}@-webkit-keyframes a{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}@keyframes a{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}.fancybox-animated{transition-timing-function:cubic-bezier(0,0,.25,1)}.fancybox-fx-slide.fancybox-slide--previous{opacity:0;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0)}.fancybox-fx-slide.fancybox-slide--next{opacity:0;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}.fancybox-fx-slide.fancybox-slide--current{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}.fancybox-fx-fade.fancybox-slide--next,.fancybox-fx-fade.fancybox-slide--previous{opacity:0;transition-timing-function:cubic-bezier(.19,1,.22,1)}.fancybox-fx-fade.fancybox-slide--current{opacity:1}.fancybox-fx-zoom-in-out.fancybox-slide--previous{opacity:0;-webkit-transform:scale3d(1.5,1.5,1.5);transform:scale3d(1.5,1.5,1.5)}.fancybox-fx-zoom-in-out.fancybox-slide--next{opacity:0;-webkit-transform:scale3d(.5,.5,.5);transform:scale3d(.5,.5,.5)}.fancybox-fx-zoom-in-out.fancybox-slide--current{opacity:1;-webkit-transform:scaleX(1);transform:scaleX(1)}.fancybox-fx-rotate.fancybox-slide--previous{opacity:0;-webkit-transform:rotate(-1turn);transform:rotate(-1turn)}.fancybox-fx-rotate.fancybox-slide--next{opacity:0;-webkit-transform:rotate(1turn);transform:rotate(1turn)}.fancybox-fx-rotate.fancybox-slide--current{opacity:1;-webkit-transform:rotate(0deg);transform:rotate(0deg)}.fancybox-fx-circular.fancybox-slide--previous{opacity:0;-webkit-transform:scale3d(0,0,0) translate3d(-100%,0,0);transform:scale3d(0,0,0) translate3d(-100%,0,0)}.fancybox-fx-circular.fancybox-slide--next{opacity:0;-webkit-transform:scale3d(0,0,0) translate3d(100%,0,0);transform:scale3d(0,0,0) translate3d(100%,0,0)}.fancybox-fx-circular.fancybox-slide--current{opacity:1;-webkit-transform:scaleX(1) translateZ(0);transform:scaleX(1) translateZ(0)}.fancybox-fx-tube.fancybox-slide--previous{-webkit-transform:translate3d(-100%,0,0) scale(.1) skew(-10deg);transform:translate3d(-100%,0,0) scale(.1) skew(-10deg)}.fancybox-fx-tube.fancybox-slide--next{-webkit-transform:translate3d(100%,0,0) scale(.1) skew(10deg);transform:translate3d(100%,0,0) scale(.1) skew(10deg)}.fancybox-fx-tube.fancybox-slide--current{-webkit-transform:translateZ(0) scale(1);transform:translateZ(0) scale(1)}.fancybox-share{background:#f4f4f4;border-radius:3px;max-width:90%;padding:30px;text-align:center}.fancybox-share h1{color:#222;font-size:35px;font-weight:700;margin:0 0 20px}.fancybox-share p{margin:0;padding:0}.fancybox-share__button{border:0;border-radius:3px;display:inline-block;font-size:14px;font-weight:700;line-height:40px;margin:0 5px 10px;min-width:130px;padding:0 15px;text-decoration:none;transition:all .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap}.fancybox-share__button:link,.fancybox-share__button:visited{color:#fff}.fancybox-share__button:hover{text-decoration:none}.fancybox-share__button--fb{background:#3b5998}.fancybox-share__button--fb:hover{background:#344e86}.fancybox-share__button--pt{background:#bd081d}.fancybox-share__button--pt:hover{background:#aa0719}.fancybox-share__button--tw{background:#1da1f2}.fancybox-share__button--tw:hover{background:#0d95e8}.fancybox-share__button svg{height:25px;margin-right:7px;position:relative;top:-1px;vertical-align:middle;width:25px}.fancybox-share__button svg path{fill:#fff}.fancybox-share__input{background:transparent;border:0;border-bottom:1px solid #d7d7d7;border-radius:0;color:#5d5b5b;font-size:14px;margin:10px 0 0;outline:none;padding:10px 15px;width:100%}.fancybox-thumbs{background:#fff;bottom:0;display:none;margin:0;-webkit-overflow-scrolling:touch;-ms-overflow-style:-ms-autohiding-scrollbar;padding:2px 2px 4px;position:absolute;right:0;-webkit-tap-highlight-color:transparent;top:0;width:212px;z-index:99995}.fancybox-thumbs-x{overflow-x:auto;overflow-y:hidden}.fancybox-show-thumbs .fancybox-thumbs{display:block}.fancybox-show-thumbs .fancybox-inner{right:212px}.fancybox-thumbs>ul{font-size:0;height:100%;list-style:none;margin:0;overflow-x:hidden;overflow-y:auto;padding:0;position:absolute;position:relative;white-space:nowrap;width:100%}.fancybox-thumbs-x>ul{overflow:hidden}.fancybox-thumbs-y>ul::-webkit-scrollbar{width:7px}.fancybox-thumbs-y>ul::-webkit-scrollbar-track{background:#fff;border-radius:10px;box-shadow:inset 0 0 6px rgba(0,0,0,.3)}.fancybox-thumbs-y>ul::-webkit-scrollbar-thumb{background:#2a2a2a;border-radius:10px}.fancybox-thumbs>ul>li{-webkit-backface-visibility:hidden;backface-visibility:hidden;cursor:pointer;float:left;height:75px;margin:2px;max-height:calc(100% - 8px);max-width:calc(50% - 4px);outline:none;overflow:hidden;padding:0;position:relative;-webkit-tap-highlight-color:transparent;width:100px}.fancybox-thumbs-loading{background:rgba(0,0,0,.1)}.fancybox-thumbs>ul>li{background-position:50%;background-repeat:no-repeat;background-size:cover}.fancybox-thumbs>ul>li:before{border:4px solid #4ea7f9;bottom:0;content:\"\";left:0;opacity:0;position:absolute;right:0;top:0;transition:all .2s cubic-bezier(.25,.46,.45,.94);z-index:99991}.fancybox-thumbs .fancybox-thumbs-active:before{opacity:1}@media (max-width:800px){.fancybox-thumbs{width:110px}.fancybox-show-thumbs .fancybox-inner{right:110px}.fancybox-thumbs>ul>li{max-width:calc(100% - 10px)}}"},{"title":"","date":"2022-07-23T16:44:06.030Z","updated":"2022-07-23T16:44:06.003Z","comments":true,"path":"css/katex.min.css","permalink":"https://jhfuture.github.io/css/katex.min.css","excerpt":"","text":"@font-face{font-family:KaTeX_AMS;src:url(fonts/KaTeX_AMS-Regular.woff2) format(\"woff2\"),url(fonts/KaTeX_AMS-Regular.woff) format(\"woff\"),url(fonts/KaTeX_AMS-Regular.ttf) format(\"truetype\");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Caligraphic;src:url(fonts/KaTeX_Caligraphic-Bold.woff2) format(\"woff2\"),url(fonts/KaTeX_Caligraphic-Bold.woff) format(\"woff\"),url(fonts/KaTeX_Caligraphic-Bold.ttf) format(\"truetype\");font-weight:700;font-style:normal}@font-face{font-family:KaTeX_Caligraphic;src:url(fonts/KaTeX_Caligraphic-Regular.woff2) format(\"woff2\"),url(fonts/KaTeX_Caligraphic-Regular.woff) format(\"woff\"),url(fonts/KaTeX_Caligraphic-Regular.ttf) format(\"truetype\");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Fraktur;src:url(fonts/KaTeX_Fraktur-Bold.woff2) format(\"woff2\"),url(fonts/KaTeX_Fraktur-Bold.woff) format(\"woff\"),url(fonts/KaTeX_Fraktur-Bold.ttf) format(\"truetype\");font-weight:700;font-style:normal}@font-face{font-family:KaTeX_Fraktur;src:url(fonts/KaTeX_Fraktur-Regular.woff2) format(\"woff2\"),url(fonts/KaTeX_Fraktur-Regular.woff) format(\"woff\"),url(fonts/KaTeX_Fraktur-Regular.ttf) format(\"truetype\");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Main;src:url(fonts/KaTeX_Main-Bold.woff2) format(\"woff2\"),url(fonts/KaTeX_Main-Bold.woff) format(\"woff\"),url(fonts/KaTeX_Main-Bold.ttf) format(\"truetype\");font-weight:700;font-style:normal}@font-face{font-family:KaTeX_Main;src:url(fonts/KaTeX_Main-BoldItalic.woff2) format(\"woff2\"),url(fonts/KaTeX_Main-BoldItalic.woff) format(\"woff\"),url(fonts/KaTeX_Main-BoldItalic.ttf) format(\"truetype\");font-weight:700;font-style:italic}@font-face{font-family:KaTeX_Main;src:url(fonts/KaTeX_Main-Italic.woff2) format(\"woff2\"),url(fonts/KaTeX_Main-Italic.woff) format(\"woff\"),url(fonts/KaTeX_Main-Italic.ttf) format(\"truetype\");font-weight:400;font-style:italic}@font-face{font-family:KaTeX_Main;src:url(fonts/KaTeX_Main-Regular.woff2) format(\"woff2\"),url(fonts/KaTeX_Main-Regular.woff) format(\"woff\"),url(fonts/KaTeX_Main-Regular.ttf) format(\"truetype\");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Math;src:url(fonts/KaTeX_Math-Italic.woff2) format(\"woff2\"),url(fonts/KaTeX_Math-Italic.woff) format(\"woff\"),url(fonts/KaTeX_Math-Italic.ttf) format(\"truetype\");font-weight:400;font-style:italic}@font-face{font-family:KaTeX_SansSerif;src:url(fonts/KaTeX_SansSerif-Bold.woff2) format(\"woff2\"),url(fonts/KaTeX_SansSerif-Bold.woff) format(\"woff\"),url(fonts/KaTeX_SansSerif-Bold.ttf) format(\"truetype\");font-weight:700;font-style:normal}@font-face{font-family:KaTeX_SansSerif;src:url(fonts/KaTeX_SansSerif-Italic.woff2) format(\"woff2\"),url(fonts/KaTeX_SansSerif-Italic.woff) format(\"woff\"),url(fonts/KaTeX_SansSerif-Italic.ttf) format(\"truetype\");font-weight:400;font-style:italic}@font-face{font-family:KaTeX_SansSerif;src:url(fonts/KaTeX_SansSerif-Regular.woff2) format(\"woff2\"),url(fonts/KaTeX_SansSerif-Regular.woff) format(\"woff\"),url(fonts/KaTeX_SansSerif-Regular.ttf) format(\"truetype\");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Script;src:url(fonts/KaTeX_Script-Regular.woff2) format(\"woff2\"),url(fonts/KaTeX_Script-Regular.woff) format(\"woff\"),url(fonts/KaTeX_Script-Regular.ttf) format(\"truetype\");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size1;src:url(fonts/KaTeX_Size1-Regular.woff2) format(\"woff2\"),url(fonts/KaTeX_Size1-Regular.woff) format(\"woff\"),url(fonts/KaTeX_Size1-Regular.ttf) format(\"truetype\");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size2;src:url(fonts/KaTeX_Size2-Regular.woff2) format(\"woff2\"),url(fonts/KaTeX_Size2-Regular.woff) format(\"woff\"),url(fonts/KaTeX_Size2-Regular.ttf) format(\"truetype\");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size3;src:url(fonts/KaTeX_Size3-Regular.woff2) format(\"woff2\"),url(fonts/KaTeX_Size3-Regular.woff) format(\"woff\"),url(fonts/KaTeX_Size3-Regular.ttf) format(\"truetype\");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size4;src:url(fonts/KaTeX_Size4-Regular.woff2) format(\"woff2\"),url(fonts/KaTeX_Size4-Regular.woff) format(\"woff\"),url(fonts/KaTeX_Size4-Regular.ttf) format(\"truetype\");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Typewriter;src:url(fonts/KaTeX_Typewriter-Regular.woff2) format(\"woff2\"),url(fonts/KaTeX_Typewriter-Regular.woff) format(\"woff\"),url(fonts/KaTeX_Typewriter-Regular.ttf) format(\"truetype\");font-weight:400;font-style:normal}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:inline-block;text-align:initial}.katex{font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;white-space:nowrap;text-indent:0;text-rendering:auto}.katex *{-ms-high-contrast-adjust:none!important}.katex .katex-html{display:inline-block}.katex .katex-mathml{position:absolute;clip:rect(1px,1px,1px,1px);padding:0;border:0;height:1px;width:1px;overflow:hidden}.katex .base{position:relative}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathit{font-family:KaTeX_Math;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-weight:700;font-style:italic}.katex .amsrm,.katex .mathbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak{font-family:KaTeX_Fraktur}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr{font-family:KaTeX_Script}.katex .mathsf{font-family:KaTeX_SansSerif}.katex .mainit{font-family:KaTeX_Main;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{display:inline-table;table-layout:fixed}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;vertical-align:bottom;position:relative}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;vertical-align:bottom;font-size:1px;width:2px}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{display:inline-block;width:100%}.katex .mspace{display:inline-block}.katex .mspace.negativethinspace{margin-left:-.16667em}.katex .mspace.muspace{width:.055556em}.katex .mspace.thinspace{width:.16667em}.katex .mspace.negativemediumspace{margin-left:-.22222em}.katex .mspace.mediumspace{width:.22222em}.katex .mspace.thickspace{width:.27778em}.katex .mspace.sixmuspace{width:.333333em}.katex .mspace.eightmuspace{width:.444444em}.katex .mspace.enspace{width:.5em}.katex .mspace.twelvemuspace{width:.666667em}.katex .mspace.quad{width:1em}.katex .mspace.qquad{width:2em}.katex .clap,.katex .llap,.katex .rlap{width:0;position:relative}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{display:inline-block;border:0 solid;position:relative}.katex .overline .overline-line,.katex .underline .underline-line{display:inline-block;width:100%}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer,.katex .sizing{display:inline-block}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{width:0;position:relative}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;margin:0 -.125em;width:.25em;overflow:hidden;position:relative}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{display:block;position:absolute;width:100%;fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1}.katex svg path{stroke:none}.katex .vertical-separator svg{width:.25em}.katex .stretchy{width:100%;display:block;position:relative;overflow:hidden}.katex .stretchy:after,.katex .stretchy:before{content:\"\"}.katex .hide-tail{width:100%;position:relative;overflow:hidden}.katex .halfarrow-left{position:absolute;left:0;width:50.2%;overflow:hidden}.katex .halfarrow-right{position:absolute;right:0;width:50.2%;overflow:hidden}.katex .brace-left{position:absolute;left:0;width:25.1%;overflow:hidden}.katex .brace-center{position:absolute;left:25%;width:50%;overflow:hidden}.katex .brace-right{position:absolute;right:0;width:25.1%;overflow:hidden}.katex .x-arrow-pad{padding:0 .5em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox{box-sizing:border-box;border:.04em solid #000}.katex .fcolorbox{box-sizing:border-box;border:.04em solid}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap+.mbin,.katex .cancel-lap+.mord,.katex .cancel-lap+.msupsub,.katex .mbin+.cancel-lap,.katex .mord+.cancel-lap{margin-left:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}"},{"title":"Repositories","date":"2022-07-22T17:15:12.116Z","updated":"2022-07-22T15:46:36.030Z","comments":false,"path":"repository/index.html","permalink":"https://jhfuture.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-22T15:46:36.031Z","updated":"2022-07-22T15:46:36.031Z","comments":false,"path":"tags/index.html","permalink":"https://jhfuture.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-07-23T16:49:19.459Z","updated":"2022-07-23T16:49:19.440Z","comments":true,"path":"css/jquery.min.js","permalink":"https://jhfuture.github.io/css/jquery.min.js","excerpt":"","text":"/*! jQuery v1.12.4 | (c) jQuery Foundation | jquery.org/license */ !function(a,b){\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(\"jQuery requires a window with a document\");return b(a)}:b(a)}(\"undefined\"!=typeof window?window:this,function(a,b){var c=[],d=a.document,e=c.slice,f=c.concat,g=c.push,h=c.indexOf,i={},j=i.toString,k=i.hasOwnProperty,l={},m=\"1.12.4\",n=function(a,b){return new n.fn.init(a,b)},o=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,p=/^-ms-/,q=/-([\\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:\"\",length:0,toArray:function(){return e.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:e.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a){return n.each(this,a)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(e.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:g,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(\"boolean\"==typeof g&&(j=g,g=arguments[h]||{},h++),\"object\"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(n.isPlainObject(c)||(b=n.isArray(c)))?(b?(b=!1,f=a&&n.isArray(a)?a:[]):f=a&&n.isPlainObject(a)?a:{},g[d]=n.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},n.extend({expando:\"jQuery\"+(m+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return\"function\"===n.type(a)},isArray:Array.isArray||function(a){return\"array\"===n.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){var b=a&&a.toString();return!n.isArray(a)&&b-parseFloat(b)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||\"object\"!==n.type(a)||a.nodeType||n.isWindow(a))return!1;try{if(a.constructor&&!k.call(a,\"constructor\")&&!k.call(a.constructor.prototype,\"isPrototypeOf\"))return!1}catch(c){return!1}if(!l.ownFirst)for(b in a)return k.call(a,b);for(b in a);return void 0===b||k.call(a,b)},type:function(a){return null==a?a+\"\":\"object\"==typeof a||\"function\"==typeof a?i[j.call(a)]||\"object\":typeof a},globalEval:function(b){b&&n.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(p,\"ms-\").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b){var c,d=0;if(s(a)){for(c=a.length;c>d;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?\"\":(a+\"\").replace(o,\"\")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,\"string\"==typeof a?[a]:a):g.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(h)return h.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,g=0,h=[];if(s(a))for(d=a.length;d>g;g++)e=b(a[g],g,c),null!=e&&h.push(e);else for(g in a)e=b(a[g],g,c),null!=e&&h.push(e);return f.apply([],h)},guid:1,proxy:function(a,b){var c,d,f;return\"string\"==typeof b&&(f=a[b],b=a,a=f),n.isFunction(a)?(c=e.call(arguments,2),d=function(){return a.apply(b||this,c.concat(e.call(arguments)))},d.guid=a.guid=a.guid||n.guid++,d):void 0},now:function(){return+new Date},support:l}),\"function\"==typeof Symbol&&(n.fn[Symbol.iterator]=c[Symbol.iterator]),n.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"),function(a,b){i[\"[object \"+b+\"]\"]=b.toLowerCase()});function s(a){var b=!!a&&\"length\"in a&&a.length,c=n.type(a);return\"function\"===c||n.isWindow(a)?!1:\"array\"===c||0===b||\"number\"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=\"sizzle\"+1*new Date,v=a.document,w=0,x=0,y=ga(),z=ga(),A=ga(),B=function(a,b){return a===b&&(l=!0),0},C=1"}],"posts":[{"title":"","slug":"C/Array","date":"2023-02-27T13:18:37.735Z","updated":"2023-02-27T14:15:01.559Z","comments":true,"path":"2023/02/27/C/Array/","link":"","permalink":"https://jhfuture.github.io/2023/02/27/C/Array/","excerpt":"","text":"本文只记录注意点1.数组的定义过程1.定义数组 数组大小必须确定 手动指定大小 [类型] 名字 [大小]； [类型] 名字 [大小]&#x3D;{1，,1} 编译器指定 [类型] Name []&#x3D;{1,12,12} 一种特别的定义方式 [Type] Name {} &#x3D;{[指定下标]&#x3D;1,[指定下标]} int array3[]&#x3D;{[1]&#x3D;1,[4]&#x3D;3}; 数组的长度默认是 最大下标+1 作为函数参数的时候可以 int array[] 。其他情况不行。 2.更改名字数组在声明时，编译器自动为 数组分配了内存地址，这个地址与数组名是绑定的，不可更改。。 123456789int a[]=&#123;12,12,123&#125;int b[2]=a;[Error] incompatible types when assigning to type &#x27;int[2]&#x27; from type &#x27;int *&#x27;int a[]=&#123;12,12,123&#125;int b[2];b=a;都会报错 How? 使用指针 123int a[]=&#123;12,12,1&#125;;int *b;b=a; 但这里会存在一个问题，数组变量变成指针变量后，大小会发生改变。当数组被当成参数传递后，默认传递的是一个 &#x3D;&#x3D;指针变量&#x3D;&#x3D;则使用 sizeof 得到的结果会发生变化。 12345678910111213141516171819202122232425262728int array1[]=&#123;1,1,4,5,5,12&#125;; printf(&quot;转换指针前的大小 %zd \\n&quot;,sizeof(array1)); int *ppp=array1; printf(&quot;转换指针后的大小 %zd \\n&quot;,sizeof(ppp));=================================================转换指针前的大小 24转换指针后的大小 8 void testAaary(int *array1, int array2[])&#123; printf(&quot;传递后array1大小为 %zu \\n&quot;,sizeof(array1)); printf(&quot;传递后array2大小为 %zu \\n&quot;,sizeof(array2));&#125; int main()&#123; int array1[]=&#123;1,1,4,5,5,12&#125;; int array2[]=&#123;2,4,5,6,2,26&#125;; printf(&quot;array1传递前数组的大小为 %zd \\n&quot;,sizeof(array1)); printf(&quot;array2传递前数组的大小为 %zd \\n&quot;,sizeof(array2)); testAaary(array1,array2); return 0;&#125;===========================================array1传递前数组的大小为 24array2传递前数组的大小为 24传递后array1大小为 8传递后array2大小为 8 2.参数传递 一维度数组传递作为参数 1void arrayTest(int array1[],int len)&#123;&#125; 二维或多维度 —-&gt; &#x3D;&#x3D;除了第一维度可以使用参数传递，其他的都需要在定义的时候就写好！ 1void arrayTest(int array1[][3],int len) 直接使用 字面量 进行传参 123int sum_array(int *a,int len);int a=sum_array( (int [])&#123;1,2,3&#125;,5) 3.多维数组并没有什么区别，只是 如果使用 一个 array[0] 访问则是 一整个数组的地址。 1234567 //多维数组printf(&quot;==========多维数组===================\\n&quot;);int array5[][2]=&#123;&#123;123,123&#125;,&#123;124,124&#125;&#125;;//访问变量。 printf(&quot;%d\\n&quot;,array5[0][0]); printf(&quot;%d\\n&quot;,**array5 );printf(&quot;%d\\n&quot;,*(array5[0]) );","categories":[],"tags":[]},{"title":"配置V2rayA","slug":"树莓派/配置V2rayA","date":"2023-02-26T13:34:12.000Z","updated":"2023-02-26T13:43:08.999Z","comments":true,"path":"2023/02/26/树莓派/配置V2rayA/","link":"","permalink":"https://jhfuture.github.io/2023/02/26/%E6%A0%91%E8%8E%93%E6%B4%BE/%E9%85%8D%E7%BD%AEV2rayA/","excerpt":"","text":"配置 V2rayA ,通过 V2ray 实现翻墙。 1.安装 V2rayV2ray官方安装 安装教程 https://github.com/v2fly/fhs-install-v2ray 2.V2rayA 提供的镜像1curl -Ls https://mirrors.v2raya.org/go.sh | sudo bash 安装后可以关掉服务，因为 v2rayA 不依赖于该 systemd 服务。 1sudo systemctl disable v2ray --now 2.安装 V2rayA方法一：通过软件源安装添加公钥#1wget -qO - https://apt.v2raya.org/key/public-key.asc | sudo tee /etc/apt/trusted.gpg.d/v2raya.asc 添加 V2RayA 软件源12echo &quot;deb https://apt.v2raya.org/ v2raya main&quot; | sudo tee /etc/apt/sources.list.d/v2raya.listsudo apt update 安装 V2RayA1sudo apt install v2raya 方法二：手动安装 deb 包下载 deb 包 后可以使用 Gdebi、QApt 等图形化工具来安装，也可以使用命令行： 1sudo apt install /path/download/installer_debian_xxx_vxxx.deb ### 自行替换 deb 包所在的实际路径 启动 v2rayA &#x2F; 设置 v2rayA 自动启动 从 1.5 版开始将不再默认为用户启动 v2rayA 及设置开机自动。 启动 v2rayA 1sudo systemctl start v2raya.service 设置开机自动启动 1sudo systemctl enable v2raya.service 方法二：手动安装 deb 包下载 deb 包 后可以使用 Gdebi、QApt 等图形化工具来安装，也可以使用命令行： 1sudo apt install /path/download/installer_debian_xxx_vxxx.deb ### 自行替换 deb 包所在的实际路径 sudo systemctl enable v2raya.service","categories":[],"tags":[]},{"title":"1-力扣刷题笔记","slug":"leetCode/1-力扣刷题笔记","date":"2023-02-25T06:45:14.000Z","updated":"2023-02-25T10:29:46.192Z","comments":true,"path":"2023/02/25/leetCode/1-力扣刷题笔记/","link":"","permalink":"https://jhfuture.github.io/2023/02/25/leetCode/1-%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"力扣刷题一、数组①双指针1.移动0123456789101112131415161718给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例 1:输入: nums = [0,1,0,3,12]输出: [1,3,12,0,0]示例 2:输入: nums = [0]输出: [0]来源：力扣（LeetCode）链接：https://leetcode.cn/problems/move-zeroes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解法： 123456789101112131415161718class Solution &#123; public void moveZeroes(int[] nums) &#123; //使用双指针法，index1 ,index2 同时指向开头 //index1， 遍历数组，遇到非0 的就将 index1上的放到 index2上，同时 index1和index2向前移动一位 //执行完后，再把 index2 到末尾的全部改成0 if (nums==null) return; int index1=0,index2=0; for (;index1&lt;nums.length;index1++)&#123; if (nums[index1]!=0)&#123; nums[index2++]=nums[index1]; &#125; &#125; // for (;index2&lt; nums.length;index2++)&#123; nums[index2]=0; &#125; &#125;&#125; 解析； &#x2F;&#x2F;使用双指针法，index1 ,index2 同时指向开头 &#x2F;&#x2F;index1， 遍历数组，遇到非0 的就将 index1上的放到 index2上，同时 index1和index2向前移动一位 &#x2F;&#x2F;执行完后，再把 index2 到末尾的全部改成0 原始 4 3 2 7 8 2 3 1 0 1 2 3 4 5 6 7 第一次执行 int x&#x3D;(4-1)%8&#x3D;3; num[3]&#x3D;7+8&#x3D;15; 4 3 2 15 8 2 3 1 0 1 2 3 4 5 6 7 第二次执行 int x&#x3D;(3-1)%8&#x3D;2; num[2]&#x3D;2+8&#x3D;10; 4 3 10 15 8 2 3 1 0 1 2 3 4 5 6 7 第三次执行 int x&#x3D;(10-1)%8&#x3D;1; num[1]&#x3D;4+8&#x3D;12 4 12 10 15 8 2 3 1 0 1 2 3 4 5 6 7 第四次执行 int x&#x3D;(15-1)%8&#x3D;6; num[6]&#x3D;3+8&#x3D;11; 4 9 18 11 8 2 11 1 0 1 2 3 4 5 6 7 第五次执行 int x&#x3D;(8-1)%8&#x3D;7; num[7]&#x3D;1+8&#x3D;9; 4 9 18 11 8 2 11 9 0 1 2 3 4 5 6 7 第六次执行 int x&#x3D;(2-1)%8&#x3D;1; num[1]&#x3D;9+8&#x3D;17; 4 17 18 11 8 2 11 9 0 1 2 3 4 5 6 7 第七次执行 int x&#x3D;(3-1)%8&#x3D;2; num[2]&#x3D;18+8&#x3D;26; 4 17 26 11 8 2 11 9 0 1 2 3 4 5 6 7 第八次执行 int x&#x3D;(9-1)%8&#x3D;0; num[0]&#x3D;4+8&#x3D;12; 12 17 26 11 8 2 11 9 0 1 2 3 4 5 6 7 4+8&#x3D;12 11%8&#x3D;3 2.查找消失的数字(448)给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。 示例 1： 输入：nums &#x3D; [4,3,2,7,8,2,3,1]输出：[5,6] 示例 2： 输入：nums &#x3D; [1,1]输出：[2] 12345678910111213141516171819202122// 查找消失的数字 //numbs长度 为n ,每个值为 1~n。 遇到1 就让 nums[0]+=n; // 2 nums[2-1]+=n; //1.遍历 numbs ,每遇到一个x 就让 numbs[x-1] 增加 n，由于numbs 全部在 1~n 必定大于n 。 //如果没有 i+1 的下标数，那该nums 中下表为 i+1的数则不会增加 //2.遍历 numbs，若 nums[i] 小于 n，则说明 numbs 中没有 i+1的数。 //3.还要注意取回修改后的原值。 public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; int n=nums.length; List&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); for (int num:nums)&#123; int x=(num-1)%n; nums[x]+=n; &#125; for (int i=0;i&lt;n;i++)&#123; if (nums[i]&lt;=n)&#123; integers.add(i+1); &#125; &#125; return integers; &#125; 二、链表1.合并两个有序列表(21)将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]输出：[1,1,2,3,4,4] 链表的合并与数组类似，都可以使用双指针方法进行快速的排序。 12345678910111213141516171819202122232425//合并两个有序链表 public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; //使用循环+双指针 //1.使用一个临时变量resultNode 进行储存结果。 //2.1使用两个指针，同时从 list1 和list2 出发，如果 list1 &gt;= list2，则把 list2 放在 resultNode 后，并将 list 2移动一位 //2.2.反正则 把 list1 放在 resultNode 后 ，list1 移动一位。 //3.resultNode移动 if (list1==null) return list2; if (list2==null) return list1; ListNode resultNode = new ListNode(0); ListNode p=resultNode; while (list1!=null&amp;&amp;list2!=null)&#123; if (list1.val&gt;= list2.val)&#123; p.next=list2; list2=list2.next; &#125;else &#123; p.next=list1; list1=list1.next; &#125; p=p.next; &#125; if (list1!=null) p.next=list1; if (list2!=null) p.next=list2; return resultNode.next; &#125;","categories":[],"tags":[]},{"title":"2-常用注解","slug":"SSM/MyBatis/2-常用注解","date":"2023-02-07T11:29:53.000Z","updated":"2023-02-07T11:39:09.126Z","comments":true,"path":"2023/02/07/SSM/MyBatis/2-常用注解/","link":"","permalink":"https://jhfuture.github.io/2023/02/07/SSM/MyBatis/2-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"1@ Mapkey(“”) 将返回的结果创建为一个大 map, 使用此标签 限定这个 大map 的 key。 结构映射","categories":[],"tags":[]},{"title":"1-MyBatis基本使用","slug":"SSM/MyBatis/1-MyBatis基本使用","date":"2023-02-05T14:00:21.000Z","updated":"2023-02-07T13:07:38.082Z","comments":true,"path":"2023/02/05/SSM/MyBatis/1-MyBatis基本使用/","link":"","permalink":"https://jhfuture.github.io/2023/02/05/SSM/MyBatis/1-MyBatis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"学习思路 学会怎么用 为什么这样用 使用步骤 创建 “mybatis-config.xml” 配置文件 创建好 “mapper.xml映射文件”，并在 “mybatis-config.xml”配置文件中配置好 mapper.xml 的路径 使用 SqlSessionFactoryBuilder创建—-&gt;sqlSessionFactory—-&gt; sqlSession 调用 sqlSession(“mapper.xml中的id,如果有 namespace 则使用 namespace.id。”,”需要传递的参数“) 进行 CRUD 基本使用例子 123456789101112131415161718192021222324252627282930313233try &#123;// 1.创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();// 2.创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;));// 3.创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession();// 4.执行SQL int count = sqlSession.insert(&quot;insertCar&quot;); System.out.println(&quot;更新了几条记录：&quot; + count);// 5.提交 sqlSession.commit(); &#125; catch (Exception e) &#123; // 回滚if (sqlSession != null) &#123;sqlSession.rollback();&#125; e.printStackTrace();&#125; finally &#123; // 6.关闭 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125;&#125; ①、一些基本使用方法1.切换环境 sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(“mybatis-config.xml”), &#x3D;&#x3D;”environmentID”&#x3D;&#x3D;); 12345// 使用指定数据库 SqlSessionFactory sqlSessionFactory1 = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;), &quot;dev&quot;); SqlSession sqlSession1 = sqlSessionFactory1.openSession(true); int count1 = sqlSession1.insert(&quot;insertCar&quot;, car); System.out.println(&quot;插入了几条记录：&quot; + count1); ②、各个环节详细解释1.mybatis-config.xml 配置文件1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--默认使用开发环境--&gt; &lt;!--&lt;environments default=&quot;dev&quot;&gt;--&gt; &lt;!--默认使用生产环境--&gt; &lt;environments default=&quot;production&quot;&gt; &lt;!-- --&gt; &lt;!--开发环境--&gt; &lt;environment id=&quot;dev&quot;&gt;========================================== &lt;!--配置事务管理--&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt;=========================================== &lt;!--配置dataSoure数据源--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/powernode&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!--生产环境--&gt; &lt;environment id=&quot;production&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;========================================== &lt;!--配置 mapper.xml文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;CarMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 注意 default 配置默认的 environment id 事务管理器 采用JDBC的原生事务机制： 开启事务：conn.setAutoCommit(false); 处理业务…… 提交事务：conn.commit(); MANAGED 交给容器去管理事务 —&gt;一般可以交给 spring 或者 springboot 去管理，当 mybatis 找不到容器支持时:也是没有事务。 不区分大小写 可以 使用 properties 外部文件 导入文件 12345&lt;!--引入外部属性资源文件--&gt; &lt;properties resource=&quot;jdbc.properties&quot;&gt; &lt;property name=&quot;jdbc.username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;jdbc.password&quot; value=&quot;root&quot;/&gt; &lt;/properties properties 有两个属性 resource 和 url resource 从类的根路径开始找 url 则从指定的url加载，假设文件放在d:&#x2F;jdbc.properties，这个url可以写成：file:&#x2F;&#x2F;&#x2F;d:&#x2F;jdbc.properties。注意是三个斜杠哦。 使用 变量 12345678$&#123;parametersName&#125;&lt;dataSource type=&quot;POOLED&quot;&gt;&lt;!--$&#123;key&#125;使用--&gt;&lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;&lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;&lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; mappers 也有两个属性 与 properties 相同。 resource 从类的根路径开始找 url 则**从指定的url加载 1.1重要 修改数据源 但凡为 程序提供 Connection 对象的都叫做数据源 12&lt;dataSource type=&quot;POOLED&quot;&gt; type 设置类别三选一 type&#x3D;”[UNPOOLED|POOLED|JNDI UNPOOLED 不使用连接池。 POOLED 使用 mybatis 自己实现的数据库连接池 JNDI – 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。这种数据源配置只需要两个属性： initial_context – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么将会直接从 InitialContext 中寻找 data_source 属性。 data_source – 这是引用数据源实例位置的上下文路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。 2.mapper.xml 文件配置 与使用 配置传入参数 使用步骤 1.配置扫描路径 1.可以在 mybatis-config.xml 或 直接在 springboot 的配置文件中进行配置 2.编写 sql语句 3.调用并传参。 传参 类别 按数量划分 一、多参数方案：一、直接传参​ 底层原理: 在多个参数的情况下，mybatis 会在底层创建一个 mapper 集合。 将传入的参数 封装为 arg0&#x2F;param0 为key的集合。 #{xxx} xxx应该写 arg0 按传入参数的下表开始。 1select * from t_student where name = #&#123;arg0&#125; and sex = #&#123;arg1&#125; 是好处也是痛处 —-&gt;解决方案 @Param 注解 来写名字 案例分析 需求：通过name和sex查询。 123456789101112131415 /** * 根据name和sex查询 * @param name * @param sex * @return */ List&lt;Student&gt; selectByNameAndSex(String name, Character sex);@Testpublic void testSelectByNameAndSex()&#123; List&lt;Student&gt; students = mapper.selectByNameAndSex(&quot;张三&quot;, &#x27;女&#x27;); students.forEach(student -&gt; System.out.println(student));&#125;&lt;select id=&quot;selectByNameAndSex&quot; resultType=&quot;student&quot;&gt; select * from t_student where name = #&#123;name&#125; and sex = #&#123;sex&#125;&lt;/select&gt; 执行结果： 异常信息描述了：name参数找不到，可用的参数包括[arg1, arg0, param1, param2] 修改StudentMapper.xml配置文件：尝试使用[arg1, arg0, param1, param2]去参数 1234&lt;select id=&quot;selectByNameAndSex&quot; resultType=&quot;student&quot;&gt; &lt;!--select * from t_student where name = #&#123;name&#125; and sex = #&#123;sex&#125;--&gt; select * from t_student where name = #&#123;arg0&#125; and sex = #&#123;arg1&#125;&lt;/select&gt; 运行结果： 再次尝试修改StudentMapper.xml文件 123456&lt;select id=&quot;selectByNameAndSex&quot; resultType=&quot;student&quot;&gt; &lt;!--select * from t_student where name = #&#123;name&#125; and sex = #&#123;sex&#125;--&gt; &lt;!--select * from t_student where name = #&#123;arg0&#125; and sex = #&#123;arg1&#125;--&gt; &lt;!--select * from t_student where name = #&#123;param1&#125; and sex = #&#123;param2&#125;--&gt; select * from t_student where name = #&#123;arg0&#125; and sex = #&#123;param2&#125;&lt;/select&gt; 通过测试可以看到： arg0 是第一个参数 param1是第一个参数 arg1 是第二个参数 param2是第二个参数 实现原理：实际上在mybatis底层会创建一个map集合，以arg0&#x2F;param1为key，以方法上的参数为value，例如以下代码： 12345678Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;arg0&quot;, name);map.put(&quot;arg1&quot;, sex);map.put(&quot;param1&quot;, name);map.put(&quot;param2&quot;, sex);// 所以可以这样取值：#&#123;arg0&#125; #&#123;arg1&#125; #&#123;param1&#125; #&#123;param2&#125;// 其本质就是#&#123;map集合的key&#125; 注意：使用mybatis****3.4.2之前的版本时：要用#{0}和#{1}这种形式。 @Param注解—–&gt;解决方案一的痛点可以不用arg0 arg1 param1 param2吗？这个map集合的key我们自定义可以吗？当然可以。使用@Param注解即可。这样可以增强可读性。 实际上在mybatis底层会创建一个map集合，以arg0&#x2F;param1为key，以方法上的参数为value. 可以通过 @Param 指定 传入参数 在 mybatis 底层创建 的mapper 对应的 keyName。 ​ 使用方法 1@Param(&quot;keyName&quot;) 使用案例 1List&lt;Student&gt; selectByNameAndAge(@Param(value=&quot;name&quot;) String name, @Param(&quot;age&quot;) int age); 注意 使用 @param 直接后，arg0 和 argxxx 会失效，但 param0 和 param1 还可以使用。 注解的原理。 方案：二、使用mapper集合方案：三、使用 pojo(domain) 类二、单参数直接传入参数即可，mybatis 会直接将传入的值添加到 对应的地方。 底层是 将占位符 #{xxx} 直接转换为 ？然后调用 selectOne 方法。即xxx里填什么都没关系。 ③、一些技巧1.使用 sql 自动生成的主键，并将其保存到一个地方。 前提是：主键是自动生成的。 业务背景：一个用户有多个角色。 插入一条新的记录之后，自动生成了主键，而这个主键需要在其他表中使用时。 插入一个用户数据的同时需要给该用户分配角色：需要将生成的用户的id插入到角色表的user_id字段上。 第一种方式：可以先插入用户数据，再写一条查询语句获取id，然后再插入user_id字段。【比较麻烦】 第二种方式：mybatis提供了一种方式更加便捷。 方法步骤 在 mapper.xml 映射文件中 1.配置 useGeneratedKeys&#x3D;”true” keyProperty&#x3D;”储存主键的字段名。” 1234567例如&lt;insert id=&quot;insertUseGeneratedKeys&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into t_car(id,car_num,brand,guide_price,produce_time,car_type) values(null,#&#123;carNum&#125;,#&#123;brand&#125;,#&#123;guidePrice&#125;,#&#123;produceTime&#125;,#&#123;carType&#125;)&lt;/insert&gt;即可在传入的 对象中使用 对象.id 得到 1234567891011121314@Testpublic void testInsertUseGeneratedKeys()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); Car car = new Car(); car.setCarNum(&quot;5262&quot;); car.setBrand(&quot;BYD汉&quot;); car.setGuidePrice(30.3); car.setProduceTime(&quot;2020-10-11&quot;); car.setCarType(&quot;新能源&quot;); mapper.insertUseGeneratedKeys(car); SqlSessionUtil.openSession().commit(); ==================== System.out.println(car.getId());&#125; 2.结果映射 1).使用 resultmapper② 使用驼峰命名自动映射。、使用这种方式的前提是：属性名遵循Java的命名规范，数据库表的列名遵循SQL的命名规范。 Java命名规范：首字母小写，后面每个单词首字母大写，遵循驼峰命名方式。 SQL命名规范：全部小写，单词之间采用下划线分割。 比如以下的对应关系： 实体类中的属性名 数据库表的列名 carNum car_num carType car_type produceTime produce_time 3.创建 大 maper4.模糊查询 两种拼接方法 12341.双引号大法 ---&gt; 单引号不行，已经试过了。&quot;%&quot;#&#123;&#125; &quot;#&quot;2.concat 拼接大法concat(&#x27;#&#x27;,#&#123;band&#125;,&#x27;%&#x27;) 需求：查询奔驰系列的汽车。【只要品牌brand中含有奔驰两个字的都查询出来。】 使用${}1234567891011121314151617181920/** * 根据品牌进行模糊查询 * @param likeBrank * @return */List&lt;Car&gt; selectLikeByBrand(String likeBrank);&lt;select id=&quot;selectLikeByBrand&quot; resultType=&quot;Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car where brand like &#x27;%$&#123;brand&#125;%&#x27;&lt;/select&gt;@Testpublic void testSelectLikeByBrand()&#123; CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class); List&lt;Car&gt; cars = mapper.selectLikeByBrand(&quot;奔驰&quot;); cars.forEach(car -&gt; System.out.println(car));&#125; 执行结果： 使用#{}第一种：concat函数 12345678&lt;select id=&quot;selectLikeByBrand&quot; resultType=&quot;Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car where brand like concat(&#x27;%&#x27;,#&#123;brand&#125;,&#x27;%&#x27;)&lt;/select&gt; 执行结果： 第二种：双引号方式 12345678&lt;select id=&quot;selectLikeByBrand&quot; resultType=&quot;Car&quot;&gt; select id,car_num as carNum,brand,guide_price as guidePrice,produce_time as produceTime,car_type as carType from t_car where brand like &quot;%&quot;#&#123;brand&#125;&quot;%&quot;&lt;/select&gt; ④、底层原理一、getMapper 的原理 简要描述: ​ 通过 javassit 生成 dao 接口的代理类。然后 使用字符拼接的方式实现 dao 接口 要实现的方法体。 细节。 1234567891011121314151617181920212223242526272829mybatis基本程序// 1.创建SqlSessionFactoryBuilder对象SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();// 2.创建SqlSessionFactory对象SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;));// 3.创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession();// 4.执行SQLint count = sqlSession.insert(&quot;insertCar&quot;);抽离核心SqlSession sqlSession = sqlSessionFactory.openSession();int count = sqlSession.insert(&quot;insertCar&quot;);这两部每一个都不一样，其他1 2部相同。 // 获取sqlId（这里非常重要：因为这行代码导致以后namespace必须是接口的全限定接口名，sqlId必须是接口中方法的方法名。）String sqlId = daoInterface.getName() + &quot;.&quot; + methodName;// 获取SqlCommondTypeString sqlCommondTypeName = sqlSession.getConfiguration().getMappedStatement(sqlId).getSqlCommandType().name();if (&quot;SELECT&quot;.equals(sqlCommondTypeName)) &#123;methodStr.append(&quot;org.apache.ibatis.session.SqlSession sqlSession = com.powernode.bank.utils.SqlSessionUtil.openSession();&quot;);methodStr.append(&quot;Object obj = sqlSession.selectOne(\\&quot;&quot; + sqlId + &quot;\\&quot;, arg0);&quot;);methodStr.append(&quot;return (&quot; + returnTypeName + &quot;)obj;&quot;);&#125; else if (&quot;UPDATE&quot;.equals(sqlCommondTypeName)) &#123; methodStr.append(&quot;org.apache.ibatis.session.SqlSession sqlSession = com.powernode.bank.utils.SqlSessionUtil.openSession();&quot;);methodStr.append(&quot;int count = sqlSession.update(\\&quot;&quot; + sqlId + &quot;\\&quot;, arg0);&quot;);methodStr.append(&quot;return count;&quot;); &#125; String sqlId &#x3D; daoInterface.getName() + “.” + methodName; daointerface.getName() 获取了接口的全类名 methodName 前面获取了 daointerface 中对应的方法名 &#x3D;&#x3D;这一步 限定了 mapper 文件里 的namespacce必须为接口的全类名，id为方法名。&#x3D;&#x3D; eg: 12345678910&lt;mapper namespace=&quot;mapper.salgradeMapper&quot;&gt; --&gt;接口的全类名 &lt;insert id=&quot;insert&quot;→方法名 &lt;/insert&gt; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;grade&quot; &gt; insert into salgrade(grade,losal,hisal) values (null,#&#123;losal&#125;,#&#123;hisal&#125;) &lt;/insert&gt; &lt;/mapper&gt; ⑤动态 SQL1.拼接 where 一个技巧 where 1&#x3D;1 不会影响条件","categories":[],"tags":[]},{"title":"1-mybatis基本使用.md","slug":"SSM/MyBatis","date":"2023-02-05T13:59:07.000Z","updated":"2023-02-05T13:59:07.025Z","comments":true,"path":"2023/02/05/SSM/MyBatis/","link":"","permalink":"https://jhfuture.github.io/2023/02/05/SSM/MyBatis/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.xml/xerces","date":"2023-02-02T16:25:41.517Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.xml/xerces/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.xml/xerces/","excerpt":"","text":"Apache Xerces v2.12.1Apache Xerces Notice ========================================================================= == NOTICE file corresponding to section 4(d) of the Apache License, == == Version 2.0, in this case for the Apache Xerces Java distribution. == ========================================================================= Apache Xerces Java Copyright 1999-2020 The Apache Software Foundation This product includes software developed at The Apache Software Foundation (http://www.apache.org/). Portions of this software were originally based on the following: - software copyright (c) 1999, IBM Corporation., http://www.ibm.com. - software copyright (c) 1999, Sun Microsystems., http://www.sun.com. - voluntary contributions made by Paul Eng on behalf of the Apache Software Foundation that were originally developed at iClick, Inc., software copyright (c) 1999. Apache 2.0 License Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.xml/xalan","date":"2023-02-02T16:25:41.515Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.xml/xalan/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.xml/xalan/","excerpt":"","text":"Apache Xalan v2.7.2Apache Xalan Notice ====================================================================================== == NOTICE file corresponding to the section 4d of the Apache License, Version 2.0, == == in this case for the Apache Xalan distribution. == ====================================================================================== This product includes software developed by The Apache Software Foundation (http://www.apache.org/). Specifically, we only include the XSLTC portion of the source from the Xalan distribution. The Xalan project has two processors: an interpretive one (Xalan Interpretive) and a compiled one (The XSLT Compiler (XSLTC)). We *only* use the XSLTC part of Xalan; We use the source from the packages that are part of the XSLTC sources. Portions of this software was originally based on the following: - software copyright (c) 1999-2002, Lotus Development Corporation., http://www.lotus.com. - software copyright (c) 2001-2002, Sun Microsystems., http://www.sun.com. - software copyright (c) 2003, IBM Corporation., http://www.ibm.com. - voluntary contributions made by Ovidiu Predescu (ovidiu@cup.hp.com) on behalf of the Apache Software Foundation and was originally developed at Hewlett Packard Company. Apache 2.0 License Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. JLEX COPYRIGHT NOTICE, LICENSE AND DISCLAIMER. Copyright 1996-2003 by Elliot Joel Berk and C. Scott Ananian Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of the authors or their employers not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission. The authors and their employers disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness. In no event shall the authors or their employers be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software.The portions of JLex output which are hard-coded into the JLex source code are (naturally) covered by this same license.","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.xml/jcup","date":"2023-02-02T16:25:41.511Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.xml/jcup/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.xml/jcup/","excerpt":"","text":"CUP Parser Generator for Java v 0.11bCUP Parser Generator License Copyright 1996-2015 by Scott Hudson, Frank Flannery, C. Scott Ananian, Michael Petter Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of the authors or their employers not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission. The authors and their employers disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness. In no event shall the authors or their employers be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software.","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.xml/dom","date":"2023-02-02T16:25:41.508Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.xml/dom/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.xml/dom/","excerpt":"","text":"DOM Level 3 Core Specification v1.0W3C License W3C SOFTWARE NOTICE AND LICENSE http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231 This work (and included software, documentation such as READMEs, or other related items) is being provided by the copyright holders under the following license. By obtaining, using and/or copying this work, you (the licensee) agree that you have read, understood, and will comply with the following terms and conditions. Permission to copy, modify, and distribute this software and its documentation, with or without modification, for any purpose and without fee or royalty is hereby granted, provided that you include the following on ALL copies of the software and documentation or portions thereof, including modifications: 1.The full text of this NOTICE in a location viewable to users of the redistributed or derivative work. 2.Any pre-existing intellectual property disclaimers, notices, or terms and conditions. If none exist, the W3C Software Short Notice should be included (hypertext is preferred, text is permitted) within the body of any redistributed or derivative code. 3.Notice of any changes or modifications to the files, including the date changes were made. (We recommend you provide URIs to the location from which the code is derived.) THIS SOFTWARE AND DOCUMENTATION IS PROVIDED \"AS IS,\" AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE OR DOCUMENTATION WILL NOT INFRINGE ANY THIRD PARTY PATENTS,COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS. COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR DOCUMENTATION. The name and trademarks of copyright holders may NOT be used in advertising or publicity pertaining to the software without specific, written prior permission. Title to copyright in this software and any associated documentation will at all times remain with copyright holders. ____________________________________ This formulation of W3C's notice and license became active on December 31 2002. This version removes the copyright ownership notice such that this license can be used with materials other than those owned by the W3C, reflects that ERCIM is now a host of the W3C, includes references to this specific dated version of the license, and removes the ambiguous grant of \"use\". Otherwise, this version is the same as the previous version and is written so as to preserve the Free Software Foundation's assessment of GPL compatibility and OSI's certification under the Open Source Definition. Please see our Copyright FAQ for common questions about using materials from our site, including specific terms and conditions for packages like libwww, Amaya, and Jigsaw. Other questions about this notice can be directed to site-policy@w3.org.","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.xml/bcel","date":"2023-02-02T16:25:41.505Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.xml/bcel/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.xml/bcel/","excerpt":"","text":"Apache Commons Byte Code Engineering Library (BCEL) Version 6.5.0Apache Commons BCEL Notice Apache Commons BCEL Copyright 2004-2020 The Apache Software Foundation This product includes software developed at The Apache Software Foundation (https://www.apache.org/). Apache 2.0 License Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/libpng","date":"2023-02-02T16:25:41.428Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/libpng/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/libpng/","excerpt":"","text":"libpng v1.6.37libpng License COPYRIGHT NOTICE, DISCLAIMER, and LICENSE ========================================= PNG Reference Library License version 2 --------------------------------------- * Copyright (c) 1995-2019 The PNG Reference Library Authors. * Copyright (c) 2018-2019 Cosmin Truta. * Copyright (c) 2000-2002, 2004, 2006-2018 Glenn Randers-Pehrson. * Copyright (c) 1996-1997 Andreas Dilger. * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc. The software is supplied \"as is\", without warranty of any kind, express or implied, including, without limitation, the warranties of merchantability, fitness for a particular purpose, title, and non-infringement. In no event shall the Copyright owners, or anyone distributing the software, be liable for any damages or other liability, whether in contract, tort or otherwise, arising from, out of, or in connection with the software, or the use or other dealings in the software, even if advised of the possibility of such damage. Permission is hereby granted to use, copy, modify, and distribute this software, or portions hereof, for any purpose, without fee, subject to the following restrictions: 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated, but is not required. 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software. 3. This Copyright notice may not be removed or altered from any source or altered source distribution. PNG Reference Library License version 1 (for libpng 0.5 through 1.6.35) ----------------------------------------------------------------------- libpng versions 1.0.7, July 1, 2000, through 1.6.35, July 15, 2018 are Copyright (c) 2000-2002, 2004, 2006-2018 Glenn Randers-Pehrson, are derived from libpng-1.0.6, and are distributed according to the same disclaimer and license as libpng-1.0.6 with the following individuals added to the list of Contributing Authors: Simon-Pierre Cadieux Eric S. Raymond Mans Rullgard Cosmin Truta Gilles Vollant James Yu Mandar Sahastrabuddhe Google Inc. Vadim Barkov and with the following additions to the disclaimer: There is no warranty against interference with your enjoyment of the library or against infringement. There is no warranty that our efforts or the library will fulfill any of your particular purposes or needs. This library is provided with all faults, and the entire risk of satisfactory quality, performance, accuracy, and effort is with the user. Some files in the \"contrib\" directory and some configure-generated files that are distributed with libpng have other copyright owners, and are released under other open source licenses. libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are Copyright (c) 1998-2000 Glenn Randers-Pehrson, are derived from libpng-0.96, and are distributed according to the same disclaimer and license as libpng-0.96, with the following individuals added to the list of Contributing Authors: Tom Lane Glenn Randers-Pehrson Willem van Schaik libpng versions 0.89, June 1996, through 0.96, May 1997, are Copyright (c) 1996-1997 Andreas Dilger, are derived from libpng-0.88, and are distributed according to the same disclaimer and license as libpng-0.88, with the following individuals added to the list of Contributing Authors: John Bowler Kevin Bracey Sam Bushell Magnus Holmgren Greg Roelofs Tom Tanner Some files in the \"scripts\" directory have other copyright owners, but are released under this license. libpng versions 0.5, May 1995, through 0.88, January 1996, are Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc. For the purposes of this copyright and license, \"Contributing Authors\" is defined as the following set of individuals: Andreas Dilger Dave Martindale Guy Eric Schalnat Paul Schmidt Tim Wegner The PNG Reference Library is supplied \"AS IS\". The Contributing Authors and Group 42, Inc. disclaim all warranties, expressed or implied, including, without limitation, the warranties of merchantability and of fitness for any purpose. The Contributing Authors and Group 42, Inc. assume no liability for direct, indirect, incidental, special, exemplary, or consequential damages, which may result from the use of the PNG Reference Library, even if advised of the possibility of such damage. Permission is hereby granted to use, copy, modify, and distribute this source code, or portions hereof, for any purpose, without fee, subject to the following restrictions: 1. The origin of this source code must not be misrepresented. 2. Altered versions must be plainly marked as such and must not be misrepresented as being the original source. 3. This Copyright notice may not be removed or altered from any source or altered source distribution. The Contributing Authors and Group 42, Inc. specifically permit, without fee, and encourage the use of this source code as a component to supporting the PNG file format in commercial products. If you use this source code in a product, acknowledgment is not required but would be appreciated.","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/lcms","date":"2023-02-02T16:25:41.425Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/lcms/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/lcms/","excerpt":"","text":"Little Color Management System (LCMS) v2.12LCMS License Little Color Management System Copyright (c) 1998-2020 Marti Maria Saguer Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/jpeg","date":"2023-02-02T16:25:41.422Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/jpeg/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/jpeg/","excerpt":"","text":"Independent JPEG Group: JPEG release 6bJPEG License12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970****************************************************************************Copyright (C) 1991-1998, Thomas G. Lane.This software is the work of Tom Lane, Philip Gladstone, Jim Boucher,Lee Crocker, Julian Minguillon, Luis Ortiz, George Phillips, Davide Rossi,Guido Vollbeding, Ge&#x27; Weijers, and other members of the Independent JPEGGroup.IJG is not affiliated with the official ISO JPEG standards committee. The authors make NO WARRANTY or representation, either express or implied,with respect to this software, its quality, accuracy, merchantability, orfitness for a particular purpose. This software is provided &quot;AS IS&quot;,and you, its user, assume the entire risk as to its quality and accuracy.This software is copyright (C) 1991-1998, Thomas G. Lane.All Rights Reserved except as specified below.Permission is hereby granted to use, copy, modify, and distributethis software (or portions thereof) for any purpose, without fee,subject to these conditions:(1) If any part of the source code for this software is distributed,then this README file must be included, with this copyright and no-warrantynotice unaltered; and any additions, deletions, or changes to the originalfiles must be clearly indicated in accompanying documentation.(2) If only executable code is distributed, then the accompanying documentationmust state that &quot;this software is based in part on the work of theIndependent JPEG Group&quot;.(3) Permission for use of this software is granted only if the user acceptsfull responsibility for any undesirable consequences; the authors acceptNO LIABILITY for damages of any kind.These conditions apply to any software derived from or based on the IJG code,not just to the unmodified library. If you use our work, you ought toacknowledge us.Permission is NOT granted for the use of any IJG author&#x27;s name or company namein advertising or publicity relating to this software or products derivedfrom it. This software may be referred to only as &quot;the Independent JPEGGroup&#x27;s software&quot;.We specifically permit and encourage the use of this software as the basisof commercial products, provided that all warranty or liability claims areassumed by the product vendor.It appears that the arithmetic coding option of the JPEG spec is coveredby patents owned by IBM, AT&amp;T, and Mitsubishi. Hence arithmetic codingcannot legally be used without obtaining one or more licenses. For thisreason, support for arithmetic coding has been removed from the freeJPEG software. (Since arithmetic coding provides only a marginal gainover the unpatented Huffman mode, it is unlikely that very manyimplementations will support it.) So far as we are aware, there areno patent restrictions on the remaining code.The IJG distribution formerly included code to read and write GIF files.To avoid entanglement with the Unisys LZW patent, GIF reading supporthas been removed altogether, and the GIF writer has been simplified toproduce &quot;uncompressed GIFs&quot;. This technique does not use the LZW algorithm;the resulting GIF files are larger than usual, but are readable by allstandard GIF decoders.We are required to state that &quot;The Graphics Interchange Format(c) isthe Copyright property of CompuServe Incorporated. GIF(sm) is aService Mark property of CompuServe Incorporated.&quot;****************************************************************************","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/harfbuzz","date":"2023-02-02T16:25:41.419Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/harfbuzz/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/harfbuzz/","excerpt":"","text":"Harfbuzz v2.8Harfbuzz Licensehttps://github.com/harfbuzz/harfbuzz/blob/master/COPYING HarfBuzz is licensed under the so-called \"Old MIT\" license. Details follow. For parts of HarfBuzz that are licensed under different licenses see individual files names COPYING in subdirectories where applicable. Copyright © 2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020 Google, Inc. Copyright © 2018,2019,2020 Ebrahim Byagowi Copyright © 2019,2020 Facebook, Inc. Copyright © 2012 Mozilla Foundation Copyright © 2011 Codethink Limited Copyright © 2008,2010 Nokia Corporation and/or its subsidiary(-ies) Copyright © 2009 Keith Stribley Copyright © 2009 Martin Hosken and SIL International Copyright © 2007 Chris Wilson Copyright © 2006 Behdad Esfahbod Copyright © 2005 David Turner Copyright © 2004,2007,2008,2009,2010 Red Hat, Inc. Copyright © 1998-2004 David Turner and Werner Lemberg For full copyright notices consult the individual files in the package. Permission is hereby granted, without written agreement and without license or royalty fees, to use, copy, modify, and distribute this software and its documentation for any purpose, provided that the above copyright notice and the following two paragraphs appear in all copies of this software. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. All source code, except for one section, is licensed as above. The one exception is licensed with a slightly different MIT variant: The contents of this directory are licensed under the following terms: Copyright (C) 2012 Grigori Goronzy Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/giflib","date":"2023-02-02T16:25:41.416Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/giflib/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/giflib/","excerpt":"","text":"GIFLIB v5.2.1GIFLIB License The GIFLIB distribution is Copyright (c) 1997 Eric S. Raymond Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. https://sourceforge.net/p/giflib/code/ci/master/tree/openbsd-reallocarray.c Copyright (c) 2008 Otto Moerbeek &lt;otto@drijf.net&gt; SPDX-License-Identifier: MIT","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/colorimaging","date":"2023-02-02T16:25:41.411Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/colorimaging/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.desktop/colorimaging/","excerpt":"","text":"Eastman Kodak Company: Portions of color management and imaging softwareEastman Kodak Notice Portions Copyright Eastman Kodak Company 1991-2003","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/zlib","date":"2023-02-02T16:25:41.383Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/zlib/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/zlib/","excerpt":"","text":"zlib v1.2.11zlib License Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software. Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions: 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required. 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software. 3. This notice may not be removed or altered from any source distribution. Jean-loup Gailly Mark Adler jloup@gzip.org madler@alumni.caltech.edu","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/wepoll","date":"2023-02-02T16:25:41.381Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/wepoll/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/wepoll/","excerpt":"","text":"Bert Belder: wepoll v 1.5.8wepoll License1234567891011121314151617181920212223242526272829wepoll - epoll for Windowshttps://github.com/piscisaureus/wepollCopyright 2012-2020, Bert Belder &lt;bertbelder@gmail.com&gt;All rights reserved.Redistribution and use in source and binary forms, with or withoutmodification, are permitted provided that the following conditions aremet: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOTLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FORA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHTOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOTLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANYTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USEOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/unicode","date":"2023-02-02T16:25:41.378Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/unicode/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/unicode/","excerpt":"","text":"The Unicode Standard, Unicode Character Database, Version 13.0.0Unicode Character Database123456789101112131415161718192021222324252627282930313233343536373839404142434445464748UNICODE, INC. LICENSE AGREEMENT - DATA FILES AND SOFTWARESee Terms of Use for definitions of Unicode Inc.&#x27;sData Files and Software.NOTICE TO USER: Carefully read the following legal agreement.BY DOWNLOADING, INSTALLING, COPYING OR OTHERWISE USING UNICODE INC.&#x27;SDATA FILES (&quot;DATA FILES&quot;), AND/OR SOFTWARE (&quot;SOFTWARE&quot;),YOU UNEQUIVOCALLY ACCEPT, AND AGREE TO BE BOUND BY, ALL OF THETERMS AND CONDITIONS OF THIS AGREEMENT.IF YOU DO NOT AGREE, DO NOT DOWNLOAD, INSTALL, COPY, DISTRIBUTE OR USETHE DATA FILES OR SOFTWARE.COPYRIGHT AND PERMISSION NOTICECopyright © 1991-2020 Unicode, Inc. All rights reserved.Distributed under the Terms of Use in https://www.unicode.org/copyright.html.Permission is hereby granted, free of charge, to any person obtaininga copy of the Unicode data files and any associated documentation(the &quot;Data Files&quot;) or Unicode software and any associated documentation(the &quot;Software&quot;) to deal in the Data Files or Softwarewithout restriction, including without limitation the rights to use,copy, modify, merge, publish, distribute, and/or sell copies ofthe Data Files or Software, and to permit persons to whom the Data Filesor Software are furnished to do so, provided that either(a) this copyright and permission notice appear with all copiesof the Data Files or Software, or(b) this copyright and permission notice appear in associatedDocumentation.THE DATA FILES AND SOFTWARE ARE PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OFANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THEWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE ANDNONINFRINGEMENT OF THIRD PARTY RIGHTS.IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THISNOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIALDAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHERTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE ORPERFORMANCE OF THE DATA FILES OR SOFTWARE.Except as contained in this notice, the name of a copyright holdershall not be used in advertising or otherwise to promote the sale,use or other dealings in these Data Files or Software without priorwritten authorization of the copyright holder.","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/c-libutl","date":"2023-02-02T16:25:41.363Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/c-libutl/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/c-libutl/","excerpt":"","text":"c-libutl 20160225c-libutl License123456789101112131415161718192021222324252627282930This software is distributed under the terms of the BSD license.== BSD LICENSE =============================================================== (C) 2009 by Remo Dentato (rdentato@gmail.com)Redistribution and use in source and binary forms, with or without modification,are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; ANDANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIEDWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE AREDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FORANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED ANDON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THISSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.http://opensource.org/licenses/bsd-license.php","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/asm","date":"2023-02-02T16:25:41.354Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/asm/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/asm/","excerpt":"","text":"ASM Bytecode Manipulation Framework v8.0.1ASM License Copyright (c) 2000-2011 France Télécom All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 3. Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","categories":[],"tags":[]},{"title":"","slug":"Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/aes","date":"2023-02-02T16:25:41.349Z","updated":"2022-08-20T09:08:38.000Z","comments":true,"path":"2023/02/03/Android/安卓逆向/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/aes/","link":"","permalink":"https://jhfuture.github.io/2023/02/03/Android/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/jadx-gui-1.4.4-with-jre-win/jre/legal/java.base/aes/","excerpt":"","text":"Cryptix AES v3.2.0Cryptix General License Cryptix General License Copyright (c) 1995-2005 The Cryptix Foundation Limited. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the copyright notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE CRYPTIX FOUNDATION LIMITED AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE CRYPTIX FOUNDATION LIMITED OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","categories":[],"tags":[]},{"title":"10-Spring6整合Junit5","slug":"SSM/Spring/10-Spring6整合Junit5","date":"2023-01-14T07:22:22.000Z","updated":"2023-01-14T07:23:24.719Z","comments":true,"path":"2023/01/14/SSM/Spring/10-Spring6整合Junit5/","link":"","permalink":"https://jhfuture.github.io/2023/01/14/SSM/Spring/10-Spring6%E6%95%B4%E5%90%88Junit5/","excerpt":"","text":"十七、Spring6整合JUnit517.1 Spring对JUnit4的支持准备工作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.powernode&lt;/groupId&gt; &lt;artifactId&gt;spring6-015-junit&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--仓库--&gt; &lt;repositories&gt; &lt;!--spring里程碑版本的仓库--&gt; &lt;repository&gt; &lt;id&gt;repository.spring.milestone&lt;/id&gt; &lt;name&gt;Spring Milestone Repository&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.0-M2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring对junit的支持相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;6.0.0-M2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit4依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt;package com.powernode.spring6.bean;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;/** * @author 动力节点 * @version 1.0 * @className User * @since 1.0 **/@Componentpublic class User &#123; @Value(&quot;张三&quot;) private String name; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public User() &#123; &#125; public User(String name) &#123; this.name = name; &#125;&#125;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.powernode.spring6.bean&quot;/&gt;&lt;/beans&gt; 单元测试： 123456789101112131415161718192021222324252627package com.powernode.spring6.test;import com.powernode.spring6.bean.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * @author 动力节点 * @version 1.0 * @className SpringJUnit4Test * @since 1.0 **/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:spring.xml&quot;)public class SpringJUnit4Test &#123; @Autowired private User user; @Test public void testUser()&#123; System.out.println(user.getName()); &#125;&#125; 执行结果如下： Spring提供的方便主要是这几个注解： @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(“classpath:spring.xml”) 在单元测试类上使用这两个注解之后，在单元测试类中的属性上可以使用@Autowired。比较方便。 17.2 Spring对JUnit5的支持引入JUnit5的依赖，Spring对JUnit支持的依赖还是：spring-test，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.powernode&lt;/groupId&gt; &lt;artifactId&gt;spring6-015-junit&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--仓库--&gt; &lt;repositories&gt; &lt;!--spring里程碑版本的仓库--&gt; &lt;repository&gt; &lt;id&gt;repository.spring.milestone&lt;/id&gt; &lt;name&gt;Spring Milestone Repository&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.0-M2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring对junit的支持相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;6.0.0-M2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt;package com.powernode.spring6.test;import com.powernode.spring6.bean.User;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit.jupiter.SpringExtension;@ExtendWith(SpringExtension.class)@ContextConfiguration(&quot;classpath:spring.xml&quot;)public class SpringJUnit5Test &#123; @Autowired private User user; @Test public void testUser()&#123; System.out.println(user.getName()); &#125;&#125; 在JUnit5当中，可以使用Spring提供的以下两个注解，标注到单元测试类上，这样在类当中就可以使用@Autowired注解了。 @ExtendWith(SpringExtension.class) @ContextConfiguration(“classpath:spring.xml”) 十八、Spring6集成MyBatis3.518.1 实现步骤 第一步：准备数据库表 使用t_act表（账户表） 第二步：IDEA中创建一个模块，并引入依赖 spring-context spring-jdbc mysql驱动 mybatis mybatis-spring：mybatis提供的与spring框架集成的依赖 德鲁伊连接池 junit 第三步：基于三层架构实现，所以提前创建好所有的包 com.powernode.bank.mapper com.powernode.bank.service com.powernode.bank.service.impl com.powernode.bank.pojo 第四步：编写pojo Account，属性私有化，提供公开的setter getter和toString。 第五步：编写mapper接口 AccountMapper接口，定义方法 第六步：编写mapper配置文件 在配置文件中配置命名空间，以及每一个方法对应的sql。 第七步：编写service接口和service接口实现类 AccountService AccountServiceImpl 第八步：编写jdbc.properties配置文件 数据库连接池相关信息 第九步：编写mybatis-config.xml配置文件 该文件可以没有，大部分的配置可以转移到spring配置文件中。 如果遇到mybatis相关的系统级配置，还是需要这个文件。 第十步：编写spring.xml配置文件 组件扫描 引入外部的属性文件 数据源 SqlSessionFactoryBean配置 注入mybatis核心配置文件路径 指定别名包 注入数据源 Mapper扫描配置器 指定扫描的包 事务管理器DataSourceTransactionManager 注入数据源 启用事务注解 注入事务管理器 第十一步：编写测试程序，并添加事务，进行测试 18.2 具体实现 第一步：准备数据库表 连接数据库的工具有很多，除了之前我们使用的navicat for mysql之外，也可以使用IDEA工具自带的DataBase插件。可以根据下图提示自行配置： 第二步：IDEA中创建一个模块，并引入依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.powernode&lt;/groupId&gt; &lt;artifactId&gt;spring6-016-sm&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--仓库--&gt; &lt;repositories&gt; &lt;!--spring里程碑版本的仓库--&gt; &lt;repository&gt; &lt;id&gt;repository.spring.milestone&lt;/id&gt; &lt;name&gt;Spring Milestone Repository&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.0-M2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.0-M2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; 第三步：基于三层架构实现，所以提前创建好所有的包 第四步：编写pojo 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.powernode.bank.pojo;/** * @author 动力节点 * @version 1.0 * @className Account * @since 1.0 **/public class Account &#123; private String actno; private Double balance; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;actno=&#x27;&quot; + actno + &#x27;\\&#x27;&#x27; + &quot;, balance=&quot; + balance + &#x27;&#125;&#x27;; &#125; public Account() &#123; &#125; public Account(String actno, Double balance) &#123; this.actno = actno; this.balance = balance; &#125; public String getActno() &#123; return actno; &#125; public void setActno(String actno) &#123; this.actno = actno; &#125; public Double getBalance() &#123; return balance; &#125; public void setBalance(Double balance) &#123; this.balance = balance; &#125;&#125; 第五步：编写mapper接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.powernode.bank.mapper;import com.powernode.bank.pojo.Account;import java.util.List;/** * @author 动力节点 * @version 1.0 * @className AccountMapper * @since 1.0 **/public interface AccountMapper &#123; /** * 保存账户 * @param account * @return */ int insert(Account account); /** * 根据账号删除账户 * @param actno * @return */ int deleteByActno(String actno); /** * 修改账户 * @param account * @return */ int update(Account account); /** * 根据账号查询账户 * @param actno * @return */ Account selectByActno(String actno); /** * 获取所有账户 * @return */ List&lt;Account&gt; selectAll();&#125; 第六步：编写mapper配置文件 一定要注意，按照下图提示创建这个目录。注意是斜杠不是点儿。在resources目录下新建。并且要和Mapper接口包对应上。 如果接口叫做AccountMapper，配置文件必须是AccountMapper.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.powernode.bank.mapper.AccountMapper&quot;&gt; &lt;insert id=&quot;insert&quot;&gt; insert into t_act values(#&#123;actno&#125;, #&#123;balance&#125;) &lt;/insert&gt; &lt;delete id=&quot;deleteByActno&quot;&gt; delete from t_act where actno = #&#123;actno&#125; &lt;/delete&gt; &lt;update id=&quot;update&quot;&gt; update t_act set balance = #&#123;balance&#125; where actno = #&#123;actno&#125; &lt;/update&gt; &lt;select id=&quot;selectByActno&quot; resultType=&quot;Account&quot;&gt; select * from t_act where actno = #&#123;actno&#125; &lt;/select&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;Account&quot;&gt; select * from t_act &lt;/select&gt;&lt;/mapper&gt; 第七步：编写service接口和service接口实现类 注意编写的service实现类纳入IoC容器管理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.powernode.bank.service;import com.powernode.bank.pojo.Account;import java.util.List;/** * @author 动力节点 * @version 1.0 * @className AccountService * @since 1.0 **/public interface AccountService &#123; /** * 开户 * @param act * @return */ int save(Account act); /** * 根据账号销户 * @param actno * @return */ int deleteByActno(String actno); /** * 修改账户 * @param act * @return */ int update(Account act); /** * 根据账号获取账户 * @param actno * @return */ Account getByActno(String actno); /** * 获取所有账户 * @return */ List&lt;Account&gt; getAll(); /** * 转账 * @param fromActno * @param toActno * @param money */ void transfer(String fromActno, String toActno, double money);&#125;package com.powernode.bank.service.impl;import com.powernode.bank.mapper.AccountMapper;import com.powernode.bank.pojo.Account;import com.powernode.bank.service.AccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * @author 动力节点 * @version 1.0 * @className AccountServiceImpl * @since 1.0 **/@Transactional@Service(&quot;accountService&quot;)public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountMapper accountMapper; @Override public int save(Account act) &#123; return accountMapper.insert(act); &#125; @Override public int deleteByActno(String actno) &#123; return accountMapper.deleteByActno(actno); &#125; @Override public int update(Account act) &#123; return accountMapper.update(act); &#125; @Override public Account getByActno(String actno) &#123; return accountMapper.selectByActno(actno); &#125; @Override public List&lt;Account&gt; getAll() &#123; return accountMapper.selectAll(); &#125; @Override public void transfer(String fromActno, String toActno, double money) &#123; Account fromAct = accountMapper.selectByActno(fromActno); if (fromAct.getBalance() &lt; money) &#123; throw new RuntimeException(&quot;余额不足&quot;); &#125; Account toAct = accountMapper.selectByActno(toActno); fromAct.setBalance(fromAct.getBalance() - money); toAct.setBalance(toAct.getBalance() + money); int count = accountMapper.update(fromAct); count += accountMapper.update(toAct); if (count != 2) &#123; throw new RuntimeException(&quot;转账失败&quot;); &#125; &#125;&#125; 第八步：编写jdbc.properties配置文件 放在类的根路径下 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/spring6jdbc.username=rootjdbc.password=root 第九步：编写mybatis-config.xml配置文件 放在类的根路径下，只开启日志，其他配置到spring.xml中。 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt; 第十步：编写spring.xml配置文件 注意：当你在spring.xml文件中直接写标签内容时，IDEA会自动给你添加命名空间 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!--组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.powernode.bank&quot;/&gt; &lt;!--外部属性配置文件--&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt; &lt;!--数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!--SqlSessionFactoryBean--&gt; &lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--mybatis核心配置文件路径--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;mybatis-config.xml&quot;/&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--起别名--&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.powernode.bank.pojo&quot;/&gt; &lt;/bean&gt; &lt;!--Mapper扫描器--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.powernode.bank.mapper&quot;/&gt; &lt;/bean&gt; &lt;!--事务管理器--&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--开启事务注解--&gt; &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;&lt;/beans&gt; 第十一步：编写测试程序，并添加事务，进行测试 1234567891011121314151617181920212223242526272829package com.powernode.spring6.test;import com.powernode.bank.service.AccountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author 动力节点 * @version 1.0 * @className SMTest * @since 1.0 **/public class SMTest &#123; @Test public void testSM()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); AccountService accountService = applicationContext.getBean(&quot;accountService&quot;, AccountService.class); try &#123; accountService.transfer(&quot;act-001&quot;, &quot;act-002&quot;, 10000.0); System.out.println(&quot;转账成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(&quot;转账失败&quot;); &#125; &#125;&#125; 最后大家别忘了测试事务！！！！ 18.3 Spring配置文件的importspring配置文件有多个，并且可以在spring的核心配置文件中使用import进行引入，我们可以将组件扫描单独定义到一个配置文件中，如下： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.powernode.bank&quot;/&gt;&lt;/beans&gt; 然后在核心配置文件中引入： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!--引入其他的spring配置文件--&gt; &lt;import resource=&quot;common.xml&quot;/&gt;&lt;/beans&gt; 注意：在实际开发中，service单独配置到一个文件中，dao单独配置到一个文件中，然后在核心配置文件中引入，养成好习惯。","categories":[{"name":"Spring6","slug":"Spring6","permalink":"https://jhfuture.github.io/categories/Spring6/"}],"tags":[{"name":"事务","slug":"事务","permalink":"https://jhfuture.github.io/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"Spring6","slug":"Spring6","permalink":"https://jhfuture.github.io/tags/Spring6/"}]},{"title":"9-Spring对事务的支持","slug":"SSM/Spring/9-Spring对事务的支持","date":"2023-01-11T12:26:22.000Z","updated":"2023-01-14T07:26:57.452Z","comments":true,"path":"2023/01/11/SSM/Spring/9-Spring对事务的支持/","link":"","permalink":"https://jhfuture.github.io/2023/01/11/SSM/Spring/9-Spring%E5%AF%B9%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%94%AF%E6%8C%81/","excerpt":"","text":"十六、Spring对事务的支持0.注意的点 1)一个事务中如果出现了 异常，即使进行了 try catch 捕获 处理异常，也依然会回滚！。不会提交事务。 —&gt;它不知道你报错的部分，或者后面代码是否还有dml 代码，就直接回滚。 16.1 事务概述 什么是事务 在一个业务流程当中，通常需要多条DML（insert delete update）语句共同联合才能完成，这多条DML语句必须同时成功，或者同时失败，这样才能保证数据的安全。 多条DML要么同时成功，要么同时失败，这叫做事务。 事务：Transaction（tx） 事务的四个处理过程： 第一步：开启事务 (start transaction) 第二步：执行核心业务代码 第三步：提交事务（如果核心业务处理过程中没有出现异常）(commit transaction) 第四步：回滚事务（如果核心业务处理过程中出现异常）(rollback transaction) 事务的四个特性： A 原子性：事务是最小的工作单元，不可再分。 C 一致性：事务要求要么同时成功，要么同时失败。事务前和事务后的总量不变。 I 隔离性：事务和事务之间因为有隔离性，才可以保证互不干扰。 D 持久性：持久性是事务结束的标志。 16.2 引入事务场景以银行账户转账为例学习事务。两个账户act-001和act-002。act-001账户向act-002账户转账10000，必须同时成功，或者同时失败。（一个减成功，一个加成功， 这两条update语句必须同时成功，或同时失败。） 连接数据库的技术采用Spring框架的JdbcTemplate。 采用三层架构搭建： 模块名：spring6-013-tx-bank（依赖如下） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.powernode&lt;/groupId&gt; &lt;artifactId&gt;spring6-013-tx-bank&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--仓库--&gt; &lt;repositories&gt; &lt;!--spring里程碑版本的仓库--&gt; &lt;repository&gt; &lt;id&gt;repository.spring.milestone&lt;/id&gt; &lt;name&gt;Spring Milestone Repository&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--依赖--&gt; &lt;dependencies&gt; &lt;!--spring context--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.0-M2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.0-M2&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;!--德鲁伊连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.13&lt;/version&gt; &lt;/dependency&gt; &lt;!--@Resource注解--&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; 第一步：准备数据库表表结构： 表数据： 第二步：创建包结构com.powernode.bank.pojo com.powernode.bank.service com.powernode.bank.service.impl com.powernode.bank.dao com.powernode.bank.dao.impl 第三步：准备POJO类1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.powernode.bank.pojo;/** * @author 动力节点 * @version 1.0 * @className Account * @since 1.0 **/public class Account &#123; private String actno; private Double balance; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;actno=&#x27;&quot; + actno + &#x27;\\&#x27;&#x27; + &quot;, balance=&quot; + balance + &#x27;&#125;&#x27;; &#125; public Account() &#123; &#125; public Account(String actno, Double balance) &#123; this.actno = actno; this.balance = balance; &#125; public String getActno() &#123; return actno; &#125; public void setActno(String actno) &#123; this.actno = actno; &#125; public Double getBalance() &#123; return balance; &#125; public void setBalance(Double balance) &#123; this.balance = balance; &#125;&#125; 第四步：编写持久层1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.powernode.bank.dao;import com.powernode.bank.pojo.Account;/** * @author 动力节点 * @version 1.0 * @className AccountDao * @since 1.0 **/public interface AccountDao &#123; /** * 根据账号查询余额 * @param actno * @return */ Account selectByActno(String actno); /** * 更新账户 * @param act * @return */ int update(Account act);&#125;package com.powernode.bank.dao.impl;import com.powernode.bank.dao.AccountDao;import com.powernode.bank.pojo.Account;import jakarta.annotation.Resource;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Component;/** * @author 动力节点 * @version 1.0 * @className AccountDaoImpl * @since 1.0 **/@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements AccountDao &#123; @Resource(name = &quot;jdbcTemplate&quot;) private JdbcTemplate jdbcTemplate; @Override public Account selectByActno(String actno) &#123; String sql = &quot;select actno, balance from t_act where actno = ?&quot;; Account account = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Account.class), actno); return account; &#125; @Override public int update(Account act) &#123; String sql = &quot;update t_act set balance = ? where actno = ?&quot;; int count = jdbcTemplate.update(sql, act.getBalance(), act.getActno()); return count; &#125;&#125; 第五步：编写业务层1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.powernode.bank.service;/** * @author 动力节点 * @version 1.0 * @className AccountService * @since 1.0 **/public interface AccountService &#123; /** * 转账 * @param fromActno * @param toActno * @param money */ void transfer(String fromActno, String toActno, double money);&#125;package com.powernode.bank.service.impl;import com.powernode.bank.dao.AccountDao;import com.powernode.bank.pojo.Account;import com.powernode.bank.service.AccountService;import jakarta.annotation.Resource;import org.springframework.stereotype.Service;/** * @author 动力节点 * @version 1.0 * @className AccountServiceImpl * @since 1.0 **/@Service(&quot;accountService&quot;)public class AccountServiceImpl implements AccountService &#123; @Resource(name = &quot;accountDao&quot;) private AccountDao accountDao; @Override public void transfer(String fromActno, String toActno, double money) &#123; // 查询账户余额是否充足 Account fromAct = accountDao.selectByActno(fromActno); if (fromAct.getBalance() &lt; money) &#123; throw new RuntimeException(&quot;账户余额不足&quot;); &#125; // 余额充足，开始转账 Account toAct = accountDao.selectByActno(toActno); fromAct.setBalance(fromAct.getBalance() - money); toAct.setBalance(toAct.getBalance() + money); int count = accountDao.update(fromAct); count += accountDao.update(toAct); if (count != 2) &#123; throw new RuntimeException(&quot;转账失败，请联系银行&quot;); &#125; &#125;&#125; 第六步：编写Spring配置文件123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.powernode.bank&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring6&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 第七步：编写表示层（测试程序）123456789101112131415161718192021222324252627package com.powernode.spring6.test;import com.powernode.bank.service.AccountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author 动力节点 * @version 1.0 * @className BankTest * @since 1.0 **/public class BankTest &#123; @Test public void testTransfer()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); AccountService accountService = applicationContext.getBean(&quot;accountService&quot;, AccountService.class); try &#123; accountService.transfer(&quot;act-001&quot;, &quot;act-002&quot;, 10000); System.out.println(&quot;转账成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果： 数据变化： 模拟异常12345678910111213141516171819202122232425262728293031323334353637383940414243package com.powernode.bank.service.impl;import com.powernode.bank.dao.AccountDao;import com.powernode.bank.pojo.Account;import com.powernode.bank.service.AccountService;import jakarta.annotation.Resource;import org.springframework.stereotype.Service;/** * @author 动力节点 * @version 1.0 * @className AccountServiceImpl * @since 1.0 **/@Service(&quot;accountService&quot;)public class AccountServiceImpl implements AccountService &#123; @Resource(name = &quot;accountDao&quot;) private AccountDao accountDao; @Override public void transfer(String fromActno, String toActno, double money) &#123; // 查询账户余额是否充足 Account fromAct = accountDao.selectByActno(fromActno); if (fromAct.getBalance() &lt; money) &#123; throw new RuntimeException(&quot;账户余额不足&quot;); &#125; // 余额充足，开始转账 Account toAct = accountDao.selectByActno(toActno); fromAct.setBalance(fromAct.getBalance() - money); toAct.setBalance(toAct.getBalance() + money); int count = accountDao.update(fromAct); // 模拟异常 String s = null; s.toString(); count += accountDao.update(toAct); if (count != 2) &#123; throw new RuntimeException(&quot;转账失败，请联系银行&quot;); &#125; &#125;&#125; 执行结果： 数据库表中数据： 丢了1万。 16.3 Spring对事务的支持Spring实现事务的两种方式 编程式事务 通过编写代码的方式来实现事务的管理。 声明式事务 基于注解方式 基于XML配置方式 Spring事务管理APISpring对事务的管理底层实现方式是基于AOP实现的。采用AOP的方式进行了封装。所以Spring专门针对事务开发了一套API，API的核心接口如下： PlatformTransactionManager接口：spring事务管理器的核心接口。在Spring6中它有两个实现： DataSourceTransactionManager：支持JdbcTemplate、MyBatis、Hibernate等事务管理。 JtaTransactionManager：支持分布式事务管理。 如果要在Spring6中使用JdbcTemplate，就要使用DataSourceTransactionManager来管理事务。（Spring内置写好了，可以直接用。） 声明式事务之注解实现方式 第一步：在spring配置文件中配置事务管理器。 123&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; 第二步：在spring配置文件中引入tx命名空间。 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; 第三步：在spring配置文件中配置“事务注解驱动器”，开始注解的方式控制事务。 1&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 第四步：在service类上或方法上添加@Transactional注解 在类上添加该注解，该类中所有的方法都有事务。在某个方法上添加该注解，表示只有这个方法使用事务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.powernode.bank.service.impl;import com.powernode.bank.dao.AccountDao;import com.powernode.bank.pojo.Account;import com.powernode.bank.service.AccountService;import jakarta.annotation.Resource;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;/** * @author 动力节点 * @version 1.0 * @className AccountServiceImpl * @since 1.0 **/@Service(&quot;accountService&quot;)@Transactionalpublic class AccountServiceImpl implements AccountService &#123; @Resource(name = &quot;accountDao&quot;) private AccountDao accountDao; @Override public void transfer(String fromActno, String toActno, double money) &#123; // 查询账户余额是否充足 Account fromAct = accountDao.selectByActno(fromActno); if (fromAct.getBalance() &lt; money) &#123; throw new RuntimeException(&quot;账户余额不足&quot;); &#125; // 余额充足，开始转账 Account toAct = accountDao.selectByActno(toActno); fromAct.setBalance(fromAct.getBalance() - money); toAct.setBalance(toAct.getBalance() + money); int count = accountDao.update(fromAct); // 模拟异常 String s = null; s.toString(); count += accountDao.update(toAct); if (count != 2) &#123; throw new RuntimeException(&quot;转账失败，请联系银行&quot;); &#125; &#125;&#125; 当前数据库表中的数据： 执行测试程序： 虽然出现异常了，再次查看数据库表中数据： 通过测试，发现数据没有变化，事务起作用了。 事务属性事务属性包括哪些 事务中的重点属性： 事务传播行为 事务隔离级别 事务超时 只读事务 设置出现哪些异常回滚事务 设置出现哪些异常不回滚事务 事务传播行为什么是事务的传播行为？ 在service类中有a()方法和b()方法，a()方法上有事务，b()方法上也有事务，当a()方法执行过程中调用了b()方法，事务是如何传递的？合并到一个事务里？还是开启一个新的事务？这就是事务传播行为。 事务传播行为在spring框架中被定义为枚举类型： 一共有七种传播行为： REQUIRED：支持当前事务，如果不存在就新建一个(默认)【没有就新建，有就加入】 SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行【有就加入，没有就不管了】 MANDATORY（强制）：必须运行在一个事务中，如果当前没有事务正在发生，将抛出一个异常【强制你要有就加入，没有就我就闹，我就抛异常】 REQUIRES_NEW：开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起【不管有没有，直接开启一个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起】 ———&gt; &#x3D;&#x3D;并列&#x3D;&#x3D; NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务【不支持事务，存在就挂起】 NEVER：以非事务方式运行，如果有事务存在，抛出异常【 不支持事务，不想要有事务，存在就抛异常】 NESTED：如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于外层事务进行提交或回滚。如果外层事务不存在，行为就像REQUIRED一样。【有事务的话，就在这个事务里再嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚。没有事务就和REQUIRED一样。】 在代码中设置事务的传播行为： 1@Transactional(propagation = Propagation.REQUIRED) 可以编写程序测试一下传播行为： 1234567891011121314151617181920212223242526@Transactional(propagation = Propagation.REQUIRED)public void save(Account act) &#123; // 这里调用dao的insert方法。 accountDao.insert(act); // 保存act-003账户 // 创建账户对象 Account act2 = new Account(&quot;act-004&quot;, 1000.0); try &#123; accountService.save(act2); // 保存act-004账户 &#125; catch (Exception e) &#123; &#125; // 继续往后进行我当前1号事务自己的事儿。&#125;@Override//@Transactional(propagation = Propagation.REQUIRED)@Transactional(propagation = Propagation.REQUIRES_NEW)public void save(Account act) &#123; accountDao.insert(act); // 模拟异常 String s = null; s.toString(); // 事儿没有处理完，这个大括号当中的后续也许还有其他的DML语句。&#125; 一定要集成Log4j2日志框架，在日志信息中可以看到更加详细的信息。 事务隔离级别事务隔离级别类似于教室A和教室B之间的那道墙，隔离级别越高表示墙体越厚。隔音效果越好。 数据库中读取数据存在的三大问题：（三大读问题） 脏读：读取到没有提交到数据库的数据，叫做脏读。 不可重复读：在同一个事务当中，第一次和第二次读取的数据不一样。 幻读：读到的数据是假的。 事务隔离级别包括四个级别： 读未提交：READ_UNCOMMITTED 这种隔离级别，存在脏读问题，所谓的脏读(dirty read)表示能够读取到其它事务未提交的数据。 读提交：READ_COMMITTED 解决了脏读问题，其它事务提交之后才能读到，但存在不可重复读问题。 可重复读：REPEATABLE_READ 解决了不可重复读，可以达到可重复读效果，只要当前事务不结束，读取到的数据一直都是一样的。但存在幻读问题。 序列化：SERIALIZABLE 解决了幻读问题，事务排队执行。不支持并发。 大家可以通过一个表格来记忆： 隔离级别 脏读 不可重复读 幻读 读未提交 有 有 有 读提交 无 有 有 可重复读 无 无 有 序列化 无 无 无 在Spring代码中如何设置隔离级别？ 隔离级别在spring中以枚举类型存在： 1@Transactional(isolation = Isolation.READ_COMMITTED) 测试事务隔离级别：READ_UNCOMMITTED 和 READ_COMMITTED 怎么测试：一个service负责插入，一个service负责查询。负责插入的service要模拟延迟。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.powernode.bank.service.impl;import com.powernode.bank.dao.AccountDao;import com.powernode.bank.pojo.Account;import jakarta.annotation.Resource;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Transactional;/** * @author 动力节点 * @version 1.0 * @className IsolationService1 * @since 1.0 **/@Service(&quot;i1&quot;)public class IsolationService1 &#123; @Resource(name = &quot;accountDao&quot;) private AccountDao accountDao; // 1号 // 负责查询 // 当前事务可以读取到别的事务没有提交的数据。 //@Transactional(isolation = Isolation.READ_UNCOMMITTED) // 对方事务提交之后的数据我才能读取到。 @Transactional(isolation = Isolation.READ_COMMITTED) public void getByActno(String actno) &#123; Account account = accountDao.selectByActno(actno); System.out.println(&quot;查询到的账户信息：&quot; + account); &#125;&#125;package com.powernode.bank.service.impl;import com.powernode.bank.dao.AccountDao;import com.powernode.bank.pojo.Account;import jakarta.annotation.Resource;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;/** * @author 动力节点 * @version 1.0 * @className IsolationService2 * @since 1.0 **/@Service(&quot;i2&quot;)public class IsolationService2 &#123; @Resource(name = &quot;accountDao&quot;) private AccountDao accountDao; // 2号 // 负责insert @Transactional public void save(Account act) &#123; accountDao.insert(act); // 睡眠一会 try &#123; Thread.sleep(1000 * 20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 测试程序 1234567891011121314@Testpublic void testIsolation1()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); IsolationService1 i1 = applicationContext.getBean(&quot;i1&quot;, IsolationService1.class); i1.getByActno(&quot;act-004&quot;);&#125;@Testpublic void testIsolation2()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); IsolationService2 i2 = applicationContext.getBean(&quot;i2&quot;, IsolationService2.class); Account act = new Account(&quot;act-004&quot;, 1000.0); i2.save(act);&#125; 通过执行结果可以清晰的看出隔离级别不同，执行效果不同。 事务超时代码如下： 1@Transactional(timeout = 10) 以上代码表示设置事务的超时时间为10秒。 表示超过10秒如果该事务中所有的DML语句还没有执行完毕的话，最终结果会选择回滚。 默认值-1，表示没有时间限制。 这里有个坑，事务的超时时间指的是哪段时间？ 在当前事务当中，最后一条DML语句执行之前的时间。如果最后一条DML语句后面很有很多业务逻辑，这些业务代码执行的时间不被计入超时时间。 1234567891011121314151617181920@Transactional(timeout = 10) // 设置事务超时时间为10秒。public void save(Account act) &#123; accountDao.insert(act); // 睡眠一会 try &#123; Thread.sleep(1000 * 15); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;@Transactional(timeout = 10) // 设置事务超时时间为10秒。public void save(Account act) &#123; // 睡眠一会 try &#123; Thread.sleep(1000 * 15); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; accountDao.insert(act);&#125; 当然，如果想让整个方法的所有代码都计入超时时间的话，可以在方法最后一行添加一行无关紧要的DML语句。 只读事务代码如下： 1@Transactional(readOnly = true) 将当前事务设置为只读事务，在该事务执行过程中只允许select语句执行，delete insert update均不可执行。 该特性的作用是：启动spring的优化策略。提高select语句执行效率。 如果该事务中确实没有增删改操作，建议设置为只读事务。 设置哪些异常回滚事务代码如下： 1@Transactional(rollbackFor = RuntimeException.class) 表示只有发生RuntimeException异常或该异常的子类异常才回滚。 设置哪些异常不回滚事务代码如下： 1@Transactional(noRollbackFor = NullPointerException.class) 表示发生NullPointerException或该异常的子类异常不回滚，其他异常则回滚。 事务的全注解式开发编写一个类来代替配置文件，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.powernode.bank;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.sql.DataSource;/** * @author 动力节点 * @version 1.0 * @className Spring6Config * @since 1.0 **/@Configuration // 代替spring.xml配置文件，在这个类当中完成配置。@ComponentScan(&quot;com.powernode.bank&quot;) // 组件扫描@EnableTransactionManagement // 开启事务注解public class Spring6Config &#123; // Spring框架，看到这个@Bean注解后，会调用这个被标注的方法，这个方法的返回值是一个java对象，这个java对象会自动纳入IoC容器管理。 // 返回的对象就是Spring容器当中的一个Bean了。 // 并且这个bean的名字是：dataSource @Bean public DataSource getDataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/spring6&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); return dataSource; &#125; @Bean(name = &quot;jdbcTemplate&quot;) public JdbcTemplate getJdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; @Bean public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource)&#123; DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource); return dataSourceTransactionManager; &#125;&#125; 测试程序如下： 1234567891011@Testpublic void testNoXml()&#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Spring6Config.class); AccountService accountService = applicationContext.getBean(&quot;accountService&quot;, AccountService.class); try &#123; accountService.transfer(&quot;act-001&quot;, &quot;act-002&quot;, 10000); System.out.println(&quot;转账成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 执行结果： 数据库表中数据： 声明式事务之XML实现方式配置步骤： 第一步：配置事务管理器 第二步：配置通知 第三步：配置切面 记得添加aspectj的依赖： 123456&lt;!--aspectj依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;6.0.0-M2&lt;/version&gt;&lt;/dependency&gt; Spring配置文件如下： 记得添加aop的命名空间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.powernode.bank&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring6&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--配置通知--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;!- 配置通知的相关属性 --&gt; &lt;tx:attributes&gt; &lt;!-- 之前讲的 事务的属性都可以在以下标签中进行配置 --&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;java.lang.Throwable&quot;/&gt; &lt;!-- *模糊匹配 --&gt; &lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;java.lang.Throwable&quot;/&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;java.lang.Throwable&quot;/&gt; &lt;tx:method name=&quot;transfer*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;java.lang.Throwable&quot;/&gt; &lt;tx:method name=&quot;query&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;get***&quot; read-only=&quot;true&quot;/&gt; &lt;!-- 启用优化策略--&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置切面--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.powernode.bank.service..*(..))&quot;/&gt; &lt;!--切面 = 通知 + 切点--&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 将AccountServiceImpl类上的@Transactional注解删除。 编写测试程序： 1234567891011@Testpublic void testTransferXml()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring2.xml&quot;); AccountService accountService = applicationContext.getBean(&quot;accountService&quot;, AccountService.class); try &#123; accountService.transfer(&quot;act-001&quot;, &quot;act-002&quot;, 10000); System.out.println(&quot;转账成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 执行结果： 数据库表中记录： 通过测试可以看到配置XML已经起作用了。","categories":[{"name":"Spring6","slug":"Spring6","permalink":"https://jhfuture.github.io/categories/Spring6/"}],"tags":[{"name":"事务","slug":"事务","permalink":"https://jhfuture.github.io/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"Spring6","slug":"Spring6","permalink":"https://jhfuture.github.io/tags/Spring6/"}]},{"title":"8-AOP切面编程","slug":"SSM/Spring/8-AOP切面编程","date":"2023-01-10T11:30:04.000Z","updated":"2023-01-11T05:00:23.883Z","comments":true,"path":"2023/01/10/SSM/Spring/8-AOP切面编程/","link":"","permalink":"https://jhfuture.github.io/2023/01/10/SSM/Spring/8-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/","excerpt":"","text":"十五、面向切面编程AOP写着写着代码就要想一下， 我们要不要面向切面 啊？ 我们要不要面向切面啊？ IoC使软件组件松耦合。AOP让你能够捕捉系统中经常使用的功能，把它转化成组件。 AOP（Aspect Oriented Programming）：面向切面编程，面向方面编程。（AOP是一种编程技术） AOP是对OOP的补充延伸。 AOP底层使用的就是动态代理来实现的。 Spring的AOP使用的动态代理JDK动态代理 + CGLIB动态代理技术。&#x3D;&#x3D;Spring在这两种动态代理中灵活切换&#x3D;&#x3D;，如果是代理接口，会默认使用JDK动态代理，如果要代理某个类，这个类没有实现接口，就会切换使用CGLIB。当然，你也可以强制通过一些配置让Spring只使用CGLIB。 1.切面 与业务逻辑不挂钩的业务代码。 15.1 AOP介绍一般一个系统当中都会有一些系统服务，例如：日志、事务管理、安全等。这些系统服务被称为：**&#x3D;&#x3D;交叉业务&#x3D;&#x3D;** 这些&#x3D;&#x3D;**交叉业务&#x3D;&#x3D;**几乎是通用的，不管你是做银行账户转账，还是删除用户数据。日志、事务管理、安全，这些都是需要做的。 如果在每一个业务处理过程当中，都掺杂这些交叉业务代码进去的话，存在两方面问题： 第一：交叉业务代码在多个业务流程中反复出现，显然这个交叉业务代码没有得到复用。并且修改这些交叉业务代码的话，需要修改多处。 第二：程序员无法专注核心业务代码的编写，在编写核心业务代码的同时还需要处理这些交叉业务。 使用AOP可以很轻松的解决以上问题。 请看下图，可以帮助你快速理解AOP的思想： 用一句话总结AOP：将与核心业务无关的代码独立的抽取出来，形成一个独立的组件，然后以横向交叉的方式应用到业务流程当中的过程被称为AOP。 AOP的优点： 第一：代码复用性增强。 第二：代码易维护。 第三：使开发者更关注业务逻辑。 15.2 AOP的七大术语123456789101112131415161718192021222324252627282930313233public class UserService&#123; public void do1()&#123; System.out.println(&quot;do 1&quot;); &#125; public void do2()&#123; System.out.println(&quot;do 2&quot;); &#125; public void do3()&#123; System.out.println(&quot;do 3&quot;); &#125; public void do4()&#123; System.out.println(&quot;do 4&quot;); &#125; public void do5()&#123; System.out.println(&quot;do 5&quot;); &#125; // 核心业务方法 public void service()&#123; try&#123; //joinpoint连接点 do1(); // pointcuy切点 do2(); do3(); do5(); &#125;catch(Exection e)&#123; throw new Exection(e); //异常通知 &#125;finally&#123; //最终通知 &#125; &#125;&#125; 连接点 Joinpoint 在程序的整个执行流程中，可以织入切面的位置。方法的执行前后，异常抛出之后等位置。 切点 Pointcut 在程序执行流程中，真正织入切面的方法。（一个切点对应多个连接点） 通知 Advice 通知又叫增强，就是具体你要织入的代码。 通知包括： 前置通知 —&gt;放在切点前 后置通知—&gt;切点后 环绕通知 –&gt;切点前后都有 异常通知 —&gt;在 catch 异常中 最终通知 –&gt;在 finally 中 切面 Aspect 切点 + 通知就是切面。 织入 Weaving 把通知应用到目标对象上的过程。 代理对象 Proxy 一个目标对象被织入通知后产生的新对象。 目标对象 Target 被织入通知的对象。 通过下图，大家可以很好的理解AOP的相关术语： 15.3 切点表达式切点表达式用来定义通知（Advice）往哪些方法上切入。 切入点表达式语法格式： 123456execution([访问控制权限修饰符] 返回值类型 [全限定类名]方法名(形式参数列表) [异常])带 [] 都是可选项。全限定类名：带包名的类名，不填则为全部含有该方法的类。 访问控制权限修饰符： 可选项。 没写，就是4个权限都包括。 写public就表示只包括公开的方法。 返回值类型： 必填项。 * 表示返回值类型任意。 全限定类名： 可选项。 两个点“..”代表当前包以及子包下的所有类。 省略时表示所有的类。 方法名： 必填项。 *表示所有方法。 set*表示所有的set方法。 形式参数列表： 必填项 () 表示没有参数的方法 (..) 参数类型和个数随意的方法 (*) 只有一个参数的方法 (*, String) 第一个参数类型随意，第二个参数是String的。 异常： 可选项。 省略时表示任意异常类型。 理解以下的切点表达式： 12345execution(public * com.powernode.mall.service.*.delete*(..)) 访问控制符为 public 返回类型为任意， 全类名为com.powernode.mall.service.下所有的类 ，方法名为 delete 形参列表为 任意execution(* com.powernode.mall..*(..)) execution(* *(..)) 15.4 使用Spring的AOPSpring对AOP的实现包括以下3种方式： 第一种方式：Spring框架结合AspectJ框架实现的AOP，基于注解方式。 第二种方式：Spring框架结合AspectJ框架实现的AOP，基于XML方式。 第三种方式：Spring框架自己实现的AOP，基于XML配置方式。 实际开发中，都是Spring+AspectJ来实现AOP。所以我们重点学习第一种和第二种方式。 什么是AspectJ？（Eclipse组织的一个支持AOP的框架。AspectJ框架是独立于Spring框架之外的一个框架，Spring框架用了AspectJ） AspectJ项目起源于帕洛阿尔托（Palo Alto）研究中心（缩写为PARC）。该中心由Xerox集团资助，Gregor Kiczales领导，从1997年开始致力于AspectJ的开发，1998年第一次发布给外部用户，2001年发布1.0 release。为了推动AspectJ技术和社团的发展，PARC在2003年3月正式将AspectJ项目移交给了Eclipse组织，因为AspectJ的发展和受关注程度大大超出了PARC的预期，他们已经无力继续维持它的发展。 15.4.1 准备工作使用Spring+AspectJ的AOP需要引入的依赖如下： 123456789101112131415161718&lt;!--spring context依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.0-M2&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring aop依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;6.0.0-M2&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring aspects依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;6.0.0-M2&lt;/version&gt;&lt;/dependency&gt; Spring配置文件中添加context命名空间和aop命名空间 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;/beans&gt; 15.4.2 基于AspectJ的AOP注解式开发实现步骤第一步：定义目标类以及目标方法 123456789package com.powernode.spring6.service;// 目标类public class OrderService &#123; // 目标方法 public void generate()&#123; System.out.println(&quot;订单已生成！&quot;); &#125;&#125; 第二步：定义切面类 12345678package com.powernode.spring6.service;import org.aspectj.lang.annotation.Aspect;// 切面类@Aspectpublic class MyAspect &#123;&#125; 第三步：目标类和切面类都纳入spring bean管理 在目标类OrderService上添加**@Component**注解。 在切面类MyAspect类上添加**@Component**注解。 第四步：在spring配置文件中添加组建扫描 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--开启组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.powernode.spring6.service&quot;/&gt;&lt;/beans&gt; 第五步：在切面类中添加通知 1234567891011121314package com.powernode.spring6.service;import org.springframework.stereotype.Component;import org.aspectj.lang.annotation.Aspect;// 切面类@Aspect@Componentpublic class MyAspect &#123; // 这就是需要增强的代码（通知） public void advice()&#123; System.out.println(&quot;我是一个通知&quot;); &#125;&#125; 第六步：在通知上添加切点表达式 123456789101112131415161718package com.powernode.spring6.service;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;import org.aspectj.lang.annotation.Aspect;// 切面类@Aspect@Componentpublic class MyAspect &#123; // 切点表达式 @Before(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) // 这就是需要增强的代码（通知） public void advice()&#123; System.out.println(&quot;我是一个通知&quot;); &#125;&#125; 注解@Before表示前置通知。 第七步：在spring配置文件中启用自动代理 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--开启组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.powernode.spring6.service&quot;/&gt; &lt;!--开启自动代理--&gt; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;&lt;/beans&gt; &lt;aop:aspectj-autoproxy proxy-target-class&#x3D;”true”&#x2F;&gt; 开启自动代理之后，凡事带有@Aspect注解的bean都会生成代理对象。 proxy-target-class&#x3D;”true” 表示采用cglib动态代理。 proxy-target-class&#x3D;”false” 表示采用jdk动态代理。默认值是false。即使写成false，当没有接口的时候，也会自动选择cglib生成代理类。 测试程序： 123456789101112131415package com.powernode.spring6.test;import com.powernode.spring6.service.OrderService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AOPTest &#123; @Test public void testAOP()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-aspectj-aop-annotation.xml&quot;); OrderService orderService = applicationContext.getBean(&quot;orderService&quot;, OrderService.class); orderService.generate(); &#125;&#125; 运行结果： 通知类型通知类型包括： 前置通知：@Before 目标方法执行之前的通知 后置通知：@AfterReturning 目标方法执行之后的通知 环绕通知：@Around 目标方法之前添加通知，同时目标方法执行之后添加通知。 异常通知：@AfterThrowing 发生异常之后执行的通知 最终通知：@After 放在finally语句块中的通知 接下来，编写程序来测试这几个通知的执行顺序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.powernode.spring6.service;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;// 切面类@Component@Aspectpublic class MyAspect &#123; @Around(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;环绕通知开始&quot;); // 执行目标方法。 proceedingJoinPoint.proceed(); System.out.println(&quot;环绕通知结束&quot;); &#125; @Before(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void beforeAdvice()&#123; System.out.println(&quot;前置通知&quot;); &#125; @AfterReturning(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void afterReturningAdvice()&#123; System.out.println(&quot;后置通知&quot;); &#125; @AfterThrowing(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void afterThrowingAdvice()&#123; System.out.println(&quot;异常通知&quot;); &#125; @After(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void afterAdvice()&#123; System.out.println(&quot;最终通知&quot;); &#125;&#125;package com.powernode.spring6.service;import org.springframework.stereotype.Component;// 目标类@Componentpublic class OrderService &#123; // 目标方法 public void generate()&#123; System.out.println(&quot;订单已生成！&quot;); &#125;&#125;package com.powernode.spring6.test;import com.powernode.spring6.service.OrderService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AOPTest &#123; @Test public void testAOP()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-aspectj-aop-annotation.xml&quot;); OrderService orderService = applicationContext.getBean(&quot;orderService&quot;, OrderService.class); orderService.generate(); &#125;&#125; 执行结果： 通过上面的执行结果就可以判断他们的执行顺序了，这里不再赘述。 结果中没有异常通知，这是因为目标程序执行过程中没有发生异常。我们尝试让目标方法发生异常： 123456789101112131415package com.powernode.spring6.service;import org.springframework.stereotype.Component;// 目标类@Componentpublic class OrderService &#123; // 目标方法 public void generate()&#123; System.out.println(&quot;订单已生成！&quot;); if (1 == 1) &#123; throw new RuntimeException(&quot;模拟异常发生&quot;); &#125; &#125;&#125; 再次执行测试程序，结果如下： 通过测试得知，当发生异常之后，最终通知也会执行，因为最终通知@After会出现在finally语句块中。 出现异常之后，后置通知和环绕通知的结束部分不会执行。 切面的先后顺序我们知道，业务流程当中不一定只有一个切面，可能有的切面控制事务，有的记录日志，有的进行安全控制，如果多个切面的话，顺序如何控制：可以使用@Order注解来标识切面类，为@Order注解的value指定一个整数型的数字，数字越小，优先级越高。 再定义一个切面类，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.powernode.spring6.service;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;@Aspect@Component@Order(1) //设置优先级public class YourAspect &#123; @Around(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;YourAspect环绕通知开始&quot;); // 执行目标方法。 proceedingJoinPoint.proceed(); System.out.println(&quot;YourAspect环绕通知结束&quot;); &#125; @Before(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void beforeAdvice()&#123; System.out.println(&quot;YourAspect前置通知&quot;); &#125; @AfterReturning(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void afterReturningAdvice()&#123; System.out.println(&quot;YourAspect后置通知&quot;); &#125; @AfterThrowing(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void afterThrowingAdvice()&#123; System.out.println(&quot;YourAspect异常通知&quot;); &#125; @After(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void afterAdvice()&#123; System.out.println(&quot;YourAspect最终通知&quot;); &#125;&#125;package com.powernode.spring6.service;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;// 切面类@Component@Aspect@Order(2) //设置优先级public class MyAspect &#123; @Around(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;环绕通知开始&quot;); // 执行目标方法。 proceedingJoinPoint.proceed(); System.out.println(&quot;环绕通知结束&quot;); &#125; @Before(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void beforeAdvice()&#123; System.out.println(&quot;前置通知&quot;); &#125; @AfterReturning(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void afterReturningAdvice()&#123; System.out.println(&quot;后置通知&quot;); &#125; @AfterThrowing(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void afterThrowingAdvice()&#123; System.out.println(&quot;异常通知&quot;); &#125; @After(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void afterAdvice()&#123; System.out.println(&quot;最终通知&quot;); &#125;&#125; 执行测试程序： 通过修改@Order注解的整数值来切换顺序，执行测试程序： 优化使用切点表达式观看以下代码中的切点表达式： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.powernode.spring6.service;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;// 切面类@Component@Aspect@Order(2)public class MyAspect &#123; @Around(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;环绕通知开始&quot;); // 执行目标方法。 proceedingJoinPoint.proceed(); System.out.println(&quot;环绕通知结束&quot;); &#125; @Before(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void beforeAdvice()&#123; System.out.println(&quot;前置通知&quot;); &#125; @AfterReturning(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void afterReturningAdvice()&#123; System.out.println(&quot;后置通知&quot;); &#125; @AfterThrowing(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void afterThrowingAdvice()&#123; System.out.println(&quot;异常通知&quot;); &#125; @After(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void afterAdvice()&#123; System.out.println(&quot;最终通知&quot;); &#125;&#125; 缺点是： 第一：切点表达式重复写了多次，没有得到复用。 第二：如果要修改切点表达式，需要修改多处，难维护。 可以这样做：将切点表达式单独的定义出来，在需要的位置引入即可。如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.powernode.spring6.service;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;// 切面类@Component@Aspect@Order(2)public class MyAspect &#123; @Pointcut(&quot;execution(* com.powernode.spring6.service.OrderService.*(..))&quot;) public void pointcut()&#123;&#125; @Around(&quot;pointcut()&quot;) public void aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;环绕通知开始&quot;); // 执行目标方法。 proceedingJoinPoint.proceed(); System.out.println(&quot;环绕通知结束&quot;); &#125; @Before(&quot;pointcut()&quot;) public void beforeAdvice()&#123; System.out.println(&quot;前置通知&quot;); &#125; @AfterReturning(&quot;pointcut()&quot;) public void afterReturningAdvice()&#123; System.out.println(&quot;后置通知&quot;); &#125; @AfterThrowing(&quot;pointcut()&quot;) public void afterThrowingAdvice()&#123; System.out.println(&quot;异常通知&quot;); &#125; @After(&quot;pointcut()&quot;) public void afterAdvice()&#123; System.out.println(&quot;最终通知&quot;); &#125;&#125; 使用@Pointcut注解来定义独立的切点表达式。 注意这个@Pointcut注解标注的方法随意，只是起到一个能够让@Pointcut注解编写的位置。 执行测试程序： 1.切点一个小细节 ProceedingJoinPoint 是专门使用在环绕方法(环绕切面)中的切点， 而 JoinPoint 可以使用在任意的切面中。（spring在调用 切面的方法时会自动传递一个 joinpoint 参数） 可以通过切点获得目标方法的签名。 a.ProceedingJoinPoint1234567@Around(&quot;commonCut()&quot;) public void Arround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;环绕通知开始&quot;); proceedingJoinPoint.proceed(); System.out.println(&quot;环绕通知结束&quot;);&#125; b.JoinPoint12345public void before(JoinPoint joinPoint)&#123; Signature signature = joinPoint.getSignature(); System.out.println(&quot;目标方法的方法名&quot;+signature.getName()); System.out.println(&quot;前置通知&quot;);&#125; 目标方法的签名是什么？ —-&gt;从修饰符开始，一直到方法名字。 全注解式开发AOP就是编写一个类，在这个类上面使用大量注解来代替spring的配置文件，spring配置文件消失了，如下： 1234567891011package com.powernode.spring6.service;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration@ComponentScan(&quot;com.powernode.spring6.service&quot;)@EnableAspectJAutoProxy(proxyTargetClass = true)public class Spring6Configuration &#123;&#125; 测试程序也变化了： 123456@Testpublic void testAOPWithAllAnnotation()&#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Spring6Configuration.class); OrderService orderService = applicationContext.getBean(&quot;orderService&quot;, OrderService.class); orderService.generate();&#125; 执行结果如下： 15.4.3 基于XML配置方式的AOP（了解）","categories":[],"tags":[]},{"title":"IoC注解式开发","slug":"SSM/Spring/6-Spring IoC注解式开发","date":"2023-01-07T15:44:02.000Z","updated":"2023-01-11T16:53:36.699Z","comments":true,"path":"2023/01/07/SSM/Spring/6-Spring IoC注解式开发/","link":"","permalink":"https://jhfuture.github.io/2023/01/07/SSM/Spring/6-Spring%20IoC%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%BC%80%E5%8F%91/","excerpt":"","text":"1 回顾注解注解的存在主要是为了简化XML的配置。Spring6倡导全注解开发。 我们来回顾一下： 第一：注解怎么定义，注解中的属性怎么定义？ 第二：注解怎么使用？ 第三：通过反射机制怎么读取注解？ 1.1注解怎么定义，注解中的属性怎么定义？123456789101112package com.powernode.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(value = &#123;ElementType.TYPE&#125;)@Retention(value = RetentionPolicy.RUNTIME)public @interface Component &#123; String value();&#125; 以上是自定义了一个注解：Component 该注解上面修饰的注解包括：Target 注解和 Retention 注解，这两个注解被称为元注解。 元注解：用来注解 注解 的注解。 两个重要的标签 Target 注解用来设置 Component 注解可以出现的位置， ElemtType.Type 以上代表表示Component注解只能用在类和接口上。 Retention注解用来设置Component注解的保持性策略， RetetionPolicy.RUNTIME 以上代表Component注解可以被反射机制读取。 定义的属性 String value(); 是Component注解中的一个属性。 该属性类型String，属性名是value。 1.2.注解怎么使用？1234567package com.powernode.bean;import com.powernode.annotation.Component;@Component(value = &quot;userBean&quot;)public class User &#123;&#125; 语法格式： @注解类型名(属性名&#x3D;属性值, 属性名&#x3D;属性值, 属性名&#x3D;属性值……) userBean为什么使用双引号括起来，因为value属性是String类型，字符串。 另外如果属性名是value，则在使用的时候可以省略属性名，例如： 12345678package com.powernode.bean;import com.powernode.annotation.Component;//@Component(value = &quot;userBean&quot;)@Component(&quot;userBean&quot;)public class User &#123;&#125; 通过反射机制怎么读取注解？ —————–&gt;类的clazz对象.isAnnotationPresent(注解的class对象) 接下来，我们来写一段程序，当Bean类上有Component注解时，则实例化Bean对象，如果没有，则不实例化对象。 我们准备两个Bean，一个上面有注解，一个上面没有注解。 1234567891011package com.powernode.bean;import com.powernode.annotation.Component;@Component(&quot;userBean&quot;)public class User &#123;&#125;package com.powernode.bean;public class Vip &#123;&#125; 假设我们现在只知道包名：com.powernode.bean。至于这个包下有多少个Bean我们不知道。哪些Bean上有注解，哪些Bean上没有注解，这些我们都不知道，如何通过程序全自动化判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.powernode.test;import com.powernode.annotation.Component;import java.io.File;import java.net.URL;import java.util.Arrays;import java.util.Enumeration;import java.util.HashMap;import java.util.Map;/** * @author 动力节点 * @version 1.0 * @className Test * @since 1.0 **/public class Test &#123; public static void main(String[] args) throws Exception &#123; // 存放Bean的Map集合。key存储beanId。value存储Bean。 Map&lt;String,Object&gt; beanMap = new HashMap&lt;&gt;(); String packageName = &quot;com.powernode.bean&quot;; String path = packageName.replaceAll(&quot;\\\\.&quot;, &quot;/&quot;); URL url = ClassLoader.getSystemClassLoader().getResource(path); File file = new File(url.getPath()); File[] files = file.listFiles(); Arrays.stream(files).forEach(f -&gt; &#123; String className = packageName + &quot;.&quot; + f.getName().split(&quot;\\\\.&quot;)[0]; try &#123; Class&lt;?&gt; clazz = Class.forName(className); if (clazz.isAnnotationPresent(Component.class)) &#123; Component component = clazz.getAnnotation(Component.class); String beanId = component.value(); Object bean = clazz.newInstance(); beanMap.put(beanId, bean); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(beanMap); &#125;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665543007882-24036142-350b-4209-bb20-46a61e35716d.png) 2 声明Bean的注解负责声明Bean的注解，常见的包括四个： @Component 其余三个是第一个的别名。 @Controller @Service @Repository 源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.powernode.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(value = &#123;ElementType.TYPE&#125;)@Retention(value = RetentionPolicy.RUNTIME)public @interface Component &#123; String value();&#125;package org.springframework.stereotype;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.annotation.AliasFor;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Controller &#123; @AliasFor( annotation = Component.class ) String value() default &quot;&quot;;&#125;package org.springframework.stereotype;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.annotation.AliasFor;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Service &#123; @AliasFor( annotation = Component.class ) String value() default &quot;&quot;;&#125;package org.springframework.stereotype;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.annotation.AliasFor;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Repository &#123; @AliasFor( annotation = Component.class ) String value() default &quot;&quot;;&#125; 通过源码可以看到，@Controller、@Service、@Repository这三个注解都是@Component注解的别名。 也就是说：这四个注解的功能都一样。用哪个都可以。 只是为了增强程序的可读性，建议： 控制器类上使用：Controller service类上使用：Service dao类上使用：Repository 他们都是只有一个value属性。value属性用来指定bean的id，也就是bean的名字。 ![img](6-Spring IoC注解式开发&#x2F;1665545099269-ebd7e446-bc2f-4442-89b8-3f513e546a8b.png) 3 Spring注解的使用如何使用以上的注解呢？ 第一步：加入aop的依赖 第二步：在配置文件中添加context命名空间 第三步：在配置文件中指定扫描的包 第四步：在Bean类上使用注解 第一步：加入aop的依赖 我们可以看到当加入spring-context依赖之后，会关联加入aop的依赖。所以这一步不用做。 ![img](6-Spring IoC注解式开发&#x2F;1665545268001-e3fb24f3-6688-4f52-a8c7-7c3084fa10a2.png) 第二步：在配置文件中添加context命名空间 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt; 第三步：在配置文件中指定要扫描的包 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.powernode.spring6.bean&quot;/&gt;&lt;/beans&gt; 第四步：在Bean类上使用注解 1234567package com.powernode.spring6.bean;import org.springframework.stereotype.Component;@Component(value = &quot;userBean&quot;)public class User &#123;&#125; 编写测试程序： 123456789101112131415package com.powernode.spring6.test;import com.powernode.spring6.bean.User;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AnnotationTest &#123; @Test public void testBean()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); User userBean = applicationContext.getBean(&quot;userBean&quot;, User.class); System.out.println(userBean); &#125;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665545669944-c067eacb-f65b-45ab-b68b-2320647cdfb4.png) 如果注解的属性名是value，那么value是可以省略的。 12345678910111213141516171819202122package com.powernode.spring6.bean;import org.springframework.stereotype.Component;@Component(&quot;vipBean&quot;)public class Vip &#123;&#125;package com.powernode.spring6.test;import com.powernode.spring6.bean.Vip;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AnnotationTest &#123; @Test public void testBean()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); Vip vipBean = applicationContext.getBean(&quot;vipBean&quot;, Vip.class); System.out.println(vipBean); &#125;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665545860738-8bae2a45-efa8-40eb-9213-0dbd2ae1b54a.png) 如果把value属性彻底去掉，spring会被Bean自动取名吗？会的。并且默认名字的规律是：Bean类名首字母小写即可。 1234567package com.powernode.spring6.bean;import org.springframework.stereotype.Component;@Componentpublic class BankDao &#123;&#125; 也就是说，这个BankDao的bean的名字为：bankDao 测试一下 123456789101112131415package com.powernode.spring6.test;import com.powernode.spring6.bean.BankDao;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AnnotationTest &#123; @Test public void testBean()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); BankDao bankDao = applicationContext.getBean(&quot;bankDao&quot;, BankDao.class); System.out.println(bankDao); &#125;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665546100844-e0ffc213-8126-419a-ab67-7f433ad43105.png) 我们将Component注解换成其它三个注解，看看是否可以用： 1234567package com.powernode.spring6.bean;import org.springframework.stereotype.Controller;@Controllerpublic class BankDao &#123;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665546198246-f9d6adc1-ecc8-4e8c-babf-49f2ed7b87cd.png) 剩下的两个注解大家可以测试一下。 如果是多个包怎么办？有两种解决方案： 第一种：在配置文件中指定多个包，用逗号隔开。 第二种：指定多个包的共同父包。 先来测试一下逗号（英文）的方式： 创建一个新的包：bean2，定义一个Bean类。 1234567package com.powernode.spring6.bean2;import org.springframework.stereotype.Service;@Servicepublic class Order &#123;&#125; 配置文件修改： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.powernode.spring6.bean,com.powernode.spring6.bean2&quot;/&gt;&lt;/beans&gt; 测试程序： 123456789101112131415161718package com.powernode.spring6.test;import com.powernode.spring6.bean.BankDao;import com.powernode.spring6.bean2.Order;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AnnotationTest &#123; @Test public void testBean()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); BankDao bankDao = applicationContext.getBean(&quot;bankDao&quot;, BankDao.class); System.out.println(bankDao); Order order = applicationContext.getBean(&quot;order&quot;, Order.class); System.out.println(order); &#125;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665546710304-8ebbe95d-1d1d-44fa-9605-9dad43e487b7.png) 我们再来看看，指定共同的父包行不行： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.powernode.spring6&quot;/&gt;&lt;/beans&gt; 执行测试程序： ![img](6-Spring IoC注解式开发&#x2F;1665546777022-4eb8c5e3-22ed-4baf-8722-a5fa98df253d.png) 4 选择性实例化Bean假设在某个包下有很多Bean，有的Bean上标注了Component，有的标注了Controller，有的标注了Service，有的标注了Repository，现在由于某种特殊业务的需要，只允许其中所有的Controller参与Bean管理，其他的都不实例化。这应该怎么办呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.powernode.spring6.bean3;import org.springframework.stereotype.Component;import org.springframework.stereotype.Controller;import org.springframework.stereotype.Repository;import org.springframework.stereotype.Service;@Componentpublic class A &#123; public A() &#123; System.out.println(&quot;A的无参数构造方法执行&quot;); &#125;&#125;@Controllerclass B &#123; public B() &#123; System.out.println(&quot;B的无参数构造方法执行&quot;); &#125;&#125;@Serviceclass C &#123; public C() &#123; System.out.println(&quot;C的无参数构造方法执行&quot;); &#125;&#125;@Repositoryclass D &#123; public D() &#123; System.out.println(&quot;D的无参数构造方法执行&quot;); &#125;&#125;@Controllerclass E &#123; public E() &#123; System.out.println(&quot;E的无参数构造方法执行&quot;); &#125;&#125;@Controllerclass F &#123; public F() &#123; System.out.println(&quot;F的无参数构造方法执行&quot;); &#125;&#125; 我只想实例化bean3包下的Controller。配置文件这样写： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.powernode.spring6.bean3&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;/beans&gt; use-default-filters&#x3D;”true” 表示：使用spring默认的规则，只要有Component、Controller、Service、Repository中的任意一个注解标注，则进行实例化。 use-default-filters&#x3D;”false” 表示：不再spring默认实例化规则，即使有Component、Controller、Service、Repository这些注解标注，也不再实例化。 &lt;context:include-filter type&#x3D;”annotation” expression&#x3D;”org.springframework.stereotype.Controller”&#x2F;&gt; 表示只有Controller进行实例化。 1234@Testpublic void testChoose()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-choose.xml&quot;);&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665556059297-de0d7dbc-aa37-46a3-9b1d-1d4c246b0ffc.png) 也可以将use-default-filters设置为true（不写就是true），并且采用exclude-filter方式排出哪些注解标注的Bean不参与实例化： 12345&lt;context:component-scan base-package=&quot;com.powernode.spring6.bean3&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot;/&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 执行测试程序： ![img](6-Spring IoC注解式开发&#x2F;1665556372417-14f2208c-4151-4bcd-9f22-80db5e3ed837.png) 5 负责注入的注解@Component @Controller @Service @Repository 这四个注解是用来声明Bean的，声明后这些Bean将被实例化。接下来我们看一下，如何给Bean的属性赋值。给Bean属性赋值需要用到这些注解： @Value —&gt;简单类型 @Autowired ——–&gt;根据类型注入 @Qualifier —-&gt;配合上面使用名字注入 @Resource —&gt;J 5.1 @Value当属性的类型是简单类型时，可以使用@Value注解进行注入。 1234567891011121314151617181920package com.powernode.spring6.bean4;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class User &#123; @Value(value = &quot;zhangsan&quot;) private String name; @Value(&quot;20&quot;) private int age; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 开启包扫描： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.powernode.spring6.bean4&quot;/&gt;&lt;/beans&gt;@Testpublic void testValue()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-injection.xml&quot;); Object user = applicationContext.getBean(&quot;user&quot;); System.out.println(user);&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665557109935-e0300b67-fd35-4d66-99d1-dac41cb0f13d.png) 通过以上代码可以发现，我们并没有给属性提供setter方法，但仍然可以完成属性赋值。 如果提供setter方法，并且在setter方法上添加@Value注解，可以完成注入吗？尝试一下： 123456789101112131415161718192021222324252627282930package com.powernode.spring6.bean4;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class User &#123; private String name; private int age; @Value(&quot;李四&quot;) public void setName(String name) &#123; this.name = name; &#125; @Value(&quot;30&quot;) public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665557275282-82ba995b-6395-4d32-b322-d976ac3299d1.png) 通过测试可以得知，@Value注解可以直接使用在属性上，也可以使用在setter方法上。都是可以的。都可以完成属性的赋值。 为了简化代码，以后我们一般不提供setter方法，直接在属性上使用@Value注解完成属性赋值。 出于好奇，我们再来测试一下，是否能够通过构造方法完成注入： 12345678910111213141516171819202122232425package com.powernode.spring6.bean4;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class User &#123; private String name; private int age; public User(@Value(&quot;隔壁老王&quot;) String name, @Value(&quot;33&quot;) int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665557643220-1010bea9-5578-4388-8868-4beb11dfbe95.png) 通过测试得知：@Value注解可以出现在属性上、setter方法上、以及构造方法的形参上。可见Spring给我们提供了多样化的注入。太灵活了。 5.2 @Autowired与@Qualifier@Autowired注解可以用来注入非简单类型。被翻译为：自动连线的，或者自动装配。 单独使用@Autowired注解，默认根据类型装配。【默认是byType】 看一下它的源码： 1234567891011121314package org.springframework.beans.factory.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Autowired &#123; boolean required() default true;&#125; 源码中有两处需要注意： 第一处：该注解可以标注在哪里？ 构造方法上 方法上 形参上 属性上 注解上 第二处：该注解有一个required属性，默认值是true，表示在注入的时候要求被注入的Bean必须是存在的，如果不存在则报错。如果required属性设置为false，表示注入的Bean存在或者不存在都没关系，存在的话就注入，不存在的话，也不报错。 我们先在属性上使用@Autowired注解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.powernode.spring6.dao;public interface UserDao &#123; void insert();&#125;package com.powernode.spring6.dao;import org.springframework.stereotype.Repository;@Repository //纳入bean管理public class UserDaoForMySQL implements UserDao&#123; @Override public void insert() &#123; System.out.println(&quot;正在向mysql数据库插入User数据&quot;); &#125;&#125;package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Service // 纳入bean管理public class UserService &#123; @Autowired // 在属性上注入 private UserDao userDao; // 没有提供构造方法和setter方法。 public void save()&#123; userDao.insert(); &#125;&#125;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.powernode.spring6.dao,com.powernode.spring6.service&quot;/&gt;&lt;/beans&gt;@Testpublic void testAutowired()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-injection.xml&quot;); UserService userService = applicationContext.getBean(&quot;userService&quot;, UserService.class); userService.save();&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665561365140-b0200308-0c25-4a29-96be-5a93594e2d2b.png) 以上构造方法和setter方法都没有提供，经过测试，仍然可以注入成功。 接下来，再来测试一下@Autowired注解出现在setter方法上： 1234567891011121314151617181920package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; private UserDao userDao; @Autowired public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void save()&#123; userDao.insert(); &#125;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665562770986-e19377a6-af3e-4082-9463-16c795742ad5.png) 我们再来看看能不能出现在构造方法上： 1234567891011121314151617181920package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; private UserDao userDao; @Autowired public UserService(UserDao userDao) &#123; this.userDao = userDao; &#125; public void save()&#123; userDao.insert(); &#125;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665562985700-7820d3d8-cf43-43af-8c81-46f301ea2835.png) 再来看看，这个注解能不能只标注在构造方法的形参上： 12345678910111213141516171819package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; private UserDao userDao; public UserService(@Autowired UserDao userDao) &#123; this.userDao = userDao; &#125; public void save()&#123; userDao.insert(); &#125;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665563225083-172d5675-cfcb-4f63-9b83-ce85b29b953e.png) 还有更劲爆的，当有参数的构造方法只有一个时，@Autowired注解可以省略。 123456789101112131415161718package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; private UserDao userDao; public UserService(UserDao userDao) &#123; this.userDao = userDao; &#125; public void save()&#123; userDao.insert(); &#125;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665563320900-df9e4cb3-c046-4f5c-b482-42951f18fb16.png) 当然，如果有多个构造方法，@Autowired肯定是不能省略的。 12345678910111213141516171819202122package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; private UserDao userDao; public UserService(UserDao userDao) &#123; this.userDao = userDao; &#125; public UserService()&#123; &#125; public void save()&#123; userDao.insert(); &#125;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665563410134-267b2484-54a3-4204-8e02-a9499ecbe614.png) 到此为止，我们已经清楚@Autowired注解可以出现在哪些位置了。 @Autowired注解默认是byType进行注入的，也就是说根据类型注入的，如果以上程序中，UserDao接口还有另外一个实现类，会出现问题吗？ 1234567891011package com.powernode.spring6.dao;import org.springframework.stereotype.Repository;@Repository //纳入bean管理public class UserDaoForOracle implements UserDao&#123; @Override public void insert() &#123; System.out.println(&quot;正在向Oracle数据库插入User数据&quot;); &#125;&#125; 当你写完这个新的实现类之后，此时IDEA工具已经提示错误信息了： ![img](6-Spring IoC注解式开发&#x2F;1665563729880-0421bc02-19ca-4353-8a10-5b0ef9972b90.png) 错误信息中说：不能装配，UserDao这个Bean的数量大于1. 怎么解决这个问题呢？当然要byName，根据名称进行装配了。 @Autowired注解和@Qualifier注解联合起来才可以根据名称进行装配，在@Qualifier注解中指定Bean名称。 123456789101112131415161718192021222324252627282930313233package com.powernode.spring6.dao;import org.springframework.stereotype.Repository;@Repository // 这里没有给bean起名，默认名字是：userDaoForOraclepublic class UserDaoForOracle implements UserDao&#123; @Override public void insert() &#123; System.out.println(&quot;正在向Oracle数据库插入User数据&quot;); &#125;&#125;package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; private UserDao userDao; @Autowired @Qualifier(&quot;userDaoForOracle&quot;) // 这个是bean的名字。 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void save()&#123; userDao.insert(); &#125;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665564055076-ffda3ad0-f957-4216-bf6c-957d62724d5f.png) 总结： @Autowired注解可以出现在：属性上、构造方法上、构造方法的参数上、setter方法上。 当带参数的构造方法只有一个，@Autowired注解可以省略。 @Autowired注解默认根据类型注入。如果要根据名称注入的话，需要配合@Qualifier注解一起使用。 5.3 @Resource@Resource注解也可以完成非简单类型注入。那它和@Autowired注解有什么区别？ @Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。) @Autowired注解是Spring框架自己的。 @Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。 @Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起用。 @Resource注解用在属性上、setter方法上。 @Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。 @Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【如果是JDK8的话不需要额外引入依赖。高于JDK11或低于JDK8需要引入以下依赖。】 12345&lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; 一定要注意：如果你用Spring6，要知道Spring6不再支持JavaEE，它支持的是JakartaEE9。（Oracle把JavaEE贡献给Apache了，Apache把JavaEE的名字改成JakartaEE了，大家之前所接触的所有的 javax.* 包名统一修改为 jakarta.*包名了。） 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; @Resource注解的源码如下： ![img](6-Spring IoC注解式开发&#x2F;1665565515435-2ad5614a-8572-4c6f-80c1-efa236dbe35f.png) 测试一下： 123456789101112131415161718192021222324252627package com.powernode.spring6.dao;import org.springframework.stereotype.Repository;@Repository(&quot;xyz&quot;)public class UserDaoForOracle implements UserDao&#123; @Override public void insert() &#123; System.out.println(&quot;正在向Oracle数据库插入User数据&quot;); &#125;&#125;package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;import jakarta.annotation.Resource;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; @Resource(name = &quot;xyz&quot;) private UserDao userDao; public void save()&#123; userDao.insert(); &#125;&#125; 执行测试程序： ![img](6-Spring IoC注解式开发&#x2F;1665622877352-0ae69e3c-e7f3-452d-a405-392901612465.png) 我们把UserDaoForOracle的名字xyz修改为userDao，让这个Bean的名字和UserService类中的UserDao属性名一致： 123456789101112131415161718192021222324252627package com.powernode.spring6.dao;import org.springframework.stereotype.Repository;@Repository(&quot;userDao&quot;)public class UserDaoForOracle implements UserDao&#123; @Override public void insert() &#123; System.out.println(&quot;正在向Oracle数据库插入User数据&quot;); &#125;&#125;package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;import jakarta.annotation.Resource;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; @Resource private UserDao userDao; public void save()&#123; userDao.insert(); &#125;&#125; 执行测试程序： ![img](6-Spring IoC注解式开发&#x2F;1665623044796-c4051a04-c56b-4ce9-b627-333ab7ca7b6a.png) 通过测试得知，当@Resource注解使用时没有指定name的时候，还是根据name进行查找，这个name是属性名。 接下来把UserService类中的属性名修改一下： 12345678910111213141516package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;import jakarta.annotation.Resource;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; @Resource private UserDao userDao2; public void save()&#123; userDao2.insert(); &#125;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665623273523-aff8ef45-b484-4462-bacc-fba7e14c8fee.png) 根据异常信息得知：显然当通过name找不到的时候，自然会启动byType进行注入。以上的错误是因为UserDao接口下有两个实现类导致的。所以根据类型注入就会报错。 我们再来看@Resource注解使用在setter方法上可以吗？ 1234567891011121314151617181920package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;import jakarta.annotation.Resource;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; private UserDao userDao; @Resource public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void save()&#123; userDao.insert(); &#125;&#125; 注意这个setter方法的方法名，setUserDao去掉set之后，将首字母变小写userDao，userDao就是name 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665623530366-79b8e09d-2559-4657-83eb-0b722261045f.png) 当然，也可以指定name： 1234567891011121314151617181920package com.powernode.spring6.service;import com.powernode.spring6.dao.UserDao;import jakarta.annotation.Resource;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; private UserDao userDao; @Resource(name = &quot;userDaoForMySQL&quot;) public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void save()&#123; userDao.insert(); &#125;&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665623611980-a66591e7-bd29-4327-a43c-6c6492c8612f.png) 一句话总结@Resource注解：默认byName注入，没有指定name时把属性名当做name，根据name找不到时，才会byType注入。byType注入时，某种类型的Bean只能有一个。 6 全注解式开发所谓的全注解开发就是不再使用spring配置文件了。写一个配置类来代替配置文件。 12345678910package com.powernode.spring6.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.ComponentScans;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(&#123;&quot;com.powernode.spring6.dao&quot;, &quot;com.powernode.spring6.service&quot;&#125;)public class Spring6Configuration &#123;&#125; 编写测试程序：不再new ClassPathXmlApplicationContext()对象了。 123456@Testpublic void testNoXml()&#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Spring6Configuration.class); UserService userService = applicationContext.getBean(&quot;userService&quot;, UserService.class); userService.save();&#125; 执行结果： ![img](6-Spring IoC注解式开发&#x2F;1665624710824-61ee0ae9-ae96-49bf-b189-4a1f358e084a.png)","categories":[],"tags":[]},{"title":"5-Bean的循环依赖问题","slug":"SSM/Spring/5-Bean的循环依赖问题","date":"2023-01-05T15:25:11.000Z","updated":"2023-01-07T15:41:27.535Z","comments":true,"path":"2023/01/05/SSM/Spring/5-Bean的循环依赖问题/","link":"","permalink":"https://jhfuture.github.io/2023/01/05/SSM/Spring/5-Bean%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/","excerpt":"","text":"一、Sigle+Set模式的 循环依赖问题。 只有 socle 为 single 才有这个曝光的机制。 - XML 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;husbandBean&quot; class=&quot;com.jhfuture.spring6.Husband&quot; scope=&quot;singleton&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt; &lt;/property&gt; &lt;property name=&quot;wife&quot; ref=&quot;wifeBean&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;wifeBean&quot; class=&quot;com.jhfuture.spring6.Wife&quot; scope=&quot;singleton&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;梨花&quot;/&gt; &lt;property name=&quot;husband&quot; ref=&quot;husbandBean&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; java src 123456789101112131415161718192021222324252627282930Husbandpackage com.jhfuture.spring6;public class Husband &#123; private String name; private Wife wife; public void setName(String name) &#123; this.name = name; &#125; public void setWife(Wife wife) &#123; this.wife = wife; &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; return &quot;Husband&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, wife=&quot; + wife.getName() + &#x27;&#125;&#x27;; &#125;&#125; Wife 123456789101112131415161718192021222324252627package com.jhfuture.spring6;public class Wife &#123; private String name; private Husband husband; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setHusband(Husband husband) &#123; this.husband = husband; &#125; @Override public String toString() &#123; return &quot;Wife&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, husband=&quot; + husband.getName() + &#x27;&#125;&#x27;; &#125;&#125; 二、prototype +Set 模式 —&gt;报错直接报错 12345org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;husbandBean&#x27; defined in class path resource [circle.xml]: Cannot resolve reference to bean &#x27;wifeBean&#x27; while setting bean property &#x27;wife&#x27; XML文件 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;husbandBean&quot; class=&quot;com.jhfuture.spring6.Husband&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt; &lt;/property&gt; &lt;property name=&quot;wife&quot; ref=&quot;wifeBean&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;wifeBean&quot; class=&quot;com.jhfuture.spring6.Wife&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;梨花&quot;/&gt; &lt;property name=&quot;husband&quot; ref=&quot;husbandBean&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 三、single + prototype +Set模式 —&gt;无问题12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;husbandBean&quot; class=&quot;com.jhfuture.spring6.Husband&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt; &lt;/property&gt; &lt;property name=&quot;wife&quot; ref=&quot;wifeBean&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;wifeBean&quot; class=&quot;com.jhfuture.spring6.Wife&quot; scope=&quot;single&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;梨花&quot;/&gt; &lt;property name=&quot;husband&quot; ref=&quot;husbandBean&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 五、基于构造依赖下产生的循环依赖—–&gt;无法解决总结 Spring解决循环依赖的机理 核心–&gt;三层缓存 Spring为什么可以解决set + singleton模式下循环依赖？ 根本的原因在于：这种方式可以做到将“实例化Bean”和“给Bean属性赋值”这两个动作分开去完成。 实例化Bean的时候：调用无参数构造方法来完成。此时可以先不给属性赋值，可以提前将该Bean对象&#x3D;&#x3D;“曝光”&#x3D;&#x3D;给外界。 给Bean属性赋值的时候：调用setter方法来完成。 两个步骤是完全可以分离开去完成的，并且这&#x3D;&#x3D;两步不要求在同一个时间点上完成&#x3D;&#x3D;。 也就是说，Bean都是单例的，我们可以先把所有的单例Bean实例化出来，放到一个集合当中（我们可以称之为缓存），所有的单例Bean全部实例化完成之后，以后我们再慢慢的调用setter方法给属性赋值。这样就解决了循环依赖的问题。","categories":[],"tags":[]},{"title":"4-Bean的实例化方法","slug":"SSM/Spring/4-Bean的实例化方法","date":"2023-01-05T11:55:14.000Z","updated":"2023-01-07T15:41:52.793Z","comments":true,"path":"2023/01/05/SSM/Spring/4-Bean的实例化方法/","link":"","permalink":"https://jhfuture.github.io/2023/01/05/SSM/Spring/4-Bean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E6%B3%95/","excerpt":"","text":"Bean的实例化方式Spring为Bean提供了多种实例化方式，通常包括4种方式。（也就是说在Spring中为Bean对象的创建准备了多种方案，目的是：更加灵活） 第一种：通过构造方法实例化 第二种：通过简单工厂模式实例化 第三种：通过factory-bean实例化 第四种：通过FactoryBean接口实例化 7.5 BeanFactory和FactoryBean的区别7.5.1 BeanFactorySpring IoC容器的顶级对象，BeanFactory被翻译为“Bean工厂”，在Spring的IoC容器中，“Bean工厂”负责创建Bean对象。 BeanFactory是工厂。 7.5.2 FactoryBeanFactoryBean：它是一个Bean，是一个能够辅助Spring实例化其它Bean对象的一个Bean。 在Spring中，Bean可以分为两类： 第一类：普通Bean 第二类：工厂Bean（记住：工厂Bean也是一种Bean，只不过这种Bean比较特殊，它可以辅助Spring实例化其它Bean对象。）","categories":[],"tags":[]},{"title":"3-设计模式","slug":"SSM/Spring/3-设计模式","date":"2023-01-04T11:53:24.000Z","updated":"2023-01-07T15:42:34.540Z","comments":true,"path":"2023/01/04/SSM/Spring/3-设计模式/","link":"","permalink":"https://jhfuture.github.io/2023/01/04/SSM/Spring/3-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"GoF一、分类创建式 工厂模式 结构式 代理模式 JDK提供的可以自动生成代理对象的 proxy 类 装饰模式 io 流的包装 适配器模式 httpServlet 行为式 观察者模式 servlet 监听器 工厂模式简单工厂模式的角色包括三个： 抽象产品 角色 具体产品 角色 工厂类 角色 简单工厂模式是 工厂方法模式的特殊一种 6.2 简单工厂模式消费者和生产者的关系。 简单工厂模式的优点： 客户端程序&#x3D;&#x3D;不需要关心对象的创建细节&#x3D;&#x3D;，需要哪个对象时，只需要向工厂索要即可，初步实现了责任的分离。客户端只负责“消费”，工厂负责“生产”。生产和消费分离。 简单工厂模式的缺点： 缺点1：工厂类集中了所有产品的创造逻辑，形成一个无所不知的全能类，有人把它叫做上帝类。显然工厂类非常关键，不能出问题，一旦出问题，整个系统瘫痪。 缺点2：不符合OCP开闭原则，在进行系统扩展时，需要修改工厂类。 Spring中的BeanFactory就使用了简单工厂模式。 6.3 工厂方法模式&#x3D;&#x3D;一个工厂生产一个产品&#x3D;&#x3D; 工厂方法模式既保留了简单工厂模式的优点，同时又解决了简单工厂模式的缺点。 工厂方法模式的角色包括： 抽象工厂角色 具体工厂角色 抽象产品角色 具体产品角色 我们可以看到在进行功能扩展的时候，不需要修改之前的源代码，显然工厂方法模式符合OCP原则。 工厂方法模式的优点： 一个调用者想创建一个对象，只要知道其名称就可以了。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 屏蔽产品的具体实现，调用者只关心产品的接口。 工厂方法模式的缺点：—&gt;类爆炸 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。","categories":[],"tags":[]},{"title":"2-Bean的作用域","slug":"SSM/Spring/2-Bean的作用域","date":"2023-01-04T11:38:53.000Z","updated":"2023-01-04T11:41:58.191Z","comments":true,"path":"2023/01/04/SSM/Spring/2-Bean的作用域/","link":"","permalink":"https://jhfuture.github.io/2023/01/04/SSM/Spring/2-Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"1 &lt;bean id=&quot;collection&quot; class=&quot;com.jhfuture.spring6.bean.Collection&quot; scope=&quot;prototype&quot;&gt; scope prototype（原型）多例 —–&gt; &#x3D;&#x3D;default&#x3D;&#x3D; 类的构造方法只会在 getBeans时执行，并且每次都是返回不同的对象 singleton 单例 类的构造方法在使用 &#x3D;&#x3D;new ClassPathXmlApplicationContext&#x3D;&#x3D;就已经被调用，每次调用 getBean 都是返回同一个 对象","categories":[],"tags":[]},{"title":"2-Bean的作用域","slug":"SSM/Spring","date":"2023-01-04T11:38:27.000Z","updated":"2023-02-27T13:27:07.725Z","comments":true,"path":"2023/01/04/SSM/Spring/","link":"","permalink":"https://jhfuture.github.io/2023/01/04/SSM/Spring/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"1-Spring_Attention","slug":"SSM/Spring/0-Attention","date":"2023-01-04T07:54:36.000Z","updated":"2023-01-08T13:11:20.967Z","comments":true,"path":"2023/01/04/SSM/Spring/0-Attention/","link":"","permalink":"https://jhfuture.github.io/2023/01/04/SSM/Spring/0-Attention/","excerpt":"","text":"一、XML文件相关 ${parameterName} 引入外部文件时，如果使用 ${parameter}，程序会 &#x3D;&#x3D;先从Windows自带的变量中查找&#x3D;&#x3D;，而不是引入的配置文件。 例如，${username} ，一般会为 Administrator 怎么解析 使用 dom4j","categories":[],"tags":[]},{"title":"2-事件处理机制","slug":"JAVA/15-坦克大战联系案例/2-事件处理机制","date":"2022-12-26T12:29:18.000Z","updated":"2022-07-20T13:15:22.346Z","comments":true,"path":"2022/12/26/JAVA/15-坦克大战联系案例/2-事件处理机制/","link":"","permalink":"https://jhfuture.github.io/2022/12/26/JAVA/15-%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98%E8%81%94%E7%B3%BB%E6%A1%88%E4%BE%8B/2-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","excerpt":"","text":"java 实践处理机制。“委派事件模型”。当事件发生时，会产生&#x3D;&#x3D;“该事件的对象”&#x3D;&#x3D;，然后会把该对象交给 &#x3D;&#x3D;“事件的监听者”&#x3D;&#x3D;进行处理。 机制分析举例 二、深入理解事件源： ​ 产生事件的对象，比如按钮，窗口等。 事件： ​ 承载事件源状态改变时的对象，比如当键盘事件会生成一个事件对象 - 事件类型 事件监听器接口： ​ 1.事件监听器实际上就是一个类，该类&#x3D;&#x3D;实现了某个事件监听器接口&#x3D;&#x3D;。","categories":[],"tags":[]},{"title":"1-坦克大战","slug":"JAVA/15-坦克大战联系案例/1-坦克大战","date":"2022-12-25T12:58:06.000Z","updated":"2022-12-25T13:59:03.223Z","comments":true,"path":"2022/12/25/JAVA/15-坦克大战联系案例/1-坦克大战/","link":"","permalink":"https://jhfuture.github.io/2022/12/25/JAVA/15-%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98%E8%81%94%E7%B3%BB%E6%A1%88%E4%BE%8B/1-%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98/","excerpt":"","text":"一、基础1.绘图坐标体系 2.绘制的基本使用 1-绘制的常用方法。小细节。 字体 x,y 的起始位置 12345678910111213141516171819202122232425画直线 drawLine(int x1,int y1,int x2,int y2)g.drawLine(10, 10, 100, 100);画矩形边框 drawRect(int x, int y, int width, int height)g.drawRect(10, 10, 100, 100);画椭圆边框 drawOval(int x, int y, int width, int height)填充矩形 fillRect(int x, int y, int width, int height)设置画笔的颜色 g.setColor(Color.blue); g.fillRect(10, 10, 100, 100);填充椭圆 fillOval(int x, int y, int width, int height)// g.setColor(Color.red);韩顺平循序渐进学 Java 零基础第 747页// g.fillOval(10, 10, 100, 100);//画图片 drawImage(Image img, int x, int y, ..)//1. 获取图片资源, /bg.png 表示在该项目的根目录去获取 bg.png 图片资源// Image image = Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(&quot;/bg.png&quot;));// g.drawImage(image, 10, 10, 175, 221, this);//画字符串 drawString(String str, int x, int y)//写字//给画笔设置颜色和字体g.setColor(Color.red);g.setFont(new Font(&quot;隶书&quot;, Font.BOLD, 50));//这里设置的 100， 100， 是 &quot;北京你好&quot;左下角g.drawString(&quot;北京你好&quot;, 100, 100);//设置画笔的字体 setFont(Font font","categories":[],"tags":[]},{"title":"1-线程的基本使用","slug":"JAVA/14-多线程基础/1-线程的基本使用","date":"2022-12-24T11:01:32.000Z","updated":"2022-12-25T12:04:33.328Z","comments":true,"path":"2022/12/24/JAVA/14-多线程基础/1-线程的基本使用/","link":"","permalink":"https://jhfuture.github.io/2022/12/24/JAVA/14-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"一、简单定义 什么是进程 2.线程与进程 线程由进程创建。 3.并发与并行 二、线程的使用 使用 继承 thread 类。重写 run 方法 实现 Runnable 接口，重写 run 方法，并将其对象传入 thread 的构造器中创建 thread 对象 1.Extend thread123456789101112131415161718192021222324252627public class threadsEXtend &#123; public static void main(String[] args) throws InterruptedException &#123; Dog dog = new Dog(); dog.start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;这是主线程&quot;+Thread.currentThread().getName()); Thread.sleep(1000); &#125; &#125;&#125;class Dog extends Thread&#123; @Override public void run() &#123; int count=1; while (true)&#123; System.out.println(&quot;小狗汪汪&quot;+&quot;线程名&quot;+currentThread().getClass()+count++); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; if (count==30)&#123; break; &#125; &#125; &#125;&#125; 2.implement Runnable 解决该类已经有 基继承的类 Thread 中具有代理模式的设计模式。 具有 一个 runnable 类型 的 Target 然后还有一个 构造器，可以接受一个 实现了 runnale 接口的类。 因为 runnable 接口没有 start 方法，创建 线程需要调用 start 方法，所以需要 thread 类进行代理。 1234567891011121314151617181920package com.threadUser;public class ThreadProxy &#123; public static void main(String[] args) &#123; Cat cat = new Cat(); Thread thread = new Thread(cat); thread.run(); &#125;&#125;class Cat implements Runnable&#123; @Override public void run() &#123; int count=1; for (int i = 0; i &lt; 30; i++) &#123; System.out.println(&quot;线程名&quot; +&quot;第&quot;+count++ +&quot;此&quot;); &#125; &#125;&#125; 3. extend 和 implement runnable 的区别 Runnable 更适合 多个线程共享一个资源的情况，并且避免了单继承的限制 12T3 t3=new T3(); 4.通知线程退出 线程完成任务后，会自动退出 可以使用&#x3D;&#x3D;控制变量&#x3D;&#x3D;来控制 run 方法退出的方式停止进程，即通知方式。 12345678910111213141516171819202122232425262728293031安丽package com.threadUser;public class ThreadExit_ &#123; public static void main(String[] args) throws InterruptedException &#123; exitTest exitTest = new exitTest(); exitTest.start(); System.out.println(&quot;等待五秒后手动关闭&quot;); Thread.sleep(5*1000); exitTest.setLoop(false); &#125;&#125;class exitTest extends Thread&#123; private boolean loop=true; int count=1; @Override public void run() &#123; while (loop)&#123; System.out.println(&quot;正在运行&quot;+count++); try &#123; //等待500毫秒 sleep(500); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; public void setLoop(boolean loop)&#123; this.loop=loop; &#125;&#125; 5.常用方法 1.setName &#x2F;&#x2F;设置线程名字 2.getName &#x2F;&#x2F;返回线程名称 3.start 启动该线程，jvm 底层调用该进程的 start0 方法 4.run &#x2F;&#x2F;直接调用线程对象的 run 方法 5-setPriority &#x2F;&#x2F;更改线程的优先级 6-getPriority &#x2F;&#x2F;获取线程的优先级 min –1 max –10 normal –5 7-sleep &#x2F;&#x2F;让线程指定休眠 xxx 毫秒 (暂停执行) 8- interrupt &#x2F;&#x2F;中断&#x3D;&#x3D;线程的休眠&#x3D;&#x3D; 9- yield :线程的礼让，让出 CPU ，让其他线程先执行，但礼让的时间不一定，所以礼让也&#x3D;&#x3D;不一定成功&#x3D;&#x3D;。 是否礼让由系统资源决定，操作系统内核负责处理，这一块 java 无法控制 10- join:线程的插队，插队的线程一旦插队成功，则肯定&#x3D;&#x3D;先执行完插入的线程的所有任务&#x3D;&#x3D;。 小弟让大哥先吃完包子自己再吃。 6.用户线程和守护线程1234567891011121314151617181920212223242526272829线程对象.setDaemon(true) ---&gt;守护进程。 setDaemon要在 start 之前设置。案例 package com.threadUser;public class SetDamon_ &#123; public static void main(String[] args) &#123; damon_ damon_ = new damon_(); damon_.setDaemon(true); damon_.start(); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(i); if (i==4)&#123; System.out.println(&quot;不，你是守护进程，你要和我一起走。&quot;); &#125; &#125; &#125;&#125;class damon_ extends Thread&#123; @Override public void run() &#123; while (true)&#123; System.out.println(&quot;我还要继续！！&quot;); &#125; &#125;&#125; 注意点 当处于 Runnable状态时，并不是一定在进行，而是由 操作系统的线程调度器负责 调配运行。—&gt;由操作系统内核决定。（内核态） 官方文档为 6 种状态，但一般 又将 runnable 细分为两种转态，即有7 钟转态 可以使用 jconsole 工具 查看线程 三、生命周期1.生命周期 2.线程同步机制1）线程同步机制 Synchronizd 一个敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性。 2.synchronize 使用四、锁 这里的同步方法是否是 静态的 非常重要。—Synchronized 如果是 this ，则是 当前对象，如果不同对象，不会造成堵塞。 如果是&#x3D;&#x3D;静态(stastic)&#x3D;&#x3D;， 则是 加在该类的 Class 中(类加载的知识) ，该&#x3D;&#x3D;类的不同对象&#x3D;&#x3D;，会造成&#x3D;&#x3D;堵塞&#x3D;&#x3D;。 1.注意事项和细节： 1.同步方法如果没有使用 static 修饰，默认锁对象就是 this 2.同步方法使用了 static 修饰，默认锁对象：当前类的 Class 对象(通常通过 类名.class获得) 3.实现锁的步骤 1.分析需要上锁的代码 2.选择&#x3D;&#x3D;同步代码块（优先考虑）&#x3D;&#x3D;或同步代码 3.&#x3D;&#x3D;要求多个线程的锁对象为同一个。&#x3D;&#x3D; 什么意思？1234567891011121314class Thread1&#123; public synchronized void sayhi()&#123; System.out.println(&quot;hi&quot;); &#125;&#125;思考：这里的 hi 能锁住吗？分析： 1.同步方法没有使用 static 修饰，那默认锁对象为 this。 2.而想要调用 sayhi 方法，就要使用 new Thread1().sayhi 3.而第2步中每次 调用都 new 了一个新对象，即此时如果使用 不同对象的 start 方法进行创建多线程。 4.那此时，多个线程的锁对象就是他们对应的那个对象----&gt;即不是同一个对象。不同的线程争夺的是不同的锁，那就无法锁住。 怎么解决？ 1.绑定同一个对象，其他的对象，例如新建一个 object 对象 2.给方法加上 static ，使其绑定类的Class 对象 2.线程死锁多个线程都占用了对方的锁资源，但不肯相让，导致了死锁。 一个案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.hspedu.syn;/*** @author 韩顺平* @version 1.0* 模拟线程死锁*/public class DeadLock_ &#123;public static void main(String[] args) &#123;//模拟死锁现象DeadLockDemo A = new DeadLockDemo(true);A.setName(&quot;A 线程&quot;);DeadLockDemo B = new DeadLockDemo(false);B.setName(&quot;B 线程&quot;);A.start();B.start();&#125;&#125;//线程韩顺平循序渐进学 Java 零基础第 810页class DeadLockDemo extends Thread &#123;static Object o1 = new Object();// 保证多线程，共享一个对象,这里使用 staticstatic Object o2 = new Object();boolean flag;public DeadLockDemo(boolean flag) &#123;//构造器this.flag = flag;&#125;@Overridepublic void run() &#123;//下面业务逻辑的分析//1. 如果 flag 为 T, 线程 A 就会先得到/持有 o1 对象锁, 然后尝试去获取 o2 对象锁//2. 如果线程 A 得不到 o2 对象锁，就会 Blocked//3. 如果 flag 为 F, 线程 B 就会先得到/持有 o2 对象锁, 然后尝试去获取 o1 对象锁//4. 如果线程 B 得不到 o1 对象锁，就会 Blockedif (flag) &#123;synchronized (o1) &#123;//对象互斥锁, 下面就是同步代码System.out.println(Thread.currentThread().getName() + &quot; 进入 1&quot;);synchronized (o2) &#123; // 这里获得 li 对象的监视权System.out.println(Thread.currentThread().getName() + &quot; 进入 2&quot;);&#125;&#125;&#125; else &#123;synchronized (o2) &#123;System.out.println(Thread.currentThread().getName() + &quot; 进入 3&quot;);synchronized (o1) &#123; // 这里获得 li 对象的监视权System.out.println(Thread.currentThread().getName() + &quot; 进入 4&quot;);&#125;&#125;&#125;&#125;&#125; 3.释放锁释放锁的问题。 下列操作不会释放锁 sleep、yield太困了，但还在厕所里面。 线程被挂起.suspend()。 六、一些疑问 为什么调用的是 start 方法，而不是直接调用 run 方法 A: 直接调用 run 方法，那就是相当于普通的方法调用，只会在主栈中调用，不会创建新线程。而调用 start 方法可以创建新 线程并 会自动调用 run 方法。–&gt;看源码分析 12345678public synchronized void start() &#123;start0();&#125;//start0() 是本地方法，是 JVM 调用, 底层是 c/c++实现//真正实现多线程的效果， 是 start0(), 而不是 runprivate native void start0();","categories":[],"tags":[]},{"title":"1-Computer System Operation","slug":"Basics_of_OS/OperatingSystem/1-Computer System Operation","date":"2022-12-24T05:59:55.000Z","updated":"2022-12-24T11:51:34.796Z","comments":true,"path":"2022/12/24/Basics_of_OS/OperatingSystem/1-Computer System Operation/","link":"","permalink":"https://jhfuture.github.io/2022/12/24/Basics_of_OS/OperatingSystem/1-Computer%20System%20Operation/","excerpt":"","text":"一、 Bus![image-20221224143316371](1-Computer System Operation&#x2F;image-20221224143316371.png) Execute concuurentlyy :并发 Memory Controller :为每个程序分配合适的内容保证他们的正常运行。 Some important Terms![image-20221224143645797](1-Computer System Operation&#x2F;image-20221224143645797.png) load System and load OS kernel into memory 2)打断 硬件的打断 —&gt; Interrupt 软件的打断 —-&gt;System Call (Monitor call) Interrupt Any time by sending a signal to the Cpu What the fixed lOCATION ![image-20221224144156476](1-Computer System Operation&#x2F;image-20221224144156476.png) 3)打断后的操作![image-20221224161745360](1-Computer System Operation&#x2F;image-20221224161745360.png) 先执行打断的程序，执行完毕后继续执行之前的内容。 二、存储结构![image-20221224183423143](1-Computer System Operation&#x2F;image-20221224183423143.png) 寄存器 Registers 以 位 的形式存储。最小的设备。 Cache 比寄存器大 Main Memory 随机存取储存器或 RAM 辅助( secondly Memory ) Electronic Disk 电子磁盘 Magnetic Disk 磁盘 Optical Disk 光盘 Magnetic Tapes 磁带 Volatile :Loses its contents when power is removedNon Volatile: Retains its contents even when power is removed 三、I&#x2F;O Structure","categories":[],"tags":[]},{"title":"3-转换流","slug":"JAVA/12-io流/3-转换流","date":"2022-12-22T16:25:10.000Z","updated":"2022-12-22T16:31:50.165Z","comments":true,"path":"2022/12/23/JAVA/12-io流/3-转换流/","link":"","permalink":"https://jhfuture.github.io/2022/12/23/JAVA/12-io%E6%B5%81/3-%E8%BD%AC%E6%8D%A2%E6%B5%81/","excerpt":"","text":"InputStreamReader 的构造方法为传入一个 inputStream(字节输入流), 和指定编码(charsetDecoder) Reader的包装类 BufferedReader 的构造器接受对象为 Reader 的子类，inputStreamReader 也属于，可以直接进行包装 步骤12345678910111213141516171819202122//如果有特定编码，不是utf-8，则需要进行转换 BufferedReader bufferedReader=null; try &#123; //1.先创建字节节点流 //2.将字节流转换为字符流 使用inputStreamReader //3.包装 FileInputStream fileInputStream = new FileInputStream(&quot;e:\\\\mytemp\\\\hw2.txt&quot;); InputStreamReader gbk = new InputStreamReader(fileInputStream, &quot;gbk&quot;); bufferedReader = new BufferedReader(gbk); String line=&quot;&quot;; int cout=1; while ((line=bufferedReader.readLine())!=null)&#123; System.out.println(&quot;第&quot;+cout+&quot;内容&quot;+line); cout++; &#125; &#125; catch (FileNotFoundException e) &#123; throw new RuntimeException(e); &#125; finally &#123; if (bufferedReader!=null)&#123; bufferedReader.close(); &#125; &#125;","categories":[],"tags":[]},{"title":"2-处理流","slug":"JAVA/12-io流/2-处理流","date":"2022-12-18T13:30:47.000Z","updated":"2022-12-22T16:24:25.371Z","comments":true,"path":"2022/12/18/JAVA/12-io流/2-处理流/","link":"","permalink":"https://jhfuture.github.io/2022/12/18/JAVA/12-io%E6%B5%81/2-%E5%A4%84%E7%90%86%E6%B5%81/","excerpt":"","text":"补充1.readLine方法 123Public String readLine()&#123;&#125;//返回一行的字符，为空时返回 null BufferedReader.&#x3D;&#x3D;readLine方法&#x3D;&#x3D;在读取的时候不会读取&#x3D;&#x3D;换行符&#x3D;&#x3D;，所以在进行&#x3D;&#x3D;拷贝文件操作&#x3D;&#x3D;时，需要&#x3D;&#x3D;手动添加换行&#x3D;&#x3D;。 1234567bufferedReader.readLine()while ((line=bufferedReader.readLine())!=null)&#123; //读取时不会读取换行符，所以如果想要换行需要进行换行操作 bufferedWriter.write(line); ===== bufferedWriter.newLine();=======&#125; 2.FileReader 和 File Writer 都只能处理 &#x3D;&#x3D;字符&#x3D;&#x3D;，即文本文件，不能处理二进制文件。","categories":[],"tags":[]},{"title":"2-反射的基本使用","slug":"JAVA/13-反射(reflection)/2-反射的基本使用","date":"2022-12-17T13:20:54.000Z","updated":"2022-12-17T14:10:48.253Z","comments":true,"path":"2022/12/17/JAVA/13-反射(reflection)/2-反射的基本使用/","link":"","permalink":"https://jhfuture.github.io/2022/12/17/JAVA/13-%E5%8F%8D%E5%B0%84(reflection)/2-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"反射一、前言反射是一种动态依赖机制，其作为各种 java 框架的核心，在 java 中具有举足轻重的地位。集多身优点的它，也因为动态加载而会损耗一定的性能。 其基本使用步骤可分为 1.获取 Class 对象 1.1使用 Class 对象获取 file(字段) 对象 对字段进行操作 1.2使用 Class 对象获取 method(方法) 对象 对方法进行调用。 1.3使用 Class 对象获取 constructor 对象对构造器进行调用。 下面来详细说每个步骤的使用方法 一、获取 Class 对象从大维度上看，获取 Class 对象是从 4 个基本维度出发。 代码阶段 &#x3D;&#x3D;Class.forName(“全路径”)&#x3D;&#x3D; 前提： 已知一个类的全类名 类是否会被加载 –&gt;是 场景 配置文件 类加载阶段 &#x3D;&#x3D;类名.class&#x3D;&#x3D; 类是否会被加载 –&gt;否 场景 传参 运行阶段 &#x3D;&#x3D;对象.class&#x3D;&#x3D; 使用加载器 对象.getClass.getClassLoader() –》使用类的加载器的load方法进行类的加载 基本数据类型获得 Class 基本数据类型.class 基本数据类型的&#x3D;&#x3D;包装类&#x3D;&#x3D; 包装类.TYPE 二、常用方法1.Class类 static Class forName(String name) 返回指定类名 name 的 Class 对象 Object newInstance 调用缺省构造函数，返回该 Class 对象的一个实例 String getName() 返回此 Class 对象所表示的实体（类、接口、数组类、基本数据类型等）名称 Class[] getInterfaces() 获取此 Class 对象的接口 ClassLoader getClassLoader() 获取该类的类构造器 Class getSuperclass() 返回表示此 Class 所表示的实体的类的 &#x3D;&#x3D;超类的Class&#x3D;&#x3D; Constructor[] getConstructors() 返回一个包含本类构造器的数组 Field[] getDeclaredFields() 返回 Field 对象的一个数组 Method getMethod(String name, Class… paramTypes) 返回一个 Method 对象， name为方法名，方法的形参类型的 Class 对像 2.Method 额外的补充 类名.class 获取 Class 对象时，该类是否加载的问题。 使用 &#x3D;&#x3D;类名.class获取 Class&#x3D;&#x3D;不会使 该类被加载，jvm 只会对其进行校验。只有在代码中真正用到了类。比如通过反设调用方法或创建对象，那么在这种情况下该类就会被加载。例如 1234567891011121314151617181920 System.out.println(nte.class);// System.out.println(nte.age); Class&lt;nte&gt; nteClass = nte.class; Method hi = nteClass.getMethod(&quot;hi&quot;); hi.invoke(null);class nte&#123; static int age=10; static &#123; System.out.println(&quot;Helloworld&quot;); &#125; public static void hi()&#123; System.out.println(&quot;hi&quot;); &#125;&#125;输出结果 class com.reflection.homework.nteHelloworldhi 第一个nte.class 输出后，静态方法块中的打印才输出，说明 使用 类名.class 时类并不会被加载。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://jhfuture.github.io/categories/JAVA/"}],"tags":[{"name":"反射","slug":"反射","permalink":"https://jhfuture.github.io/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"1-类加载过程","slug":"JAVA/13-反射(reflection)/1-类加载过程","date":"2022-12-16T11:27:46.000Z","updated":"2022-12-25T09:40:27.902Z","comments":true,"path":"2022/12/16/JAVA/13-反射(reflection)/1-类加载过程/","link":"","permalink":"https://jhfuture.github.io/2022/12/16/JAVA/13-%E5%8F%8D%E5%B0%84(reflection)/1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"","text":"一、简要类加载的三个加载 1.前者两个是 jvm 进行操作 2.第三个初始化 时程序员进行的 —-&gt; 静态成员的初始化&#x3D;&#x3D; 二、逐步分析1.加载阶段 二进制字节流加载到内存：即在方法区中放入类的字节码二进制数据。并同时在堆区中创建类的 Class 对象 2.连接 Linking 阶段1)验证 可以通过设置 -Xverify:none 参数来关闭大部分的类验证措施，从而缩短虚拟机类加载的时间。 2)准备对&#x3D;&#x3D;静态变量&#x3D;&#x3D;进行默认初始化—&gt; 看案例理解准备阶段 12345678910111213141516171819public class ClassLoad02 &#123;public static void main(String[] args) &#123;&#125;&#125;class A &#123;//属性-成员变量-字段//老韩分析类加载的链接阶段-准备 属性是如何处理//1. n1 是实例属性, 不是静态变量，因此在准备阶段，是不会分配内存//2. n2 是静态变量，分配内存 n2 是默认初始化 0 ,而不是 20//3. n3 是 static final 是常量, 他和静态变量不一样, 因为一旦赋值就不变 n3 = 30 //1.n1 是实例属性，不是静态变量，因此在准备阶段，是不会分配内存。 //为什么说是实例属性，只有当创建了类的对象实例时，这个属性才能使用，而静态变量可以通过 // 类名.namepublic int n1 = 10; //2. n2 是静态变量，在准备阶段时会默认初始化为0public static int n2 = 20; //3. n3 是 static final ，他和静态变量不同，因为一旦赋值就不变， n3=30public static final int n3 = 30;&#125; 3)解析将符号引用替换为直接引用。 3.Initialization（初始化） 123456789101112131415161718192021222324252627282930313233343536373839404142public class ClassLoad03 &#123;public static void main(String[] args) throws ClassNotFoundException &#123;//老韩分析//1. 加载 B 类，并生成 B 的 class 对象//2. 链接 num = 0//3. 初始化阶段// 依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句,并合并/*clinit() &#123;System.out.println(&quot;B 静态代码块被执行&quot;);//num = 300;num = 100;&#125;合并: num = 100*///new B();//类加载//System.out.println(B.num);//100, 如果直接使用类的静态属性，也会导致类的加载//看看加载类的时候，是有同步机制控制/*protected Class&lt;?&gt; loadClass(String name, boolean resolve)韩顺平循序渐进学 Java 零基础第 938页throws ClassNotFoundException&#123;//正因为有这个机制，才能保证某个类在内存中, 只有一份 Class 对象synchronized (getClassLoadingLock(name)) &#123;//.... &#125;&#125;*/B b = new B();&#125;&#125;class B &#123;static &#123;System.out.println(&quot;B 静态代码块被执行&quot;);num = 300;&#125;static int num = 100;public B() &#123;//构造器System.out.println(&quot;B() 构造器被执行&quot;);&#125;&#125;","categories":[],"tags":[]},{"title":"1-Windoes","slug":"Windows/1-小技巧","date":"2022-12-16T11:22:24.000Z","updated":"2022-12-16T11:25:26.937Z","comments":true,"path":"2022/12/16/Windows/1-小技巧/","link":"","permalink":"https://jhfuture.github.io/2022/12/16/Windows/1-%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"1. 步骤记录器 前言 ​ 我们可能经常需要给别人演示操作步骤，写文档的方式可能不够优雅。这时候我们可以使用 Windows 自带的&#x3D;&#x3D;步骤记录器&#x3D;&#x3D; psr.exe 使用步骤 a. Win+R 同时按下调出 运行窗口 b. 输入 psr.exe c .点击开始记录然后开始相关的操作即可。 d. 操作结束后点击停止即可自动生成文档。","categories":[{"name":"Windows使用技巧","slug":"Windows使用技巧","permalink":"https://jhfuture.github.io/categories/Windows%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://jhfuture.github.io/tags/Windows/"}]},{"title":"1-查找论文","slug":"学习相关/1-查找论文","date":"2022-12-14T12:42:27.000Z","updated":"2022-12-14T12:55:19.240Z","comments":true,"path":"2022/12/14/学习相关/1-查找论文/","link":"","permalink":"https://jhfuture.github.io/2022/12/14/%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/1-%E6%9F%A5%E6%89%BE%E8%AE%BA%E6%96%87/","excerpt":"","text":"免费查找一些论文一、前言在学校或者使用 webvpn 可以解决我们查文献的问题，但是有很多资料是学校没有购买的，我们查找文献的时候就非常麻烦，现在众所周知的就是 [sci-hub](SCI-Hub论文下载可用网址链接（实时更新） - YoviSun工具集) 它可以通过 DOI 、PubMed 、数据库链接进行论文下载，但一部分资源及其网络的原因国内无法正常访问，这里介绍一个新的工具 中文DOI (chinadoi.cn) 二、操作流程1.打开网页，在查找 DOI 中输入文章标题。 2.在搜索结果中复制 DOI。例如我这里 可能个别文章的 DOi 并不正确，不行的话多试几次即可。 将 doi：xxxxx 复制。 &#x3D;&#x3D;前缀“doi”也要一起复制！！！！&#x3D;&#x3D;&#x3D;&#x3D; 3.使用 DOI 进行文献搜索 将你搜到的 DOI 填入 &#x3D;&#x3D;DOI解析&#x3D;&#x3D;中，进行解析即可。 4.恭喜你成功了 另外首选：ChinaDOI网站（http://www.chinadoi.cn/portal/index.htm），这是亚洲唯一的DOI注册机构网站，中文论文都经此注册。 另外，也可到万方数据知识服务平台 （http://www.wanfangdata.com.cn）查询，ChinaDOI的DOI数据与万方数据知识服务平台同步，在这里查询也一样。 英文论文：首选：CrossRef（http://www.crossref.org），这是全球最大的DOI注册机构; 如果在CrossRef找不到，考虑其他注册机构网站，详见http://www.doi.org/registration_agencies.html。","categories":[],"tags":[]},{"title":"","slug":"JAVA/Untitled","date":"2022-12-07T13:20:26.804Z","updated":"2022-12-07T13:20:26.804Z","comments":true,"path":"2022/12/07/JAVA/Untitled/","link":"","permalink":"https://jhfuture.github.io/2022/12/07/JAVA/Untitled/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"1-文件操作入门","slug":"JAVA/12-io流/1-文件操作入门","date":"2022-11-28T11:18:36.000Z","updated":"2022-07-20T14:08:45.928Z","comments":true,"path":"2022/11/28/JAVA/12-io流/1-文件操作入门/","link":"","permalink":"https://jhfuture.github.io/2022/11/28/JAVA/12-io%E6%B5%81/1-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%85%A5%E9%97%A8/","excerpt":"","text":"—————————————————！！！注意！！！——————————————————————————————– 无论使用什么文件流，最后一定要记得 close 或者 flush —————————&#x3D;&#x3D;否则不会保存！！！！！！！！&#x3D;&#x3D;———————————————————————————————– 一、文件操作 流？ —&gt;数据从硬盘通过内存流到java程序。 12345File file = new File(filePath);file.createNewFile();//为什么需要第一部已经创建了对象，还要调用第二个方法因为第一个创建的文件对象 ---&gt;存在于内存中----&gt;调用第二个将其写进 硬盘 二、创建文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445//方式 1 new File(String pathname)@Testpublic void create01() &#123;String filePath = &quot;e:\\\\news1.txt&quot;;File file = new File(filePath);try &#123;file.createNewFile();System.out.println(&quot;文件创建成功&quot;);&#125; catch (IOException e) &#123;e.printStackTrace();&#125;&#125;//方式 2 new File(File parent,String child) //根据父目录文件+子路径构建//e:\\\\news2.txt@Testpublic void create02() &#123;File parentFile = new File(&quot;e:\\\\&quot;);String fileName = &quot;news2.txt&quot;;//这里的 file 对象，在 java 程序中，只是一个对象//只有执行了 createNewFile 方法，才会真正的，在磁盘创建该文件File file = new File(parentFile, fileName);韩顺平循序渐进学 Java 零基础第 819页try &#123;file.createNewFile();System.out.println(&quot;创建成功~&quot;);&#125; catch (IOException e) &#123;e.printStackTrace();&#125;&#125;//方式 3 new File(String parent,String child) //根据父目录+子路径构建@Testpublic void create03() &#123;//String parentPath = &quot;e:\\\\&quot;;String parentPath = &quot;e:\\\\&quot;;String fileName = &quot;news4.txt&quot;;File file = new File(parentPath, fileName);try &#123;file.createNewFile();System.out.println(&quot;创建成功~&quot;);&#125; catch (IOException e) &#123;e.printStackTrace();&#125;&#125;","categories":[],"tags":[]},{"title":"JUnit单元测试框架","slug":"JAVA/0-Java细节/JUnit","date":"2022-11-28T08:13:07.000Z","updated":"2023-01-15T12:54:14.136Z","comments":true,"path":"2022/11/28/JAVA/0-Java细节/JUnit/","link":"","permalink":"https://jhfuture.github.io/2022/11/28/JAVA/0-Java%E7%BB%86%E8%8A%82/JUnit/","excerpt":"","text":"二、注意 Junit 最好运用在 Maven 的 Test 中 该包名下不能有名为 test 的包或 类。 期望值与实际值的使用 int expected&#x3D;xxx; int acutal&#x3D;业务代码。 使用 Assert 工具类的 assertEquals(expected,actual) 方法进行判断","categories":[{"name":"JUnit","slug":"JUnit","permalink":"https://jhfuture.github.io/categories/JUnit/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://jhfuture.github.io/tags/JAVA/"}]},{"title":"1-泛型入门","slug":"JAVA/10-泛型/1-泛型入门","date":"2022-11-28T06:32:08.000Z","updated":"2023-01-02T13:26:40.994Z","comments":true,"path":"2022/11/28/JAVA/10-泛型/1-泛型入门/","link":"","permalink":"https://jhfuture.github.io/2022/11/28/JAVA/10-%E6%B3%9B%E5%9E%8B/1-%E6%B3%9B%E5%9E%8B%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、泛型what？ 泛型是 ——–&gt; 可以 接受 数据类型 的一种 数据类型 。 why? how? 1.类的自定义泛型 2.接口的自定义类型 接口中有泛型时， 最好不要 class xxx implements Iusb{ } 这样写 而是 class xxx implements Iusb &lt;Object,Object &gt;{ } 二、注意的点 泛型 只能是 &#x3D;&#x3D;引用类型&#x3D;&#x3D;。 — 不指定类型 ，默认类型 为 &#x3D;&#x3D;object&#x3D;&#x3D; 使用泛型的数组不能初始化。因为 new 的时候会为 数组分配内存空间，而 此刻不能确定其类型，就无法开空间。 静态成员(属性、方法、方法快)都不能使用 泛型，因为泛型只有在类被创建实例时才被指定 类型 ，而 静态成员在 &#x3D;&#x3D;类加载&#x3D;&#x3D;时，就被初始化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.hspedu.customgeneric;import java.util.Arrays;/*** @author 韩顺平* @version 1.0*/@SuppressWarnings(&#123;&quot;all&quot;&#125;)public class CustomGeneric_ &#123;public static void main(String[] args) &#123;//T=Double, R=String, M=IntegerTiger&lt;Double,String,Integer&gt; g = new Tiger&lt;&gt;(&quot;john&quot;);g.setT(10.9); //OK//g.setT(&quot;yy&quot;); //错误，类型不对System.out.println(g);Tiger g2 = new Tiger(&quot;john~~&quot;);//OK T=Object R=Object M=Objectg2.setT(&quot;yy&quot;); //OK ,因为 T=Object &quot;yy&quot;=String 是 Object 子类System.out.println(&quot;g2=&quot; + g2);&#125;&#125;//老韩解读//1. Tiger 后面泛型，所以我们把 Tiger 就称为自定义泛型类//2, T, R, M 泛型的标识符, 一般是单个大写字母//3. 泛型标识符可以有多个. //4. 普通成员可以使用泛型 (属性、方法)//5. 使用泛型的数组，不能初始化//6. 静态方法中不能使用类的泛型class Tiger&lt;T, R, M&gt; &#123;String name;R r; //属性使用到泛型M m;T t;//因为数组在 new 不能确定 T 的类型，就无法在内存开空间T[] ts;public Tiger(String name) &#123;this.name = name;&#125;public Tiger(R r, M m, T t) &#123;//构造器使用泛型this.r = r;this.m = m;this.t = t;&#125;public Tiger(String name, R r, M m, T t) &#123;//构造器使用泛型this.name = name;this.r = r;this.m = m;this.t = t;&#125;//因为静态是和类相关的，在类加载时，对象还没有创建//所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化// static R r2;// public static void m1(M m) &#123;//// &#125;//方法使用泛型public String getName() &#123;return name;&#125;public void setName(String name) &#123;this.name = name;&#125;public R getR() &#123;return r;&#125;public void setR(R r) &#123;//方法使用到泛型this.r = r;&#125;public M getM() &#123;//返回类型可以使用泛型. return m;&#125;public void setM(M m) &#123;this.m = m;&#125;public T getT() &#123;return t;&#125;public void setT(T t) &#123;this.t = t;&#125;@Overridepublic String toString() &#123;return &quot;Tiger&#123;&quot; +&quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +&quot;, r=&quot; + r +&quot;, m=&quot; + m +&quot;, t=&quot; + t +&quot;, ts=&quot; + Arrays.toString(ts) +&#x27;&#125;&#x27;;&#125;&#125; 2. &#x3D;# 三、通配符与继承 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class GenericExtends &#123;public static void main(String[] args) &#123;Object o = new String(&quot;xx&quot;);//泛型没有继承性//List&lt;Object&gt; list = new ArrayList&lt;String&gt;();//举例说明下面三个方法的使用List&lt;Object&gt; list1 = new ArrayList&lt;&gt;();List&lt;String&gt; list2 = new ArrayList&lt;&gt;();List&lt;AA&gt; list3 = new ArrayList&lt;&gt;();List&lt;BB&gt; list4 = new ArrayList&lt;&gt;();List&lt;CC&gt; list5 = new ArrayList&lt;&gt;();//如果是 List&lt;?&gt; c ，可以接受任意的泛型类型printCollection1(list1);printCollection1(list2);韩顺平循序渐进学 Java 零基础第 737页printCollection1(list3);printCollection1(list4);printCollection1(list5);//List&lt;? extends AA&gt; c： 表示 上限，可以接受 AA 或者 AA 子类// printCollection2(list1);//×// printCollection2(list2);//×printCollection2(list3);//√printCollection2(list4);//√printCollection2(list5);//√//List&lt;? super AA&gt; c: 支持 AA 类以及 AA 类的父类，不限于直接父类printCollection3(list1);//√//printCollection3(list2);//×printCollection3(list3);//√//printCollection3(list4);//×//printCollection3(list5);//×//冒泡排序//插入排序//....韩顺平循序渐进学 Java 零基础第 738页&#125;// ? extends AA 表示 上限，可以接受 AA 或者 AA 子类public static void printCollection2(List&lt;? extends AA&gt; c) &#123;for (Object object : c) &#123;System.out.println(object);&#125;&#125;//说明: List&lt;?&gt; 表示 任意的泛型类型都可以接受public static void printCollection1(List&lt;?&gt; c) &#123;for (Object object : c) &#123; // 通配符，取出时，就是 ObjectSystem.out.println(object);&#125;&#125;// ? super 子类类名 AA:支持 AA 类以及 AA 类的父类，不限于直接父类，//规定了泛型的下限public static void printCollection3(List&lt;? super AA&gt; c) &#123;for (Object object : c) &#123;System.out.println(object);&#125;&#125;&#125;韩顺平循序渐进学 Java 零基础第 739页class AA &#123;&#125;class BB extends AA &#123;&#125;class CC extends BB &#123;&#125;","categories":[],"tags":[]},{"title":"","slug":"JavaWeb/Servlet-JSP-课堂笔记","date":"2022-11-27T08:39:39.971Z","updated":"2023-02-10T07:29:20.760Z","comments":true,"path":"2022/11/27/JavaWeb/Servlet-JSP-课堂笔记/","link":"","permalink":"https://jhfuture.github.io/2022/11/27/JavaWeb/Servlet-JSP-%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/","excerpt":"","text":"关于直播 直播什么内容？ 从JavaWEB开始。（Servlet为核心，从Servlet开始学习。） JSP（JSP使用较少了，但是还有用，所以时间上少一些。快速地学习一下JSP。） AJAX（异步通信技术。） jQuery（JavaScript库。） MyBatis Spring SpringMVC SpringBoot SpringCloud …. 需要提前准备了哪些技术，接下来的课才能听懂？ JavaSE（Java语言的标准版，Java提供的最基本的类库） Java的开发环境搭建 Java的基础语法 Java的面向对象 数组 常用类 异常 集合 多线程 IO流 反射机制 注解Annotation ….. MySQL（数据库） 最基本的要求是：能够编写增删改查等简单的SQL语句即可。 JDBC（Java语言链接数据库） 这是一套Java语言链接数据库的接口。 WEB前端（会一些） HTML（网页） CSS（层叠样式表语言，修饰HTML） JavaScript（一种脚本语言，运行在浏览器当中，让浏览器中的元素可以增删改。让网页产生更强的交互效果） WEB后端 Servlet（Server Applet：服务器端的Java小程序） JSP AJAX jQuery MyBatis Spring SpringMVC SpringBoot SpringCloud …… Typora软件介绍 Markdown文本编辑器（可以编辑xxx.md文件） 12345public class Test&#123; public static void main(String[] args)&#123; System.out.println(&quot;Test code!&quot;); &#125;&#125; Servlet关于系统架构 系统架构包括什么形式？ C&#x2F;S架构 B&#x2F;S架构 C&#x2F;S架构？ Client &#x2F; Server（客户端 &#x2F; 服务器） C&#x2F;S架构的软件或者说系统有哪些呢？ QQ（先去腾讯官网下载一个QQ软件，几十MB，然后把这个客户端软件安装上去，然后输入QQ号以及密码，登录之后，就可以和你的朋友聊天了，就可以使用这个软件了。） C&#x2F;S架构的特点：需要安装特定的客户端软件。 C&#x2F;S架构的系统优点和缺点分别是什么？ 优点： 速度快（软件中的数据大部分都是集成到客户端软件当中的，很少量的数据从服务器端传送过来，所以C&#x2F;S结构的系统速度快） 体验好（速度又快，界面又酷炫，当然体验好了。） 界面酷炫（专门的语言去实现界面的，更加灵活。） 服务器压力小（因为大量的数据都是集成在客户端软件当中，所以服务器只需要传送很少的数据量，当然服务器压力小。） 安全（因为大量的数据是集成在客户端软件当中的，并且客户端有很多个，服务器虽然只有一个，就算服务器那边地震了，火灾了，服务器受损了，问题也不大，因为大量的数据在多个客户端上有缓存，有存储，所以从这个方面来说，C&#x2F;S结构的系统比较安全。） ….. 缺点： 升级维护比较差劲。（升级维护比较麻烦。成本比较高。每一个客户端软件都需要升级。有一些软件不是那么容易安装的。） B&#x2F;S架构？ B&#x2F;S（Browser &#x2F; Server，浏览器 &#x2F; 服务器） http://www.baidu.com http://www.jd.com http://www.126.com B&#x2F;S结构的系统是不是一个特殊的C&#x2F;S系统？ 实际上B&#x2F;S结构的系统还是一个C&#x2F;S，只不过这个C比较特殊，这个Client是一个固定不变浏览器软件。 B&#x2F;S结构的系统优点和缺点是： 优点： 升级维护方便，成本比较低。（只需要升级服务器端即可。） 不需要安装特定的客户端软件，用户操作极其方便。只需要打开浏览器，输入网址即可。 缺点： 速度慢（不是因为带宽低的问题，是因为所有的数据都是在服务器上，用户发送的每一个请求都是需要服务器全身心的响应数据，所以B&#x2F;S结构的系统在网络中传送的数据量比较大。） 体验差（界面不是那么酷炫，因为浏览器只支持三个语言HTML CSS JavaScript。在加上速度慢。） 不安全（所有的数据都在服务器上，只要服务器发生火灾，地震等不可抗力，最终数据全部丢失。） …. C&#x2F;S和B&#x2F;S结构的系统，哪个好，哪个不好？ 这个问题问的没有水平。并不是哪个好，哪个不好。不同结构的系统在不同的业务场景下有不同的适用场景。 娱乐性软件建议使用？ C&#x2F;S 结构 公司内部使用的一些业务软件建议使用？ 公司内部使用的系统，需要维护成本低。 公司内部使用的系统，不需要很酷炫。 公司内部使用的企业级系统主要是能够进行数据的维护即可。 B&#x2F;S 结构。 注意了：开发B&#x2F;S结构的系统，其实就是开发网站，其实就是开发一个WEB系统。 开发一个WEB系统你需要会哪些技术？ WEB前端（运行在浏览器上的程序。） HTML CSS JavaScript WEB后端（WEB服务器端的程序。） Java可以（Java做WEB开发我们称为JavaWEB开发。JavaWEB开发最核心的规范：Servlet【Server Applet服务器端的Java小程序。】） C语言也可以 C++也可以 Python也行 PHP也可以 …. JavaEE是什么？ Java包括三大块： JavaSE Java标准版（一套类库：别人写好的一套类库，只不过这个类库是标准类库，走EE，或者走ME，这个SE一定是基础，先学。） JavaEE（WEB方向，WEB系统。） Java企业版（也是一套类库：也是别人写好的一套类库，只不过这套类库可以帮助我们完成企业级项目的开发，专门为企业内部提供解决方案的一套（多套）类库。） 别人写好的，你用就行了，用它可以开发企业级项目。 可以开发web系统。 Java比较火爆的就是这个JavaEE方向。 JavaME Java微型版（还是一套类库，只不过这套类库帮助我们进行电子微型设备内核程序的开发） 机顶盒内核程序，吸尘器内核程序，电冰箱内核程序，电饭煲内核程序。。。。。 JavaEE实际上包括很多种规范，13种规范，其中Servlet就是JavaEE规范之一。学Servlet还是Java语言。 B&#x2F;S结构的系统通信原理（没有涉及到Java小程序） WEB系统的访问过程 第一步：打开浏览器 第二步：找到地址栏 第三步：输入一个合法的网址 第四步：回车 第五步：在浏览器上会展示响应的结果。 关于域名： https://www.baidu.com/ （网址） www.baidu.com 是一个域名 在浏览器地址栏上输入域名，回车之后，域名解析器会将域名解析出来一个具体的IP地址和端口号等。 解析结果也许是：http://110.242.68.3:80/index.html IP地址是啥？ 计算机在网络当中的一个身份证号。在同一个网络当中，IP地址是唯一的。 A计算机要想和B计算机通信，首先你需要知道B计算机的IP地址，有了IP地址才能建立连接。 端口号是啥？ 一个端口代表一个软件（一个端口代表一个应用，一个端口仅代表一个服务）。 一个计算机当中有很多软件，每一个软件启动之后都有一个端口号。 在同一个计算机上，端口号具有唯一性。 一个WEB系统的通信原理？通信步骤： 第一步：用户输入网址（URL） 第二步：域名解析器进行域名解析：http://110.242.68.3:80/index.html 第三步：浏览器软件在网络中搜索110.242.68.3这一台主机，直到找到这台主机。 第四步：定位110.242.68.3这台主机上的服务器软件，因为是80端口，可以很轻松的定位到80端口对应的服务器软件。 第五步：80端口对应的服务器软件得知浏览器想要的资源名是：index.html 第六步：服务器软件找到index.html文件，并且将index.html文件中的内容直接输出响应到浏览器上。 第七步：浏览器接收到来自服务器的代码（HTML CSS JS） 第八步：浏览器渲染，执行HTML CSS JS代码，展示效果。 什么是URL？ 统一资源定位符（http://www.baidu.com） 什么是请求，什么是响应？ 请求和响应实际上说的是数据的流向不同。 从Browser端发送数据到Server端，我们称为请求。英语单词：request 从Server端向浏览器Browser端发送数据，我们称为响应。英语单词：response B –&gt; S （请求request） S –&gt; B （响应response） 关于WEB服务器软件 WEB服务器软件都有哪些呢？（这些软件都是提前开发好的。） Tomcat（WEB服务器） jetty（WEB服务器） JBOSS（应用服务器） WebLogic（应用服务器） WebSphere（应用服务器） 应用服务器和WEB服务器的关系？ 应用服务器实现了JavaEE的所有规范。(JavaEE有13个不同的规范。) WEB服务器只实现了JavaEE中的Servlet + JSP两个核心的规范。 通过这个讲解说明了：应用服务器是包含WEB服务器的。 用过JBOSS服务器的同学应该很清楚，JBOSS中内嵌了一个Tomcat服务器。 Tomcat下载 apache官网地址：https://www.apache.org/ tomcat官网地址：https://tomcat.apache.org tomcat开源免费的轻量级WEB服务器。 tomcat还有另外一个名字：catalina（catalina是美国的一个岛屿，风景秀丽，据说作者是在这个风景秀丽的小岛上开发了一个轻量级的WEB服务器，体积小，运行速度快，因此tomcat又被称为catalina） tomcat的logo是一只公猫（寓意表示Tomcat服务器是轻巧的，小巧的，果然，体积小，运行速度快，只实现了Servlet+JSP规范） tomcat是java语言写的。 tomcat服务器要想运行，必须先又jre（Java的运行时环境） Tomcat服务器要想运行，需要先有jre，所以要先安装JDK，配置java运行环境。 JAVA_HOME&#x3D;C:\\Program Files\\Java\\jdk-17.0.1 PATH&#x3D;%JAVA_HOME%\\bin 目前JAVA_HOME没有配置，思考一个问题，这样行不行呢？目前只运行java程序是没问题的。真的没问题吗？ Tomcat服务器的安装： 绿色版本的安装很简单，直接zip包解压即可。解压就是安装。 我有一个好习惯，在C盘的根目录下新建一个dev目录，java开发所有相关的工具都安装到dev目录下，这样比较方便管理。（你随意） 启动Tomcat bin目录下有一个文件：startup.bat,通过它可以启动Tomcat服务器。 xxx.bat文件是个什么文件？bat文件是windows操作系统专用的，bat文件是批处理文件，这种文件中可以编写大量的windows的dos命令，然后执行bat文件就相当于批量的执行dos命令。 startup.sh，这个文件在windows当中无法执行，在Linux环境当中可以使用。在Linux环境下能够执行的是shell命令，大量的shell命令编写在shell文件当中，然后执行这个shell文件可以批量的执行shell命令。 tomcat服务器提供了bat和sh文件，说明了这个tomcat服务器的通用性。 分析startup.bat文件得出，执行这个命令，实际上最后是执行：catalina.bat文件。 catalina.bat文件中有这样一行配置：MAINCLASS&#x3D;org.apache.catalina.startup.Bootstrap （这个类就是main方法所在的类。） tomcat服务器就是Java语言写的，既然是java语言写的，那么启动Tomcat服务器就是执行main方法。 我们尝试打开dos命令窗口，在dos命令窗口中输入startup.bat来启动tomcat服务器。 启动Tomcat服务器只配置path对应的bin目录是不行的。有两个环境变量需要配置： JAVA_HOME&#x3D;JDK的根 CATALINA_HOME&#x3D;Tomcat服务器的根 关于Tomcat服务器的目录 bin ： 这个目录是Tomcat服务器的命令文件存放的目录，比如：启动Tomcat，关闭Tomcat等。 conf： 这个目录是Tomcat服务器的配置文件存放目录。（server.xml文件中可以配置端口号，默认Tomcat端口是8080） lib ：这个目录是Tomcat服务器的核心程序目录，因为Tomcat服务器是Java语言编写的，这里的jar包里面都是class文件。 logs: Tomcat服务器的日志目录，Tomcat服务器启动等信息都会在这个目录下生成日志文件。 temp：Tomcat服务器的临时目录。存储临时文件。 webapps：这个目录当中就是用来存放大量的webapp（web application：web应用） work：这个目录是用来存放JSP文件翻译之后的java文件以及编译之后的class文件。 配置Tomcat服务器需要哪些环境变量？ JAVA_HOME&#x3D;JDK的根 CATALINA_HOME&#x3D;Tomcat服务器的根 PATH&#x3D;%JAVA_HOME%\\bin;%CATALINA_HOME%\\bin 启动Tomcat： startup 关闭Tomcat：stop （shutdown.bat文件重命名为stop.bat，为什么？原因是shutdown命令和windows中的关机命令冲突。所以修改一下。） 怎么测试Tomcat服务器有没有启动成功呢？ 打开浏览器，在浏览器的地址栏上输入URL即可： http://ip地址:端口号 ip地址是什么？端口号我知道，是8080 本机的IP地址是：127.0.0.1，或者是localhost，都行。 实现一个最基本的web应用（这个web应用中没有java小程序） 第一步：找到CATALINA_HOME\\webapps目录 因为所有的webapp要放到webapps目录下。（没有为什么，这是Tomcat服务器的要求。如果不放到这里，Tomcat服务器找不到你的应用。） 第二步：在CATALINA_HOME\\webapps目录下新建一个子目录，起名：oa 这个目录名oa就是你这个webapp的名字。 第三步：在oa目录下新建资源文件，例如：index.html 编写index.html文件的内容。 第四步：启动Tomcat服务器 第五步：打开浏览器，在浏览器地址栏上输入这样的URL： http://127.0.0.1:8080/oa/index.html 思考一个问题： 我们在浏览器上直接输入一个URL，然后回车。这个动作和超链接一样吗？既然是一样的，我们完全可以使用超链接。 123456&lt;!--注意以下的路径，以/开始，带项目名，是一个绝对路径。不需要添加：http://127.0.0.1:8080--&gt;&lt;a href=&quot;/oa/login.html&quot;&gt;user login2&lt;/a&gt;&lt;!--多个层级也没有关系，正常访问即可。--&gt;&lt;!--注意：我们目前前端上的路径都以“/”开始的，都是加项目名的。--&gt;&lt;a href=&quot;/oa/test/debug/d.html&quot;&gt;d page&lt;/a&gt; http://127.0.0.1:8080/oa/userList.html 访问这个地址，可以展示一个用户列表页面。但是这个用户列表页面是写死在HTML文件当中的。这种资源我们称为静态资源。怎么能变成动态资源。显然需要连接数据库。 连接数据库需要JDBC程序，也就是说需要编写Java程序连接数据库，数据库中有多少条记录，页面上就显示多少条记录，这种技术被称为动态网页技术。（动态网页技术并不是说页面中有flash动画。动态网页技术是说页面中的数据是动态的，根据数据库中数据的变化而变化。） 对于一个动态的web应用来说，一个请求和响应的过程有多少个角色参与，角色和角色之间有多少个协议 有哪些角色（在整个BS结构的系统当中，有哪些人参与进去了） 浏览器软件的开发团队（浏览器软件太多了：谷歌浏览器、火狐浏览器、IE浏览器….） WEB Server的开发团队（WEB Server这个软件也是太多了：Tomcat、Jetty、WebLogic、JBOSS、WebSphere….） DB Server的开发团队（DB Server这个软件也是太多了：Oracle、MySQL…..） webapp的开发团队（WEB应用是我们做为JavaWEB程序员开发的） 角色和角色之间需要遵守哪些规范，哪些协议 webapp的开发团队 和 WEB Server的开发团队 之间有一套规范: JavaEE规范之一Servlet规范。 Servlet规范的作用是什么？ WEB Server 和 webapp解耦合。 Browser 和 WebServer之间有一套传输协议：HTTP协议。（超文本传输协议。） webapp开发团队 和 DB Server的开发团队之间有一套规范：JDBC规范。 Servlet规范是一个什么规范？ 遵循Servlet规范的webapp，这个webapp就可以放在不同的WEB服务器中运行。（因为这个webapp是遵循Servlet规范的。） Servlet规范包括什么呢？ 规范了哪些接口 规范了哪些类 规范了一个web应用中应该有哪些配置文件 规范了一个web应用中配置文件的名字 规范了一个web应用中配置文件存放的路径 规范了一个web应用中配置文件的内容 规范了一个合法有效的web应用它的目录结构应该是怎样的。 ….. 开发一个带有Servlet（Java小程序）的webapp（重点） 开发步骤是怎样的？ 第一步：在webapps目录下新建一个目录，起名crm（这个crm就是webapp的名字）。当然，也可以是其它项目，比如银行项目，可以创建一个目录bank，办公系统可以创建一个oa。 注意：crm就是这个webapp的根 第二步：在webapp的根下新建一个目录：WEB-INF 注意：这个目录的名字是Servlet规范中规定的，必须全部大写，必须一模一样。必须的必须。 第三步：在WEB-INF目录下新建一个目录：classes 注意：这个目录的名字必须是全部小写的classes。这也是Servlet规范中规定的。另外这个目录下一定存放的是Java程序编译之后的class文件（这里存放的是字节码文件）。 第四步：在WEB-INF目录下新建一个目录：lib 注意：这个目录不是必须的。但如果一个webapp需要第三方的jar包的话，这个jar包要放到这个lib目录下，这个目录的名字也不能随意编写，必须是全部小写的lib。例如java语言连接数据库需要数据库的驱动jar包。那么这个jar包就一定要放到lib目录下。这Servlet规范中规定的。 第五步：在WEB-INF目录下新建一个文件：web.xml 注意：这个文件是必须的，这个文件名必须叫做web.xml。这个文件必须放在这里。一个合法的webapp，web.xml文件是必须的，这个web.xml文件就是一个配置文件，在这个配置文件中描述了请求路径和Servlet类之间的对照关系。 这个文件最好从其他的webapp中拷贝，最好别手写。没必要。复制粘贴 &#96;&#96;&#96;xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- 第六步：编写一个Java程序，这个小Java程序也不能随意开发，这个小java程序必须实现Servlet接口。 - 这个Servlet接口不在JDK当中。（因为Servlet不是JavaSE了。Servlet属于JavaEE，是另外的一套类库。） - Servlet接口（Servlet.class文件）是Oracle提供的。（最原始的是sun公司提供的。） - Servlet接口是JavaEE的规范中的一员。 - Tomcat服务器实现了Servlet规范，所以Tomcat服务器也需要使用Servlet接口。Tomcat服务器中应该有这个接口，Tomcat服务器的CATALINA_HOME\\lib目录下有一个servlet-api.jar，解压这个servlet-api.jar之后，你会看到里面有一个Servlet.class文件。 - 重点：从JakartaEE9开始，Servlet接口的全名变了：jakarta.servlet.Servlet - 注意：编写这个Java小程序的时候，java源代码你愿意在哪里就在哪里，位置无所谓，你只需要将java源代码编译之后的class文件放到classes目录下即可。- 第七步：编译我们编写的HelloServlet - 重点：你怎么能让你的HelloServlet编译通过呢？配置环境变量CLASSPATH CLASSPATH=.;C:\\dev\\apache-tomcat-10.0.12\\lib\\servlet-api.jar - 思考问题：以上配置的CLASSPATH和Tomcat服务器运行有没有关系？ - 没有任何关系，以上配置这个环境变量只是为了让你的HelloServlet能够正常编译生成class文件。- 第八步：将以上编译之后的HelloServlet.class文件拷贝到WEB-INF\\classes目录下。- 第九步：在web.xml文件中编写配置信息，让“请求路径”和“Servlet类名”关联在一起。 - 这一步用专业术语描述：在web.xml文件中注册Servlet类。 - ```xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot; version=&quot;5.0&quot; metadata-complete=&quot;true&quot;&gt; &lt;!--servlet描述信息--&gt; &lt;!--任何一个servlet都对应一个servlet-mapping --&gt; &lt;servlet&gt; &lt;servlet-name&gt;fdsafdsagfdsafdsa&lt;/servlet-name&gt; &lt;!--这个位置必须是带有包名的全限定类名--&gt; &lt;servlet-class&gt;com.bjpowernode.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--servlet映射信息--&gt; &lt;servlet-mapping&gt; &lt;!--这个也是随便的，不过这里写的内容要和上面的一样。--&gt; &lt;servlet-name&gt;fdsafdsagfdsafdsa&lt;/servlet-name&gt; &lt;!--这里需要一个路径--&gt; &lt;!--这个路径唯一的要求是必须以 / 开始--&gt; &lt;!--当前这个路径可以随便写--&gt; &lt;url-pattern&gt;/fdsa/fd/saf/d/sa/fd/sa/fd&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 第十步：启动Tomcat服务器 第十一步：打开浏览器，在浏览器地址栏上输入一个url，这个URL必须是： http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd 非常重要的一件事：浏览器上的请求路径不能随便写，这个请求路径必须和web.xml文件中的url-pattern一致。 注意：浏览器上的请求路径和web.xml文件中的url-pattern的唯一区别就是：浏览器上的请求路径带项目名：&#x2F;crm 浏览器上编写的路径太复杂，可以使用超链接。（非常重要：html页面只能放到WEB-INF目录外面。） 以后不需要我们编写main方法了。tomcat服务器负责调用main方法，Tomcat服务器启动的时候执行的就是main方法。我们javaweb程序员只需要编写Servlet接口的实现类，然后将其注册到web.xml文件中，即可。 总结一下：一个合法的webapp目录结构应该是怎样的？ 12345678910webapproot |------WEB-INF |------classes(存放字节码) |------lib(第三方jar包) |------web.xml(注册Servlet) |------html |------css |------javascript |------image .... 浏览器发送请求，到最终服务器调用Servlet中的方法，是怎样的一个过程？（以下这个过程描述的很粗糙。其中还有很多步骤我省略了。） 用户输入URL，或者直接点击超链接：http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd 然后Tomcat服务器接收到请求，截取路径：&#x2F;crm&#x2F;fdsa&#x2F;fd&#x2F;saf&#x2F;d&#x2F;sa&#x2F;fd&#x2F;sa&#x2F;fd Tomcat服务器找到crm项目 Tomcat服务器在web.xml文件中查找&#x2F;fdsa&#x2F;fd&#x2F;saf&#x2F;d&#x2F;sa&#x2F;fd&#x2F;sa&#x2F;fd 对应的Servlet是：com.bjpowernode.servlet.HelloServlet Tomcat服务器通过反射机制，创建com.bjpowernode.servlet.HelloServlet的对象。 Tomcat服务器调用com.bjpowernode.servlet.HelloServlet对象的service方法。 关于JavaEE的版本 JavaEE目前最高版本是 JavaEE8 JavaEE被Oracle捐献了，Oracle将JavaEE规范捐献给Apache了。 Apache把JavaEE换名了，以后不叫JavaEE了，以后叫做 jakarta EE。 以后没有JavaEE了。以后都叫做Jakarta EE。 JavaEE8版本升级之后的”JavaEE 9”，不再是”JavaEE9”这个名字了，叫做JakartaEE9 JavaEE8的时候对应的Servlet类名是：javax.servlet.Servlet JakartaEE9的时候对应的Servlet类名是：jakarta.servlet.Servlet （包名都换了） 如果你之前的项目还是在使用javax.servlet.Servlet，那么你的项目无法直接部署到Tomcat10+版本上。你只能部署到Tomcat9-版本上。在Tomcat9以及Tomcat9之前的版本中还是能够识别javax.servlet这个包。 解决Tomcat服务器在DOS命令窗口中的乱码问题（控制台乱码）将CATALINA_HOME&#x2F;conf&#x2F;logging.properties文件中的内容修改如下： java.util.logging.ConsoleHandler.encoding &#x3D; GBK 向浏览器响应一段HTML代码12345public void service(ServletRequest request, ServletResponse response)&#123; response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.print(&quot;&lt;h1&gt;hello servlet!&lt;/h1&gt;&quot;);&#125; 在Servlet中连接数据库，怎么做？ Servlet是Java程序，所以在Servlet中完全可以编写JDBC代码连接数据库。 在一个webapp中去连接数据库，需要将驱动jar包放到WEB-INF&#x2F;lib目录下。（com.mysql.cj.jdbc.Driver 这个类就在驱动jar包当中。） 在集成开发环境当中开发Servlet程序 集成开发工具很多，其中目前使用比较多的是： IntelliJ IDEA（这个居多，IDEA在提示功能方面要强于Eclipse，也就是说IDEA使用起来比Eclipse更加智能，更好用。JetBrain公司开发的。收费的。） Eclipse（这个少一些），Eclipse目前还是有团队使用，只不过处于减少的趋势，自己从事工作之后，可能会遇到。Eclipse是IBM团队开发的。Eclipse寓意是“日食”。“日食”表示将太阳吃掉。太阳是SUN。IBM团队开发Eclipse的寓意是吞并SUN公司，但是2009年的时候SUN公司被Oracle公司并购了。IBM并没有成功并购SUN公司。 使用IDEA集成开发工具开发Servlet 第一步：New Project（我比较习惯先创建一个Empty Project【空工程】，然后在空工程下新建Module【模块】，这不是必须的，只是一种习惯，你可以直接新建非空的Project），这个Empty Project起名为：javaweb（不是必须的，只是一个名字而已。一般情况下新建的Project的名字最好和目录的名字一致。） 第二步：新建模块（File –&gt; new –&gt; Module…） 这里新建的是一个普通的JavaSE模块（这里先不要新建Java Enterprise模块） 这个Module自动会被放在javaweb的project下面。 这个Module起名：servlet01 第三步：让Module变成JavaEE的模块。（让Module变成webapp的模块。符合webapp规范。符合Servlet规范的Module） 在Module上点击右键：Add Framework Support…（添加框架支持） 在弹出的窗口中，选择Web Application（选择的是webapp的支持） 选择了这个webapp的支持之后，IDEA会自动给你生成一个符合Servlet规范的webpp目录结构。 重点，需要注意的：在IDEA工具中根据Web Application模板生成的目录中有一个web目录，这个目录就代表webapp的根 第四步（非必须）：根据Web Application生成的资源中有index.jsp文件，这里我选择删除这个index.jsp文件。 第五步：编写Servlet（StudentServlet） class StudentServlet implements Servlet 这个时候发现Servlet.class文件没有。怎么办？将CATALINA_HOME&#x2F;lib&#x2F;servlet-api.jar和jsp-api.jar添加到classpath当中（这里的classpath说的是IDEA的classpath） File –&gt; Project Structrue –&gt; Modules –&gt; + 加号 –&gt; Add JARS…. 实现jakarta.servlet.Servlet接口中的5个方法。 第六步：在Servlet当中的service方法中编写业务代码（我们这里连接数据库了。） 第七步：在WEB-INF目录下新建了一个子目录：lib（这个目录名可不能随意，必须是全部小写的lib），并且将连接数据库的驱动jar包放到lib目录下。 第八步：在web.xml文件中完成StudentServlet类的注册。（请求路径和Servlet之间对应起来） 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;studentServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjpowernode.javaweb.servlet.StudentServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;studentServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/student&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 第九步：给一个html页面，在HTML页面中编写一个超链接，用户点击这个超链接，发送请求，Tomcat执行后台的StudentServlet。 student.html 这个文件不能放到WEB-INF目录里面，只能放到WEB-INF目录外面。 student.html文件的内容 &#96;&#96;&#96;html student page student list 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 - 第十步：让IDEA工具去关联Tomcat服务器。关联的过程当中将webapp部署到Tomcat服务器当中。 - IDEA工具右上角，绿色小锤子右边有一个：Add Configuration - 左上角加号，点击Tomcat Server --&gt; local - 在弹出的界面中设置服务器Server的参数（基本上不用动） - 在当前窗口中有一个Deployment（点击这个用来部署webapp），继续点击加号，部署即可。 - 修改 Application context为：/xmm - 第十一步：启动Tomcat服务器 - 在右上角有绿色的箭头，或者绿色的小虫子，点击这个绿色的小虫子，可以采用debug的模式启动Tomcat服务器。 - 我们开发中建议适用debug模式启动Tomcat - 第十二步：打开浏览器，在浏览器地址栏上输入：http://localhost:8080/xmm/student.html## Servlet对象的生命周期- 什么是Servlet对象生命周期？ - Servlet对象什么时候被创建。 - Servlet对象什么时候被销毁。 - Servlet对象创建了几个？ - Servlet对象的生命周期表示：一个Servlet对象从出生在最后的死亡，整个过程是怎样的。- Servlet对象是由谁来维护的？ - Servlet对象的创建，对象上方法的调用，对象最终的销毁，Javaweb程序员是无权干预的。 - Servlet对象的生命周期是由Tomcat服务器（WEB Server）全权负责的。 - Tomcat服务器通常我们又称为：WEB容器。（这个叫法你要知道【WEB Container】） - WEB容器来管理Servlet对象的死活。- 思考：我们自己new的Servlet对象受WEB容器的管理吗？ - 我们自己new的Servlet对象是不受WEB容器管理的。 - WEB容器创建的Servlet对象，这些Servlet对象都会被放到一个集合当中（HashMap），只有放到这个HashMap集合中的Servlet才能够被WEB容器管理，自己new的Servlet对象不会被WEB容器管理。（自己new的Servlet对象不在容器当中） - web容器底层应该有一个HashMap这样的集合，在这个集合当中存储了Servlet对象和请求路径之间的关系 - ![WEB容器中的Map集合](D:\\course\\01-Servlet\\文档\\WEB容器中的Map集合.png)- 研究：服务器在启动的Servlet对象有没有被创建出来（默认情况下）？ - 在Servlet中提供一个无参数的构造方法，启动服务器的时候看看构造方法是否执行。 - 经过测试得出结论：默认情况下，服务器在启动的时候Servlet对象并不会被实例化。 - 这个设计是合理的。用户没有发送请求之前，如果提前创建出来所有的Servlet对象，必然是耗费内存的，并且创建出来的Servlet如果一直没有用户访问，显然这个Servlet对象是一个废物，没必要先创建。- 怎么让服务器启动的时候创建Servlet对象呢？ - 在servlet标签中添加&lt;load-on-startup&gt;子标签，在该子标签中填写整数，越小的整数优先级越高。 - ```xml &lt;servlet&gt; &lt;servlet-name&gt;aservlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjpowernode.javaweb.servlet.AServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;aservlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/a&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Servlet对象生命周期 默认情况下服务器启动的时候AServlet对象并没有被实例化 这里的Aservlet 指的是 一个自定义的类 用户发送第一次请求的时候，控制台输出了以下内容： 123AServlet无参数构造方法执行了AServlet&#x27;s init method execute!AServlet&#x27;s service method execute! 根据以上输出内容得出结论： 用户在发送第一次请求的时候Servlet对象被实例化（AServlet的构造方法被执行了。并且执行的是无参数构造方法。） AServlet对象被创建出来之后，Tomcat服务器马上调用了AServlet对象的init方法。（init方法在执行的时候，AServlet对象已经存在了。已经被创建出来了。） 用户发送第一次请求的时候，init方法执行之后，Tomcat服务器马上调用AServlet对象的service方法。 用户继续发送第二次请求，控制台输出了以下内容： 1AServlet&#x27;s service method execute! 根据以上输出结果得知，用户在发送第二次，或者第三次，或者第四次请求的时候，Servlet对象并没有新建，还是使用之前创建好的Servlet对象，直接调用该Servlet对象的service方法，这说明： 第一：Servlet对象是单例的（单实例的。但是要注意：Servlet对象是单实例的，但是Servlet类并不符合单例模式。我们称之为&#x3D;&#x3D;假单例&#x3D;&#x3D;。之所以单例是因为Servlet对象的创建我们javaweb程序员管不着，这个&#x3D;&#x3D;对象的创建只能是Tomcat来说了算&#x3D;&#x3D;，Tomcat只创建了一个，所以导致了单例，但是属于假单例。真单例模式，构造方法是私有化的。） 第二：无参数构造方法、init方法只在第一次用户发送请求的时候执行。也就是说无参数构造方法只执行一次。init方法也只被Tomcat服务器调用一次。 第三：只要用户发送一次请求：service方法必然会被Tomcat服务器调用一次。发送100次请求，service方法会被调用100次。 关闭服务器的时候，控制台输出了以下内容： 1AServlet&#x27;s destroy method execute! 通过以上输出内容，可以得出以下结论： Servlet的destroy方法只被Tomcat服务器调用一次。 destroy方法是在什么时候被调用的？ 在服务器关闭的时候。 因为服务器关闭的时候要销毁AServlet对象的内存。 服务器在销毁AServlet对象内存之前，Tomcat服务器会自动调用AServlet对象的destroy方法。 请问：destroy方法调用的时候，对象销毁了还是没有销毁呢？ destroy方法执行的时候AServlet对象还在，没有被销毁。destroy方法执行结束之后，AServlet对象的内存才会被Tomcat释放。 Servlet对象更像一个人的一生： Servlet的无参数构造方法执行：标志着你出生了。 Servlet对象的init方法的执行：标志着你正在接受教育。 Servlet对象的service方法的执行：标志着你已经开始工作了，已经开始为人类提供服务了。 Servlet对象的destroy方法的执行：标志着临终。有什么遗言，抓紧的。要不然，来不及了。 关于Servlet类中方法的调用次数？ 构造方法只执行一次。 init方法只执行一次。 service方法：用户发送一次请求则执行一次，发送N次请求则执行N次。 destroy方法只执行一次。 当我们Servlet类中编写一个有参数的构造方法，如果没有手动编写无参数构造方法会出现什么问题？ &#x3D;&#x3D;报错了：500错误。&#x3D;&#x3D; 注意：500是一个HTTP协议的错误状态码。 500一般情况下是因为服务器端的Java程序出现了异常。（服务器端的错误都是500错误：服务器内部错误。） 如果没有无参数的构造方法，会导致出现500错误，无法实例化Servlet对象。 所以，一定要注意：在Servlet开发当中，不建议程序员来定义构造方法，因为定义不当，一不小心就会导致无法实例化Servlet对象。 思考：Servlet的无参数构造方法是在对象第一次创建的时候执行，并且只执行一次。init方法也是在对象第一次创建的时候执行，并且只执行一次。那么这个无参数构造方法可以代替掉init方法吗？ 不能。 Oracle标准中。 Servlet规范中有要求，作为javaweb程序员，编写Servlet类的时候，&#x3D;&#x3D;不建议手动编写构造方法&#x3D;&#x3D;，因为编写构造方法，很容易让无参数构造方法消失，这个操作可能会导致Servlet对象无法实例化。所以init方法是有存在的必要的。 执行 构造器 后就会立刻执行 init 方法，几乎是同时的。 init、service、destroy方法中使用最多的是哪个方法？ 使用最多就是service方法，service方法是一定要实现的，因为service方法是处理用户请求的核心方法。 什么时候使用init方法呢？ init方法很少用。 什么代码只执行一次？ 通常在init方法当中做初始化操作，并且这个初始化操作只需要执行一次。例如：初始化数据库连接池，初始化线程池…. 什么时候使用destroy方法呢？ destroy方法也很少用。 通常在destroy方法当中，进行&#x3D;&#x3D;资源的关闭&#x3D;&#x3D;。马上对象要被销毁了，还有什么没有关闭的，抓紧时间关闭资源。还有什么资源没保存的，抓紧时间保存一下。 执行流程 第一次访问 –&gt; 使用反射机制调用书写的 servlet 无参构造方法创建对象 —&gt; 调用 init 方法完成初始化 —&gt;service 第n次 直接调用第一次创建的对象的service方法 GenericServlet 我们编写一个Servlet类直接实现Servlet接口有什么缺点？ 我们只需要service方法，其他方法大部分情况下是不需要使用的。代码很丑陋。 适配器设计模式Adapter 手机直接插到220V的电压上，手机直接就报废了。怎么办？可以找一个充电器。这个充电器就是一个适配器。手机连接适配器。适配器连接220V的电压。这样问题就解决了。 编写一个GenericServlet类，这个类是一个抽象类，其中有一个抽象方法service。 GenericServlet实现Servlet接口。 GenericServlet是一个适配器。 以后编写的所有Servlet类继承GenericServlet，重写service方法即可。 思考：GenericServlet类是否需要改造一下？怎么改造？更利于子类程序的编写？ 思考第一个问题：我提供了一个GenericServlet之后，init方法还会执行吗？ 还会执行。会执行GenericServlet类中的init方法。 思考第二个问题：init方法是谁调用的？ Tomcat服务器调用的。 思考第三个问题：init方法中的ServletConfig对象是谁创建的？是谁传过来的？ 都是Tomcat干的。 Tomcat服务器先创建了ServletConfig对象，然后调用init方法，将ServletConfig对象传给了init方法。 思考一下Tomcat服务器伪代码： &#96;&#96;&#96;javapublic class Tomcat {public static void main(String[] args){ &#x2F;&#x2F; ….. &#x2F;&#x2F; Tomcat服务器伪代码 &#x2F;&#x2F; 创建LoginServlet对象（通过反射机制，调用无参数构造方法来实例化LoginServlet对象） Class clazz &#x3D; Class.forName(“com.bjpowernode.javaweb.servlet.LoginServlet”); Object obj &#x3D; clazz.newInstance(); &#x2F;&#x2F; 向下转型 Servlet servlet &#x3D; (Servlet)obj; &#x2F;&#x2F; 创建ServletConfig对象 &#x2F;&#x2F; Tomcat服务器负责将ServletConfig对象实例化出来。 &#x2F;&#x2F; 多态（Tomcat服务器完全实现了Servlet规范） ServletConfig servletConfig &#x3D; new org.apache.catalina.core.StandardWrapperFacade(); &#x2F;&#x2F; 调用Servlet的init方法 servlet.init(servletConfig); &#x2F;&#x2F; 调用Servlet的service方法 &#x2F;&#x2F; ….}}12345678910111213141516171819202122232425## ServletConfig- 什么是ServletConfig？ - Servlet对象的配置信息对象。 - ServletConfig对象中封装了&lt;servlet&gt;&lt;/servlet&gt;标签中的配置信息。（web.xml文件中servlet的配置信息）- ==一个Servlet对应一个ServletConfig对象。==- Servlet对象是Tomcat服务器创建，并且ServletConfig对象也是Tomcat服务器创建。并且默认情况下，他们都是在用户==发送第一次请求==的时候创建。- Tomcat服务器调用Servlet对象的init方法的时候需要传一个ServletConfig对象的参数给init方法。 - ServletConfig接口的实现类是Tomcat服务器给实现的。（Tomcat服务器说的就是WEB服务器。）- ServletConfig接口有哪些常用的方法？ - ```java public String getInitParameter(String name); // 通过初始化参数的name获取value public Enumeration&lt;String&gt; getInitParameterNames(); // 获取所有的初始化参数的name public ServletContext getServletContext(); // 获取ServletContext对象 public String getServletName(); // 获取Servlet的name 以上方法在Servlet类当中，都可以使用this去调用。因为GenericServlet实现了ServletConfig接口。 一个Servlet对象对应一个ServletConfig。100个Servlet对象则对应100个ServletConfig对象。 ServletContext 只要在同一个webapp当中，只要在同一个应用(webapp)当中，所有的Servlet对象都是共享同一个ServletContext对象的。 ServletContext对象在服务器启动阶段创建，在服务器关闭的时候销毁。这就是ServletContext对象的生命周期。ServletContext对象是应用级对象。 Tomcat服务器中有一个 webapps，这个 webapps 下可以存放 webapp，可以存放多个webapp ，假设有100个 webapp，那么就有100个ServletContext对象。但是，总之，一个应用，一个webapp肯定是只有一个ServletContext对象。 ServletContext被称为 Servlet 上下文对象。（Servlet对象的四周环境对象。） 一个ServletContext对象通常对应的是一个 &#x3D;&#x3D;web.xml&#x3D;&#x3D; 文件。 ServletContext对应显示生活中的什么例子呢？ 一个教室里有多个学生，那么每一个学生就是一个Servlet，这些学生都在同一个教室当中，那么我们可以把这个教室叫做ServletContext对象。那么也就是说放在这个ServletContext对象（环境）当中的数据，在同一个教室当中，物品都是共享的。比如：教室中有一个空调，所有的学生都可以操作。可见，空调是共享的。因为空调放在教室当中。教室就是ServletContext对象。 ServletContext是一个接口，Tomcat服务器对ServletContext接口进行了实现。 ServletContext对象的创建也是Tomcat服务器来完成的。启动webapp的时候创建的。 ServletContext接口中有哪些常用的方法？ 一、获取 web.xml 文件中的配置信息 public String getInitParameter(String name); // 通过初始化参数的name获取value public Enumeration&lt;String&gt; getInitParameterNames(); // 获取所有的初始化参数的name 12345678910111213- ```xml &lt;!--以上两个方法是ServletContext对象的方法，这个方法获取的是什么信息？是以下的配置信息--&gt; &lt;context-param&gt; &lt;param-name&gt;pageSize&lt;/param-name&gt; &lt;param-value&gt;10&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;startIndex&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--注意：以上的配置信息属于应用级的配置信息，一般一个项目中共享的配置信息会放到以上的标签当中。--&gt; &lt;!--如果你的配置信息只是想给某一个servlet作为参考，那么你配置到servlet标签当中即可，使用ServletConfig对象来获取。--&gt; // 获取应用的根路径（非常重要），因为在java源代码当中有一些地方可能会需要应用的根路径，这个方法可以动态获取应用的根路径 // 在java源码当中，不要将应用的根路径写死，因为你永远都不知道这个应用在最终部署的时候，起一个什么名字。 public String getContextPath(); //String contextPath = application.getContextPath(); 12345678910111213141516- ```java // 获取文件的绝对路径（真实路径） public String getRealPath(String path); 1.写/就从 web应用 的根开始指定路径找 ---&gt;适合指定路径 2.不写 /，默认也是从 web根(web文件夹)下找 System.out.println(servletContext.getRealPath(&quot;add1.html&quot;)); ---不能用于多级目录，否则会出问题 add1.html的正确路径应该是 D:\\project_jhfuture\\IDEA\\Tomcat_learn\\out\\artifacts\\pro07\\hello\\add1.html 而返回的结果 D:\\project_jhfuture\\IDEA\\Tomcat_learn\\out\\artifacts\\pro07\\add1.html -如果存在多个同名文件，则以目录优先级为准 ![image-20221211002313349](Servlet-JSP-课堂笔记/image-20221211002313349.png) ### 二、记录日志 通过ServletContext对象也是可以记录日志的 public void log(String message); public void log(String message, Throwable t); // 这些日志信息记录到哪里了？ // localhost.2021-11-05.log // Tomcat服务器的logs目录下都有哪些日志文件？ //catalina.2021-11-05.log 服务器端的java程序运行的控制台信息。 //localhost.2021-11-05.log ServletContext对象的log方法记录的日志信息存储到这个文件中。 //localhost_access_log.2021-11-05.txt 访问日志 12345678910111213141516171819 查看idea中的 tomcat log日志路径 using CATABLINA_BASE idea根据配置的tomcat自己再生产的一个。 ![image-20221211003841185](Servlet-JSP-课堂笔记/image-20221211003841185.png) ### 三、应用域 - 数据满足三个要点 - 1.数据量小、 - 2.所有用户共享、 - 3.又不修改 - 怎么用 - 存 - ```java public void setAttribute(String name, Object value); // map.put(k, v) - - 取 - ```java // 取（怎么从ServletContext应用域中取数据） public Object getAttribute(String name); // Object v = map.get(k) 123456 - 删 - ```java // 删（怎么删除ServletContext应用域中的数据） public void removeAttribute(String name); // map.remove(k) - &#96;&#96;&#96;java&#x2F;&#x2F; ServletContext对象还有另一个名字：应用域（后面还有其他域，例如：请求域、会话域） &#x2F;&#x2F; 如果所有的用户共享一份数据，并且这个数据很少的被修改，并且这个数据量很少，可以将这些数据放到ServletContext这个应用域中 &#x2F;&#x2F; 为什么是所有用户共享的数据？ 不是共享的没有意义。因为ServletContext这个对象只有一个。只有共享的数据放进去才有意义。 &#x2F;&#x2F; 为什么数据量要小？ 因为数据量比较大的话，太占用堆内存，并且这个对象的生命周期比较长，服务器关闭的时候，这个对象才会被销毁。大数据量会影响服务器的性能。占用内存较小的数据量可以考虑放进去。 &#x2F;&#x2F; 为什么这些共享数据很少的修改，或者说几乎不修改？—&gt; Only Read&#x2F;&#x2F; 所有用户共享的数据，如果涉及到修改操作，必然会存在线程并发所带来的安全问题。&#x2F;&#x2F;—-&gt;所以放在ServletContext对象中的数据一般都是只读的。 &#x2F;&#x2F; 1数据量小、2所有用户共享、3又不修改，这样的数据放到ServletContext这个应用域当中，会大大提升效率。因为应用域相当于一个缓存，放到缓存中的数据，下次在用的时候，不需要从数据库中再次获取，大大提升执行效率。 &#x2F;&#x2F; 存（怎么向ServletContext应用域中存数据）public void setAttribute(String name, Object value); &#x2F;&#x2F; map.put(k, v)&#x2F;&#x2F; 取（怎么从ServletContext应用域中取数据）public Object getAttribute(String name); &#x2F;&#x2F; Object v &#x3D; map.get(k)&#x2F;&#x2F; 删（怎么删除ServletContext应用域中的数据）public void removeAttribute(String name); &#x2F;&#x2F; map.remove(k) 123456789 - 注意：以后我们编写Servlet类的时候，实际上是不会去直接继承GenericServlet类的，因为我们是B/S结构的系统，这种系统是基于HTTP超文本传输协议的，在Servlet规范当中，提供了一个类叫做HttpServlet，它是专门为HTTP协议准备的一个Servlet类。我们编写的Servlet类要继承HttpServlet。（HttpServlet是HTTP协议专用的。）使用HttpServlet处理HTTP协议更便捷。但是你需要直到它的继承结构： - ``` jakarta.servlet.Servlet（接口）【爷爷】 jakarta.servlet.GenericServlet implements Servlet（抽象类）【儿子】 jakarta.servlet.http.HttpServlet extends GenericServlet（抽象类）【孙子】 我们以后编写的Servlet要继承HttpServlet类。 大家到目前为止都接触过哪些缓存机制了？ 堆内存当中的字符串常量池。 “abc” 先在字符串常量池中查找，如果有，直接拿来用。如果没有则新建，然后再放入字符串常量池。 堆内存当中的整数型常量池。 [-128 ~ 127] 一共256个Integer类型的引用，放在整数型常量池中。没有超出这个范围的话，直接从常量池中取。 连接池(Connection Cache) 这里所说的连接池中的连接是java语言连接数据库的连接对象：java.sql.Connection对象。 JVM是一个进程。MySQL数据库是一个进程。进程和进程之间建立连接，打开通道是很费劲的。是很耗费资源的。怎么办？可以提前先创建好N个Connection连接对象，将连接对象放到一个集合当中，我们把这个放有Connection对象的集合称为连接池。每一次用户连接的时候不需要再新建连接对象，省去了新建的环节，直接从连接池中获取连接对象，大大提升访问效率。 连接池 最小连接数 最大连接数 连接池可以提高用户的访问效率。当然也可以保证数据库的安全性。 线程池 Tomcat服务器本身就是支持多线程的。 Tomcat服务器是在用户发送一次请求，就新建一个Thread线程对象吗？ 当然不是，实际上是在Tomcat服务器启动的时候，会先创建好N多个线程Thread对象，然后将线程对象放到集合当中，称为线程池。用户发送请求过来之后，需要有一个对应的线程来处理这个请求，这个时候线程对象就会直接从线程池中拿，效率比较高。 所有的WEB服务器，或者应用服务器，都是支持多线程的，都有线程池机制。 redis NoSQL数据库。非关系型数据库。缓存数据库。 向ServletContext应用域中存储数据，也等于是将数据存放到缓存cache当中了。 HTTP协议 什么是协议？ 协议实际上是某些人，或者某些组织提前制定好的一套规范，大家都按照这个规范来，这样可以做到沟通无障碍。 协议就是一套规范，就是一套标准。由其他人或其他组织来负责制定的。 我说的话你能听懂，你说的话，我也能听懂，这说明我们之间是有一套规范的，一套协议的，这套协议就是：中国普通话协议。我们都遵守这套协议，我们之间就可以沟通无障碍。 什么是HTTP协议？ HTTP协议：是W3C制定的一种超文本传输协议。（通信协议：发送消息的模板提前被制定好。） W3C： 万维网联盟组织 负责制定标准的：HTTP HTML4.0 HTML5 XML DOM等规范都是W3C制定的。 万维网之父：蒂姆·伯纳斯·李 什么是超文本？ 超文本说的就是：不是普通文本，比如流媒体：声音、视频、图片等。 HTTP协议支持：不但可以传送普通字符串，同样支持传递声音、视频、图片等流媒体信息。 这种协议游走在B和S之间。B向S发数据要遵循HTTP协议。S向B发数据同样需要遵循HTTP协议。这样B和S才能解耦合。 什么是解耦合？ B不依赖S。 S也不依赖B。 B&#x2F;S表示：B&#x2F;S结构的系统（浏览器访问WEB服务器的系统） 浏览器 向 WEB服务器发送数据，叫做：请求（request) WEB服务器 向 浏览器发送数据，叫做：响应（response） HTTP协议包括： 请求协议 浏览器 向 WEB服务器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体格式。 响应协议 WEB服务器 向 浏览器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体格式。 HTTP协议就是提前制定好的一种消息模板。 不管你是哪个品牌的浏览器，都是这么发。 不管你是哪个品牌的WEB服务器，都是这么发。 FF浏览器 可以向 Tomcat发送请求，也可以向Jetty服务器发送请求。浏览器不依赖具体的服务器品牌。 WEB服务器也不依赖具体的浏览器品牌。可以是FF浏览器，也可以是Chrome浏览器，可以是IE，都行。 HTTP的请求协议（B –&gt; S） HTTP的请求协议包括：4部分 请求行 请求头 空白行 请求体 HTTP请求协议的具体报文：GET请求 &#96;&#96;&#96;GET &#x2F;servlet05&#x2F;getServlet?username&#x3D;lucy&amp;userpwd&#x3D;1111 HTTP&#x2F;1.1 请求行Host: localhost:8080 请求头Connection: keep-alivesec-ch-ua: “Google Chrome”;v&#x3D;”95”, “Chromium”;v&#x3D;”95”, “;Not A Brand”;v&#x3D;”99”sec-ch-ua-mobile: ?0sec-ch-ua-platform: “Windows”Upgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;95.0.4638.54 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,&#x2F;;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Sec-Fetch-Site: same-originSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentReferer: http://localhost:8080/servlet05/index.htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q&#x3D;0.9 空白行 请求体 例如12345678910111213141516171819202122232425262728 - HTTP请求协议的具体报文：POST请求 - ``` POST /servlet05/postServlet HTTP/1.1 请求行 Host: localhost:8080 请求头 Connection: keep-alive Content-Length: 25 Cache-Control: max-age=0 sec-ch-ua: &quot;Google Chrome&quot;;v=&quot;95&quot;, &quot;Chromium&quot;;v=&quot;95&quot;, &quot;;Not A Brand&quot;;v=&quot;99&quot; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: &quot;Windows&quot; Upgrade-Insecure-Requests: 1 Origin: http://localhost:8080 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: same-origin Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Referer: http://localhost:8080/servlet05/index.html Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 空白行 username=lisi&amp;userpwd=123 请求体 请求行 包括三部分： 第一部分：请求方式（7种） get（常用的） post（常用的） delete put head options trace 第二部分：URI 什么是URI？ 统一资源标识符。代表网络中某个资源的名字。但是通过URI是无法定位资源的。 什么是URL？统一资源定位符。代表网络中某个资源，同时，通过URL是可以定位到该资源的。 URI和URL什么关系，有什么区别？ URL包括URI http://localhost:8080/servlet05/index.html 这是URL。 &#x2F;servlet05&#x2F;index.html 这是URI。 第三部分：HTTP协议版本号 请求头 请求的主机 主机的端口 浏览器信息 平台信息 cookie等信息 …. 空白行 空白行是用来区分“请求头”和“请求体” 请求体 向服务器发送的具体数据。 HTTP的响应协议（S –&gt; B） HTTP的响应协议包括：4部分 状态行 响应头 空白行 响应体 HTTP响应协议的具体报文： &#96;&#96;&#96;HTTP&#x2F;1.1 200 ok 状态行Content-Type: text&#x2F;html;charset&#x3D;UTF-8 响应头Content-Length: 160Date: Mon, 08 Nov 2021 13:19:32 GMTKeep-Alive: timeout&#x3D;20Connection: keep-alive 空白行 响应体 from get servlet from get servlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325 - 状态行 - 三部分组成 - 第一部分：协议版本号（HTTP/1.1） - 第二部分：状态码（HTTP协议中规定的响应状态号。不同的响应结果对应不同的号码。） - 200 表示请求响应成功，正常结束。 - 以4开始的，一般是浏览器端的错误导致的。 - 404表示访问的资源不存在，通常是因为要么是你路径写错了，要么是路径写对了，但是服务器中对应的资源并没有启动成功。总之404错误是前端错误。 - 405 表示前端发送的请求方式与后端请求的==处理方式不一致==时发生： - 比如：前端是POST请求，后端的处理方式按照get方式进行处理时，发生405 - 比如：前端是GET请求，后端的处理方式按照post方式进行处理时，发生405 - 以5开始的，一般是服务器端的错误导致的。 - 500表示服务器端的程序出现了异常。一般会认为是服务器端的错误导致的。 - 第三部分：状态的描述信息 - ok 表示正常成功结束。 - not found 表示资源找不到。 - 响应头： - 响应的内容类型 - 响应的内容长度 - 响应的时间 - .... - 空白行： - 用来分隔“响应头”和“响应体”的。 - 响应体： - 响应体就是响应的正文，这些内容是一个长的字符串，这个字符串被浏览器渲染，解释并执行，最终展示出效果。- 怎么查看的协议内容？ - 使用chrome浏览器：F12。然后找到network，通过这个面板可以查看协议的具体内容。- 怎么向服务器发送GET请求，怎么向服务器发送POST请求？ - 到目前为止，只有一种情况可以发送POST请求：使用form表单，并且form标签中的method属性值为：method=&quot;post&quot;。 - 其他所有情况一律都是get请求： - 在浏览器地址栏上直接输入URL，敲回车，属于get请求。 - 在浏览器上直接点击超链接，属于get请求。 - 使用form表单提交数据时，form标签中没有写method属性，默认就是get - 或者使用form的时候，form标签中method属性值为：method=&quot;get&quot; - ....- GET请求和POST请求有什么区别？ - get请求发送数据的时候，数据会挂在URI的后面，并且在URI后面添加一个“?”，&quot;?&quot;后面是数据。这样会导致发送的数据回显在浏览器的地址栏上。（get请求在“请求行”上发送数据） - http://localhost:8080/servlet05/getServlet?username=zhangsan&amp;userpwd=1111 - post请求发送数据的时候，在请求体当中发送。不会回显到浏览器的地址栏上。也就是说post发送的数据，在浏览器地址栏上看不到。（post在“请求体”当中发送数据） - get请求只能发送普通的字符串。并且发送的字符串长度有限制，不同的浏览器限制不同。这个没有明确的规范。 - get请求无法发送大数据量。 - post请求可以发送任何类型的数据，包括普通字符串，流媒体等信息：视频、声音、图片。 - post请求可以发送大数据量，理论上没有长度限制。 - get请求在W3C中是这样说的：get请求比较==适合从服务器端获取数据==。 - post请求在W3C中是这样说的：post请求比较==适合向服务器端传送数据。== - get请求是安全的。get请求是绝对安全的。为什么？因为get请求只是为了从服务器上获取数据。不会对服务器造成威胁。（get本身是安全的，你不要用错了。用错了之后又冤枉人家get不安全，你这样不好（太坏了），那是你自己的问题，不是get请求的问题。） - post请求是危险的。为什么？因为post请求是向服务器提交数据，如果这些数据通过后门的方式进入到服务器当中，服务器是很危险的。另外post是为了提交数据，所以一般情况下拦截请求的时候，大部分会选择拦截（监听）post请求。 - **get请求支持缓存。** - eg:https://n.sinaimg.cn/finance/590/w240h350/20211101/b40c-b425eb67cabc342ff5b9dc018b4b00cc.jpg - ==任何一个get请求最终的“响应结果”都会被浏览器缓存起来。在浏览器缓存当中：== - 一个get请求的路径a 对应 一个资源。 - 一个get请求的路径b 对应 一个资源。 - 一个get请求的路径c 对应 一个资源。 - ...... - 实际上，你只要发送get请求，浏览器做的第一件事都是先从本地浏览器缓存中找，找不到的时候才会去服务器上获取。这种缓存机制目的是为了提高用户的体验。 - ==**一个需求**== 解决浏览器缓存的问题 - 有没有这样一个需求：我们不希望get请求走缓存，怎么办？怎么避免走缓存？我希望每一次这个get请求都去服务器上找资源，我不想从本地浏览器的缓存中取。 - 只要每一次get请求的请求路径不同即可。 - https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897898 - https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897899 - https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=系统毫秒数 - 怎么解决？可以在路径的后面==添加==一个每时每刻都在变化的“==时间戳==”，这样，每一次的请求路径都不一样，浏览器就不走缓存了。 - post请求==不支持缓存==。（POST是用来修改服务器端的资源的。） - post请求之后，服务器“响应的结果”不会被浏览器缓存起来。因为这个缓存没有意义。- GET请求和POST请求如何选择，什么时候使用GET请求，什么时候使用POST请求？ - 怎么选择GET请求和POST请求呢？衡量标准是什么呢？你这个请求是想获取服务器端的数据，还是想向服务器发送数据。如果你是想从服务器上获取资源，建议使用GET请求，如果你这个请求是为了向服务器提交数据，建议使用POST请求。 - 大部分的form表单提交，都是post方式，因为form表单中要填写大量的数据，这些数据是收集用户的信息，一般是需要传给服务器，服务器将这些数据保存/修改等。 - 如果表单中有敏感信息，还是建议适用post请求，因为get请求会回显敏感信息到浏览器地址栏上。（例如：密码信息） - 做文件上传，一定是post请求。要传的数据不是普通文本。 - 其他情况都可以使用get请求。- 不管你是get请求还是post请求，发送的请求数据格式是完全相同的，只不过位置不同，格式都是统一的： - name=value&amp;name=value&amp;name=value&amp;name=value - name是什么？ - 以form表单为例：form表单中input标签的name。 - value是什么？ - 以form表单为例：form表单中input标签的value。## 模板方法设计模式- 什么是设计模式？ - 某个问题的固定的解决方案。(可以被重复使用。)- 你知道哪些设计模式？ - GoF设计模式： - 通常我们所说的23种设计模式。（Gang of Four：4人组提出的设计模式） - 单例模式 - 工厂模式 - 代理模式 - 门面模式 - 责任链设计模式 - 观察者模式 - 模板方法设计模式 - ..... - JavaEE设计模式： - DAO - DTO - VO - PO - pojo - .... - ....- 什么是模板方法设计模式？ - 在模板类的模板方法当中定义核心算法骨架，具体的实现步骤可以延迟到子类当中完成。- 模板类通常是一个抽象类，模板类当中的模板方法定义核心算法，这个方法通常是final的（但也可以不是final的）- 模板类当中的抽象方法就是不确定实现的方法，这个不确定怎么实现的事儿交给子类去做。## HttpServlet源码分析- HttpServlet类是专门为HTTP协议准备的。比GenericServlet更加适合HTTP协议下的开发。- HttpServlet在哪个包下？ - jakarta.servlet.http.HttpServlet（不同的servlet api 包名不同）- 到目前为止我们接触了servlet规范中哪些接口？ - jakarta.servlet.Servlet 核心接口（接口） - jakarta.servlet.ServletConfig Servlet配置信息接口（接口） - jakarta.servlet.ServletContext Servlet上下文接口（接口）----&gt;xml文件 - jakarta.servlet.ServletRequest Servlet请求接口（接口） - jakarta.servlet.ServletResponse Servlet响应接口（接口） - jakarta.servlet.ServletException Servlet异常（类） - jakarta.servlet.GenericServlet 标准通用的Servlet类（抽象类）- http包下都有哪些类和接口呢？jakarta.servlet.http.*; - jakarta.servlet.http.HttpServlet （HTTP协议专用的Servlet类，抽象类） - jakarta.servlet.http.HttpServletRequest （HTTP协议专用的请求对象） - jakarta.servlet.http.HttpServletResponse （HTTP协议专用的响应对象）- HttpServletRequest对象中封装了什么信息？ - HttpServletRequest，简称request对象。 - HttpServletRequest中封装了请求协议的全部内容。 - Tomcat服务器（WEB服务器）将“请求协议”中的数据全部解析出来，然后将这些数据全部封装到request对象当中了。 - 即把请求行、请求头、请求体等这些数据进行封装。 - 也就是说，我们只要面向HttpServletRequest，就可以获取请求协议中的数据。- HttpServletResponse对象是专门用来响应HTTP协议到浏览器的。- 回忆Servlet生命周期？ - 用户第一次请求 - Tomcat服务器通过反射机制，调用无参数构造方法。创建Servlet对象。(web.xml文件中配置的Servlet类对应的对象。) - Tomcat服务器调用Servlet对象的init方法完成初始化。 - Tomcat服务器调用Servlet对象的service方法处理请求。 - 用户第二次请求 - Tomcat服务器调用Servlet对象的service方法处理请求。 - 用户第三次请求 - Tomcat服务器调用Servlet对象的service方法处理请求。 - .... - Tomcat服务器调用Servlet对象的service方法处理请求。 - 服务器关闭 - Tomcat服务器调用Servlet对象的destroy方法，做销毁之前的准备工作。 - Tomcat服务器销毁Servlet对象。- HttpServlet源码分析：```javapublic class HelloServlet extends HttpServlet &#123; // 用户第一次请求，创建HelloServlet对象的时候，会执行这个无参数构造方法。 public HelloServlet() &#123; &#125; //override 重写 doGet方法 //override 重写 doPost方法&#125;public abstract class GenericServlet implements Servlet, ServletConfig, java.io.Serializable &#123; // 用户第一次请求的时候，HelloServlet对象第一次被创建之后，这个init方法会执行。 public void init(ServletConfig config) throws ServletException &#123; this.config = config; this.init(); &#125; // 用户第一次请求的时候，带有参数的init(ServletConfig config)执行之后，会执行这个没有参数的init() public void init() throws ServletException &#123; // NOOP by default &#125;&#125;// HttpServlet模板类。public abstract class HttpServlet extends GenericServlet &#123; // 用户发送第一次请求的时候这个service会执行 // 用户发送第N次请求的时候，这个service方法还是会执行。 // 用户只要发送一次请求，这个service方法就会执行一次。 @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request; HttpServletResponse response; try &#123; // 将ServletRequest和ServletResponse向下转型为带有Http的HttpServletRequest和HttpServletResponse request = (HttpServletRequest) req; response = (HttpServletResponse) res; &#125; catch (ClassCastException e) &#123; throw new ServletException(lStrings.getString(&quot;http.non_http&quot;)); &#125; // 调用重载的service方法。 service(request, response); &#125; // 这个service方法的两个参数都是带有Http的。 // 这个service是一个模板方法。 // 在该方法中定义核心算法骨架，具体的实现步骤延迟到子类中去完成。 protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取请求方式 // 这个请求方式最终可能是：&quot;&quot; // 注意：request.getMethod()方法获取的是请求方式，可能是七种之一： // GET POST PUT DELETE HEAD OPTIONS TRACE String method = req.getMethod(); // 如果请求方式是GET请求，则执行doGet方法。 if (method.equals(METHOD_GET)) &#123; long lastModified = getLastModified(req); if (lastModified == -1) &#123; // servlet doesn&#x27;t support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); &#125; else &#123; long ifModifiedSince; try &#123; ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); &#125; catch (IllegalArgumentException iae) &#123; // Invalid date header - proceed as if none was set ifModifiedSince = -1; &#125; if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) &#123; // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125; &#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); &#125; else if (method.equals(METHOD_POST)) &#123; // 如果请求方式是POST请求，则执行doPost方法。 doPost(req, resp); &#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp); &#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp); &#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp); &#125; else &#123; // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); &#125; &#125; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; // 报405错误 String msg = lStrings.getString(&quot;http.method_get_not_supported&quot;); sendMethodNotAllowed(req, resp, msg); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 报405错误 String msg = lStrings.getString(&quot;http.method_post_not_supported&quot;); sendMethodNotAllowed(req, resp, msg); &#125; &#125;/*通过以上源代码分析： 假设前端发送的请求是get请求，后端程序员重写的方法是doPost 假设前端发送的请求是post请求，后端程序员重写的方法是doGet 会发生什么呢？ 发生405这样的一个错误。 405表示前端的错误，发送的请求方式不对。和服务器不一致。不是服务器需要的请求方式。 通过以上源代码可以知道：只要HttpServlet类中的doGet方法或doPost方法执行了，必然405.怎么避免405的错误呢？ 后端重写了doGet方法，前端一定要发get请求。 后端重写了doPost方法，前端一定要发post请求。 这样可以避免405错误。 这种前端到底需要发什么样的请求，其实应该后端说了算。后端让发什么方式，前端就得发什么方式。 有的人，你会看到为了避免405错误，在Servlet类当中，将doGet和doPost方法都进行了重写。这样，确实可以避免405的发生，但是不建议，405错误还是有用的。该报错的时候就应该让他报错。如果你要是同时重写了doGet和doPost，那还不如你直接重写service方法好了。这样代码还能少写一点。*/ 我们编写的HelloServlet直接继承HttpServlet，直接重写HttpServlet类中的service()方法行吗？ 可以，只不过你享受不到405错误。享受不到HTTP协议专属的东西。 到今天我们终于得到了最终的一个Servlet类的开发步骤： 第一步：编写一个Servlet类，直接继承HttpServlet 第二步：重写doGet方法或者重写doPost方法，到底重写谁，javaweb程序员说了算。 第三步：将Servlet类配置到web.xml文件当中。 第四步：准备前端的页面（form表单），form表单中指定请求路径即可。 关于一个web站点的欢迎页面 什么是一个web站点的欢迎页面？ 对于一个webapp来说，我们是可以设置它的欢迎页面的。 设置了欢迎页面之后，当你访问这个webapp的时候，或者访问这个web站点的时候，没有指定任何“资源路径”，这个时候会默认访问你的欢迎页面。 我们一般的访问方式是： http://localhost:8080/servlet06/login.html 这种方式是指定了要访问的就是login.html资源。 如果我们访问的方式是： http://localhost:8080/servlet06 如果我们访问的就是这个站点，没有指定具体的资源路径。它默认会访问谁呢？ 默认会访问你设置的欢迎页面。 怎么设置欢迎页面呢？ 第一步：我在IDEA工具的web目录下新建了一个文件login.html 第二步：在web.xml文件中进行了以下的配置 &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 123456789101112131415161718192021 - 注意：设置欢迎页面的时候，这个路径不需要以“/”开始。并且这个路径默认是从webapp的根下开始查找。 - 第三步：启动服务器，浏览器地址栏输入地址 - http://localhost:8080/servlet07- 如果在webapp的根下新建一个目录，目录中再给一个文件，那么这个欢迎页该如何设置呢？ - 在webapp根下新建page1 - 在page1下新建page2目录 - 在page2目录下新建page.html页面 - 在web.xml文件中应该这样配置 - ``` &lt;welcome-file-list&gt; &lt;welcome-file&gt;page1/page2/page.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 注意：路径不需要以“&#x2F;”开始，并且路径默认从webapp的根下开始找。 一个webapp是可以设置多个欢迎页面的 &#96;&#96;&#96;xml page1/page2/page.html login.html 12345678910111213141516171819 - 注意：越靠上的优先级越高。找不到的继续向下找。- 你有没有注意一件事：当我的文件名设置为index.html的时候，不需要在web.xml文件中进行配置欢迎页面。这是为什么？ - 这是因为小猫咪Tomcat服务器已经提前配置好了。 - 实际上配置欢迎页面有两个地方可以配置： - 一个是在webapp内部的web.xml文件中。（在这个地方配置的属于局部配置） - 一个是在CATALINA_HOME/conf/web.xml文件中进行配置。（在这个地方配置的属于全局配置） - ```xml &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; Tomcat服务器的全局欢迎页面是：index.html index.htm index.jsp。如果你一个web站点没有设置局部的欢迎页面，Tomcat服务器就会以index.html index.htm index.jsp作为一个web站点的欢迎页面。 注意原则：局部优先原则。（就近原则） 欢迎页可以是一个Servlet吗？ 当然可以。 你不要多想，欢迎页就是一个资源，既然是一个资源，那么可以是静态资源，也可以是动态资源。 静态资源：index.html welcome.html ….. 动态资源：Servlet类。 步骤： 第一步：写一个Servlet &#96;&#96;&#96;javapublic class WelcomeServlet extends HttpServlet {@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(“text&#x2F;html”); PrintWriter out &#x3D; response.getWriter(); out.print(“welcome to bjpowernode!“);}}1234567891011121314 - 第二步：在web.xml文件中配置servlet - ```xml &lt;servlet&gt; &lt;servlet-name&gt;welcomeServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjpowernode.javaweb.servlet.WelcomeServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;welcomeServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/fdsa/fds/a/fds/af/ds/af/dsafdsafdsa&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 第三步：在web.xml文件中配置欢迎页 &#96;&#96;&#96;xml fdsa&#x2F;fds&#x2F;a&#x2F;fds&#x2F;af&#x2F;ds&#x2F;af&#x2F;dsafdsafdsa12345678910111213141516171819 ## 关于WEB-INF目录- 在WEB-INF目录下新建了一个文件：welcome.html- 打开浏览器访问：http://localhost:8080/servlet07/WEB-INF/welcome.html 出现了404错误。- 注意：放在WEB-INF目录下的资源是受保护的。在浏览器上不能够通过路径直接访问。所以像HTML、CSS、JS、image等静态资源一定要放到WEB-INF目录之外。## HttpServletRequest接口详解- HttpServletRequest是一个接口，全限定名称：jakarta.servlet.http.HttpServletRequest- HttpServletRequest接口是Servlet规范中的一员。- HttpServletRequest接口的父接口：ServletRequest - ```java public interface HttpServletRequest extends ServletRequest &#123;&#125; HttpServletRequest接口的实现类谁写的? HttpServletRequest对象是谁给创建的？ 通过测试：org.apache.catalina.connector.RequestFacade 实现了 HttpServletRequest接口 public class RequestFacade implements HttpServletRequest &#123;&#125; 1234567891011121314151617181920212223242526 - 测试结果说明：Tomcat服务器（WEB服务器、WEB容器）实现了HttpServletRequest接口，还是说明了Tomcat服务器实现了Servlet规范。而对于我们javaweb程序员来说，实际上不需要关心这个，我们只需要面向接口编程即可。我们关心的是HttpServletRequest接口中有哪些方法，这些方法可以完成什么功能！！！！- HttpServletRequest对象中都有什么信息？都包装了什么信息？ - HttpServletRequest对象是Tomcat服务器负责创建的。这个对象中封装了什么信息？封装了==HTTP的请求协议。== - 实际上是用户发送请求的时候，遵循了HTTP协议，发送的是HTTP的请求协议，Tomcat服务器将HTTP协议中的信息以及数据全部解析出来，然后Tomcat服务器把这些信息封装到HttpServletRequest对象当中，传给了我们javaweb程序员。 - javaweb程序员面向HttpServletRequest接口编程，调用方法就可以获取到请求的信息了。- request和response对象的生命周期？ - request对象和response对象，一个是请求对象，一个是响应对象。这两个对象只在当前请求中有效。 - 一次请求对应一个request。 - 两次请求则对应两个request。 - .....- HttpServletRequest接口中有哪些常用的方法？ - 怎么获取前端浏览器用户提交的数据？ - ```java Map&lt;String,String[]&gt; getParameterMap() 这个是获取Map Enumeration&lt;String&gt; getParameterNames() 这个是获取Map集合中所有的key String[] getParameterValues(String name) 根据key获取Map集合的value ===》多选框 String getParameter(String name) 获取value这个一维数组当中的第一个元素。这个方法最常用。 // 以上的4个方法，和获取用户提交的数据有关系。 思考：如果是你，前端的form表单提交了数据之后，你准备怎么存储这些数据，你准备采用什么样的数据结构去存储这些数据呢？ 前端提交的数据格式：username&#x3D;abc&amp;userpwd&#x3D;111&amp;aihao&#x3D;s&amp;aihao&#x3D;d&amp;aihao&#x3D;tt 我会采用Map集合来存储： &#96;&#96;&#96;javaMap&lt;String,String&gt;key存储Stringvalue存储String这种想法对吗？不对。如果采用以上的数据结构存储会发现key重复的时候value覆盖。&#x3D;&#x3D;map中不会存在相同的key&#x3D;&#x3D;key value———————username abcuserpwd 111aihao saihao daihao tt这样是不行的，因为map的key不能重复。Map&lt;String, String[]&gt;key存储Stringvalue存储String[]key value——————————-username {“abc”}userpwd {“111”}aihao {“s”,”d”,”tt”}123456789101112 - 注意：前端表单提交数据的时候，假设提交了120这样的“数字”，其实是以字符串&quot;120&quot;的方式提交的，所以服务器端获取到的一定是一个字符串的&quot;120&quot;，而不是一个数字。（前端永远提交的是字符串，后端获取的也永远是字符串。） - 手工开发一个webapp。测试HttpServletRequest接口中的相关方法。 - 先测试了4个常用的方法，获取请求参数的四个方法。 - ```java Map&lt;String,String[]&gt; parameterMap = request.getParameterMap(); Enumeration&lt;String&gt; names = request.getParameterNames(); String[] values = request.getParameterValues(&quot;name&quot;); ==== String value = request.getParameter(&quot;name&quot;); request对象实际上又称为“请求域”对象。 应用域对象是什么？ ServletContext （Servlet上下文对象。） 什么情况下会考虑向ServletContext这个应用域当中绑定数据呢？ 第一：所有用户共享的数据。 第二：这个共享的数据量很小。 第三：这个共享的数据很少的修改操作。 在以上三个条件都满足的情况下，使用这个应用域对象，可以大大提高我们程序执行效率。 实际上向应用域当中绑定数据，就相当于把数据放到了缓存（Cache）当中，然后用户访问的时候直接从缓存中取，减少IO的操作，大大提升系统的性能，所以缓存技术是提高系统性能的重要手段。 你见过哪些缓存技术呢？ 字符串常量池 整数型常量池 [-128~127]，但凡是在这个范围当中的Integer对象不再创建新对象，直接从这个整数型常量池中获取。大大提升系统性能。 数据库连接池（提前创建好N个连接对象，将连接对象放到集合当中，使用连接对象的时候，直接从缓存中拿。省去了连接对象的创建过程。效率提升。） 线程池（Tomcat服务器就是支持多线程的。所谓的线程池就是提前先创建好N个线程对象，将线程对象存储到集合中，然后用户请求过来之后，直接从线程池中获取线程对象，直接拿来用。提升系统性能） 后期你还会学习更多的缓存技术，例如：redis、mongoDB….. ServletContext当中有三个操作域的方法： &#96;&#96;&#96;javavoid setAttribute(String name, Object obj); &#x2F;&#x2F; 向域当中绑定数据。Object getAttribute(String name); &#x2F;&#x2F; 从域当中根据name获取数据。void removeAttribute(String name); &#x2F;&#x2F; 将域当中绑定的数据移除 &#x2F;&#x2F; 以上的操作类似于Map集合的操作。Map&lt;String, Object&gt; map;map.put(“name”, obj); &#x2F;&#x2F; 向map集合中放key和valueObject obj &#x3D; map.get(“name”); &#x2F;&#x2F; 通过map集合的key获取valuemap.remove(“name”); &#x2F;&#x2F; 通过Map集合的key删除key和value这个键值对。 123456789101112131415 - “请求域”对象 - “请求域”对象要比“应用域”对象范围小很多。生命周期短很多。请求域只在一次请求内有效。 - 一个请求对象request对应一个请求域对象。一次请求结束之后，这个请求域就销毁了。 - 一个请求对象对应一个请求 - 请求域对象也有这三个方法： - ```java void setAttribute(String name, Object obj); // 向域当中绑定数据。 Object getAttribute(String name); // 从域当中根据name获取数据。 void removeAttribute(String name); // 将域当中绑定的数据移除 请求域和应用域的选用原则？ 尽量使用小的域对象，因为小的域对象占用的资源较少。 跳转 转发（一次请求） &#96;&#96;&#96;java&#x2F;&#x2F; 第一步：获取请求转发器对象RequestDispatcher dispatcher &#x3D; request.getRequestDispatcher(“&#x2F;b”);&#x2F;&#x2F; 第二步：调用转发器的forward方法完成跳转&#x2F;转发dispatcher.forward(request,response); &#x2F;&#x2F; 第一步和第二步代码可以联合在一起。request.getRequestDispatcher(“&#x2F;b”).forward(request,response); 123456789101112131415161718192021222324- 两个Servlet怎么共享数据？ - 将数据放到ServletContext应用域当中，当然是可以的，但是应用域范围太大，占用资源太多。不建议使用。 - 可以将数据放到request域当中，然后AServlet转发到BServlet，保证AServlet和BServlet在同一次请求当中，这样就可以做到两个Servlet，或者多个Servlet共享同一份数据。- 转发的下一个资源必须是一个Servlet吗？ - 不一定，只要是Tomcat服务器当中的合法资源，都是可以转发的。例如：html.... - 注意：转发的时候，路径的写法要注意，转发的路径以“/”开始，不加项目名。- 关于request对象中两个非常容易混淆的方法： - ```java // uri?username=zhangsan&amp;userpwd=123&amp;sex=1 String username = request.getParameter(&quot;username&quot;); // 之前一定是执行过：request.setAttribute(&quot;name&quot;, new Object()) Object obj = request.getAttribute(&quot;name&quot;); // 以上两个方法的区别是什么？ // 第一个方法：获取的是用户在浏览器上提交的数据。 // 第二个方法：获取的是请求域当中绑定的数据。 HttpServletRequest接口的其他常用方法： &#96;&#96;&#96;java&#x2F;&#x2F; 获取客户端的IP地址String remoteAddr &#x3D; request.getRemoteAddr(); &#x2F;&#x2F; get请求在请求行上提交数据。&#x2F;&#x2F; post请求在请求体中提交数据。&#x2F;&#x2F; 设置请求体的字符集。（显然这个方法是处理POST请求的乱码问题。这种方式并不能解决get请求的乱码问题。）&#x2F;&#x2F; Tomcat10之后，request请求体当中的字符集默认就是UTF-8，不需要设置字符集，不会出现乱码问题。&#x2F;&#x2F; Tomcat9前（包括9在内），如果前端请求体提交的是中文，后端获取之后出现乱码，怎么解决这个乱码？执行以下代码。request.setCharacterEncoding(“UTF-8”); &#x2F;&#x2F; 在Tomcat9之前（包括9），响应中文也是有乱码的，怎么解决这个响应的乱码？response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”);&#x2F;&#x2F; 在Tomcat10之后，包括10在内，响应中文的时候就不在出现乱码问题了。以上代码就不需要设置UTF-8了。 &#x2F;&#x2F; 注意一个细节&#x2F;&#x2F; 在Tomcat10包括10在内之后的版本，中文将不再出现乱码。（这也体现了中文地位的提升。） &#x2F;&#x2F; get请求乱码问题怎么解决？&#x2F;&#x2F; get请求发送的时候，数据是在请求行上提交的，不是在请求体当中提交的。&#x2F;&#x2F; get请求乱码怎么解决&#x2F;&#x2F; 方案：修改CATALINA_HOME&#x2F;conf&#x2F;server.xml配置文件 // 注意：从Tomcat8之后，URIEncoding的默认值就是UTF-8，所以GET请求也没有乱码问题了。 &#x2F;&#x2F; 获取应用的根路径String contextPath &#x3D; request.getContextPath(); &#x2F;&#x2F; 获取请求方式String method &#x3D; request.getMethod(); &#x2F;&#x2F; 获取请求的URIString uri &#x3D; request.getRequestURI(); &#x2F;&#x2F; &#x2F;aaa&#x2F;testRequest &#x2F;&#x2F; 获取servlet pathString servletPath &#x3D; request.getServletPath(); &#x2F;&#x2F; &#x2F;testRequest 1234567891011121314151617181920212223## 使用纯Servlet做一个单表的CRUD操作- 使用纯粹的Servlet完成单表【对部门的】的增删改查操作。（B/S结构的。）- 实现步骤 - 第一步：准备一张数据库表。（sql脚本） - ```sql # 部门表 drop table if exists dept; create table dept( deptno int primary key, dname varchar(255), loc varchar(255) ); insert into dept(deptno, dname, loc) values(10, &#x27;XiaoShouBu&#x27;, &#x27;BEIJING&#x27;); insert into dept(deptno, dname, loc) values(20, &#x27;YanFaBu&#x27;, &#x27;SHANGHAI&#x27;); insert into dept(deptno, dname, loc) values(30, &#x27;JiShuBu&#x27;, &#x27;GUANGZHOU&#x27;); insert into dept(deptno, dname, loc) values(40, &#x27;MeiTiBu&#x27;, &#x27;SHENZHEN&#x27;); commit; select * from dept; 第二步：准备一套HTML页面（项目原型）【前端开发工具使用HBuilder】 把HTML页面准备好 然后将HTML页面中的链接都能够跑通。（页面流转没问题。） 应该设计哪些页面呢？ 欢迎页面：index.html 列表页面：list.html（以列表页面为核心，展开其他操作。） 新增页面：add.html 修改页面：edit.html 详情页面：detail.html 第三步：分析我们这个系统包括哪些功能？ 什么叫做一个功能呢？ 只要 这个操作连接了数据库，就表示一个独立的功能。 包括哪些功能？ 查看部门列表 新增部门 删除部门 查看部门详细信息 跳转到修改页面 修改部门 第四步：在IDEA当中搭建开发环境 创建一个webapp（给这个webapp添加servlet-api.jar和jsp-api.jar到classpath当中。） 向webapp中添加连接数据库的jar包（mysql驱动） 必须在WEB-INF目录下新建lib目录，然后将mysql的驱动jar包拷贝到这个lib目录下。这个目录名必须叫做lib，全部小写的。 JDBC的工具类 将所有HTML页面拷贝到web目录下。 第五步：实现第一个功能：查看部门列表 我们应该怎么去实现一个功能呢？ 建议：你可以从后端往前端一步一步写。也可以从前端一步一步往后端写。都可以。但是千万要记住不要想起来什么写什么。你写代码的过程最好是程序的执行过程。也就是说：程序执行到哪里，你就写哪里。这样一个顺序流下来之后，基本上不会出现什么错误、意外。 从哪里开始？ 假设从前端开始，那么一定是从用户点击按钮那里开始的。 第一：先修改前端页面的超链接，因为用户先点击的就是这个超链接。 &#96;&#96;&#96;html查看部门列表12345678910111213- 第二：编写web.xml文件 - ```xml &lt;servlet&gt; &lt;servlet-name&gt;list&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjpowernode.oa.web.action.DeptListServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;list&lt;/servlet-name&gt; &lt;!--web.xml文件中的这个路径也是以“/”开始的，但是不需要加项目名--&gt; &lt;url-pattern&gt;/dept/list&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 第三：编写DeptListServlet类继承HttpServlet类。然后重写doGet方法。 &#96;&#96;&#96;javapackage com.bjpowernode.oa.web.action; import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse; import java.io.IOException; public class DeptListServlet extends HttpServlet {@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {}} 1234567891011121314151617181920212223242526- 第四：在DeptListServlet类的doGet方法中连接数据库，查询所有的部门，动态的展示部门列表页面. - 分析list.html页面中哪部分是固定死的，哪部分是需要动态展示的。 - list.html页面中的内容所有的双引号要替换成单引号，因为out.print(&quot;&quot;)这里有一个双引号，容易冲突。 - 现在写完这个功能之后，你会有一种感觉，感觉开发很繁琐，只使用servlet写代码太繁琐了。 - ```java while(rs.next())&#123; String deptno = rs.getString(&quot;a&quot;); String dname = rs.getString(&quot;dname&quot;); String loc = rs.getString(&quot;loc&quot;); out.print(&quot; &lt;tr&gt;&quot;); out.print(&quot; &lt;td&gt;&quot;+(++i)+&quot;&lt;/td&gt;&quot;); out.print(&quot; &lt;td&gt;&quot;+deptno+&quot;&lt;/td&gt;&quot;); out.print(&quot; &lt;td&gt;&quot;+dname+&quot;&lt;/td&gt;&quot;); out.print(&quot; &lt;td&gt;&quot;); out.print(&quot; &lt;a href=&#x27;&#x27;&gt;删除&lt;/a&gt;&quot;); out.print(&quot; &lt;a href=&#x27;edit.html&#x27;&gt;修改&lt;/a&gt;&quot;); out.print(&quot; &lt;a href=&#x27;detail.html&#x27;&gt;详情&lt;/a&gt;&quot;); out.print(&quot; &lt;/td&gt;&quot;); out.print(&quot; &lt;/tr&gt;&quot;); &#125; 第六步：查看部门详情。 建议：从前端往后端一步一步实现。首先要考虑的是，用户点击的是什么？用户点击的东西在哪里？ 一定要先找到用户点的“详情”在哪里。找了半天，终于在后端的java程序中找到了 &lt;a href=&#39;写一个路径&#39;&gt;详情&lt;/a&gt; 123456789 - 详情 是需要连接数据库的，所以这个超链接点击之后也是需要执行一段java代码的。所以要将这个超链接的路径修改一下。 - 注意：修改路径之后，这个路径是需要加项目名的。&quot;/oa/dept/detail&quot;- 技巧： - ```java out.print(&quot;&lt;a href=&#x27;&quot;+contextPath+&quot;/dept/detail?deptno=&quot;+deptno+&quot;&#x27;&gt;详情&lt;/a&gt;&quot;); 重点：向服务器提交数据的格式：uri?name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value&amp;name&#x3D;value 这里的问号，必须是英文的问号。不能中文的问号。 解决404的问题。写web.xml文件。 &#96;&#96;&#96;xml detail com.bjpowernode.oa.web.action.DeptDetailServlet detail /dept/detail 1234567891011121314151617181920212223- 编写一个类：DeptDetailServlet继承HttpServlet，重写doGet方法。 - ```java package com.bjpowernode.oa.web.action; import jakarta.servlet.ServletException; import jakarta.servlet.http.HttpServlet; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import java.io.IOException; public class DeptDetailServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //中文思路（思路来源于：你要做什么？目标：查看部门详细信息。） // 第一步：获取部门编号 // 第二步：根据部门编号查询数据库，获取该部门编号对应的部门信息。 // 第三步：将部门信息响应到浏览器上。（显示一个详情。） &#125; &#125; 在doGet方法当中：连接数据库，根据部门编号查询该部门的信息。动态展示部门详情页。 第七步：删除部门 怎么开始？从哪里开始？从前端页面开始，用户点击删除按钮的时候，应该提示用户是否删除。因为删除这个动作是比较危险的。任何系统在进行删除操作之前，是必须要提示用户的，因为这个删除的动作有可能是用户误操作。（在前端页面上写JS代码，来提示用户是否删除。） &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;del(30)&quot; &gt;删除&lt;/a&gt; &lt;script type=&quot;text/javascript&quot;&gt; function del(dno)&#123; if(window.confirm(&quot;亲，删了不可恢复哦！&quot;))&#123; document.location.href = &quot;/oa/dept/delete?deptno=&quot; + dno; &#125; &#125; &lt;/script&gt; 1234567891011121314151617181920 - 以上的前端程序要写到后端的java代码当中： - DeptListServlet类的doGet方法当中，使用out.print()方法，将以上的前端代码输出到浏览器上。 - 解决404的问题： - http://localhost:8080/oa/dept/delete?deptno=30 - web.xml文件 - ```xml &lt;servlet&gt; &lt;servlet-name&gt;delete&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjpowernode.oa.web.action.DeptDelServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;delete&lt;/servlet-name&gt; &lt;url-pattern&gt;/dept/delete&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 编写DeptDelServlet继承HttpServlet，重写doGet方法。 &#96;&#96;&#96;javapackage com.bjpowernode.oa.web.action; import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse; import java.io.IOException; public class DeptDelServlet extends HttpServlet {@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 根据部门编号，删除部门。}} 1234567891011121314 - 删除成功或者失败的时候的一个处理（这里我们选择了转发，并没有使用重定向机制。） - ```java // 判断删除成功了还是失败了。 if (count == 1) &#123; //删除成功 //仍然跳转到部门列表页面 //部门列表页面的显示需要执行另一个Servlet。怎么办？转发。 request.getRequestDispatcher(&quot;/dept/list&quot;).forward(request, response); &#125;else&#123; // 删除失败 request.getRequestDispatcher(&quot;/error.html&quot;).forward(request, response); &#125; 第八步：新增部门 注意：最后保存成功之后，转发到 &#x2F;dept&#x2F;list 的时候，会出现405，为什么？ 第一：保存用的是post请求。底层要执行doPost方法。 第二：转发是一次请求，之前是post，之后还是post，因为它是一次请求。 第三：&#x2F;dept&#x2F;list Servlet当中只有一个doGet方法。 怎么解决？两种方案 第一种：在&#x2F;dept&#x2F;list Servlet中添加doPost方法，然后在doPost方法中调用doGet。 第二种：重定向。 第九步：跳转到修改部门的页面 第十步：修改部门 在一个web应用中应该如何完成资源的跳转 在一个web应用中通过两种方式，可以完成资源的跳转： 第一种方式：转发 第二种方式：重定向 转发和重定向有什么区别？ 代码上有什么区别？ 转发 &#96;&#96;&#96;java&#x2F;&#x2F; 获取请求转发器对象RequestDispatcher dispatcher &#x3D; request.getRequestDispatcher(“&#x2F;dept&#x2F;list”);&#x2F;&#x2F; 调用请求转发器对象的forward方法完成转发dispatcher.forward(request, response); &#x2F;&#x2F; 合并一行代码request.getRequestDispatcher(“&#x2F;dept&#x2F;list”).forward(request, response);&#x2F;&#x2F; 转发的时候是一次请求，不管你转发了多少次。都是一次请求。&#x2F;&#x2F; AServlet转发到BServlet，再转发到CServlet，再转发到DServlet，不管转发了多少次，都在同一个request当中。&#x2F;&#x2F; 这是因为调用forward方法的时候，会将当前的request和response对象传递给下一个Servlet。 123456789- 重定向 - ```java // 注意：路径上要加一个项目名。为什么？ // 浏览器发送请求，请求路径上是需要添加项目名的。 // 以下这一行代码会将请求路径“/oa/dept/list”发送给浏览器 // 浏览器会自发的向服务器发送一次全新的请求：/oa/dept/list response.sendRedirect(&quot;/oa/dept/list&quot;); 形式上有什么区别？ 转发（一次请求） 在浏览器地址栏上发送的请求是：http://localhost:8080/servlet10/a ，最终请求结束之后，浏览器地址栏上的地址还是这个。没变。 重定向（两次请求） 在浏览器地址栏上发送的请求是：http://localhost:8080/servlet10/a ，最终在浏览器地址栏上显示的地址是：http://localhost:8080/servlet10/b 转发和重定向的本质区别？ 转发：是由WEB服务器来控制的。A资源跳转到B资源，这个跳转动作是Tomcat服务器内部完成的。 重定向：是浏览器完成的。具体跳转到哪个资源，是浏览器说了算。 使用一个例子去描述这个转发和重定向 借钱（转发：发送了一次请求） 杜老师没钱了，找张三借钱，其实张三没有钱，但是张三够义气，张三自己找李四借了钱，然后张三把这个钱给了杜老师，杜老师不知道这个钱是李四的，杜老师只求了一个人。杜老师以为这个钱就是张三的。 借钱（重定向：发送了两次请求） 杜老师没钱了，找张三借钱，张三没有钱，张三有一个好哥们，叫李四，李四是个富二代，于是张三将李四的家庭住址告诉了杜老师，杜老师按照这个地址去找到李四，然后从李四那里借了钱。显然杜老师在这个过程中，求了两个人。并且杜老师知道最终这个钱是李四借给俺的。 转发和重定向应该如何选择？什么时候使用转发，什么时候使用重定向？ 如果在上一个Servlet当中向request域当中绑定了数据，希望从下一个Servlet当中把request域里面的数据取出来，使用转发机制。 剩下所有的请求均使用重定向。（重定向使用较多。） 跳转的下一个资源有没有要求呢？必须是一个Servlet吗？ 不一定，跳转的资源只要是服务器内部合法的资源即可。包括：Servlet、JSP、HTML….. 转发会存在浏览器的刷新问题。 将oa项目中的资源跳转修改为合适的跳转方式 删除之后，重定向 修改之后，重定向 保存之后，重定向 重定向： 成功 失败 Servlet注解，简化配置 分析oa项目中的web.xml文件 现在只是一个单标的CRUD，没有复杂的业务逻辑，很简单的一丢丢功能。web.xml文件中就有如此多的配置信息。如果采用这种方式，对于一个大的项目来说，这样的话web.xml文件会非常庞大，有可能最终会达到几十兆。 在web.xml文件中进行servlet信息的配置，显然开发效率比较低，每一个都需要配置一下。 而且在web.xml文件中的配置是很少被修改的，所以这种配置信息能不能直接写到java类当中呢？可以的。 Servlet3.0版本之后，推出了各种Servlet基于注解式开发。优点是什么？ 开发效率高，不需要编写大量的配置信息。直接在java类上使用注解进行标注。 web.xml文件体积变小了。 并不是说注解有了之后，web.xml文件就不需要了： 有一些需要变化的信息，还是要配置到web.xml文件中。一般都是 注解+配置文件 的开发模式。 一些不会经常变化修改的配置建议使用注解。一些可能会被修改的建议写到配置文件中。 我们的第一个注解： &#96;&#96;&#96;jakarta.servlet.annotation.WebServlet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113 - 在Servlet类上使用：@WebServlet，WebServlet注解中有哪些属性呢？ - name属性：用来指定Servlet的名字。等同于：&lt;servlet-name&gt; - urlPatterns属性：用来指定Servlet的映射路径。可以指定多个字符串。&lt;url-pattern&gt; - loadOnStartUp属性：用来指定在服务器启动阶段是否加载该Servlet。等同于：&lt;load-on-startup&gt; - value属性：当注解的属性名是value的时候，使用注解的时候，value属性名是可以省略的。 - 注意：不是必须将所有属性都写上，只需要提供需要的。（需要什么用什么。） - 注意：属性是一个数组，如果数组中只有一个元素，使用该注解的时候，属性值的大括号可以省略。- 注解对象的使用格式： - @注解名称(属性名=属性值, 属性名=属性值, 属性名=属性值....)## 使用模板方法设计模式优化oa项目- 上面的注解解决了配置文件的问题。但是现在的oa项目仍然存在一个比较臃肿的问题。 - 一个单标的CRUD，就写了6个Servlet。如果一个复杂的业务系统，这种开发方式，显然会导致类爆炸。（类的数量太大。） - 怎么解决这个类爆炸问题？可以使用模板方法设计模式。- 怎么解决类爆炸问题？ - 以前的设计是一个请求一个Servlet类。1000个请求对应1000个Servlet类。导致类爆炸。 - 可以这样做：一个请求对应一个方法。一个业务对应一个Servlet类。 - 处理部门相关业务的对应一个DeptServlet。处理用户相关业务的对应一个UserServlet。处理银行卡卡片业务对应一个CardServlet。## 分析使用纯粹Servlet开发web应用的缺陷- 在Servlet当中编写HTML/CSS/JavaScript等前端代码。存在什么问题？ - java程序中编写前端代码，编写难度大。麻烦。 - java程序中编写前端代码，显然程序的耦合度非常高。 - java程序中编写前端代码，代码非常不美观。 - java程序中编写前端代码，维护成本太高。（非常难于维护） - 修改小小的一个前端代码，只要有改动，就需要重新编译java代码，生成新的class文件，打一个新的war包，重新发布。- 思考一下，如果是你的话，你准备怎么解决这个问题？ - 思路很重要。使用什么样的思路去做、去解决这个问题 - 上面的那个Servlet（Java程序）能不能不写了，让机器自动生成。我们程序员只需要写这个Servlet程序中的“前端的那段代码”，然后让机器将我们写的“前端代码”自动翻译生成“Servlet这种java程序”。然后机器再自动将“java”程序编译生成&quot;class&quot;文件。然后再使用JVM调用这个class中的方法。## 关于B/S结构系统的会话机制（session机制）- 什么是会话？ - 会话对应的英语单词：session - 用户打开浏览器，进行一系列操作，然后最终将浏览器关闭，这个整个过程叫做：一次会话。会话在服务器端也有一个对应的java对象，这个java对象叫做：session。 - 什么是一次请求：用户在浏览器上点击了一下，然后到页面停下来，可以粗略认为是一次请求。请求对应的服务器端的java对象是：request。 - 一个会话当中包含多次请求。（一次会话对应N次请求。） - 在java的servlet规范当中，session对应的类名：HttpSession（jarkata.servlet.http.HttpSession）- session机制属于B/S结构的一部分。如果使用php语言开发WEB项目，同样也是有session这种机制的。session机制实际上是一个规范。然后不同的语言对这种会话机制都有实现。- session对象最主要的作用是：保存会话状态。（用户登录成功了，这是一种登录成功的状态，你怎么把登录成功的状态一直保存下来呢？使用session对象可以保留会话状态。）- 为什么需要session对象来保存会话状态呢？ - 因为HTTP协议是一种无状态协议。 - 什么是无状态：请求的时候，B和S是连接的，但是请求结束之后，连接就断了。为什么要这么做？HTTP协议为什么要设计成这样？因为这样的无状态协议，可以降低服务器的压力。请求的瞬间是连接的，请求结束之后，连接断开，这样服务器压力小。 - 只要B和S断开了，那么关闭浏览器这个动作，服务器知道吗？ - 不知道。服务器是不知道浏览器关闭的。 - 张三打开一个浏览器A，李四打开一个浏览器B，访问服务器之后，在服务器端会生成： - 张三专属的session对象 - 李四专属的session对象 - 为什么不使用request对象保存会话状态？为什么不使用ServletContext对象保存会话状态？ - request.setAttribute()存，request.getAttribute()取，ServletContext也有这个方法。request是请求域。ServletContext是应用域。 - request是一次请求一个对象。 - ServletContext对象是服务器启动的时候创建，服务器关闭的时候销毁，这个ServletContext对象只有一个。 - ServletContext对象的域太大。 - request请求域（HttpServletRequest）、session会话域（HttpSession）、application域（ServletContext） - request &lt; session &lt; application - 思考一下：session对象的实现原理。 - HttpSession session = request.getSession(); - 这行代码很神奇。张三访问的时候获取的session对象就是张三的。李四访问的时候获取的session对象就是李四的。 - ==**session的实现原理：**== - JSESSIONID=xxxxxx 这个是以Cookie的形式保存在==浏览器的内存==中的。浏览器只要关闭。这个cookie就没有了。 - session列表是一个Map，map的key是sessionid，map的value是session对象。 - 用户第一次请求，服务器生成session对象，同时生成id，将id发送给浏览器。 - 用户第二次请求，自动将浏览器内存中的id发送给服务器，服务器根据id查找session对象。 - 关闭浏览器，内存消失，cookie消失，sessionid消失，会话等同于结束。- ==Cookie禁用了，session还能找到吗？==----&gt;面试题 - cookie禁用是什么意思？服务器正常发送cookie给浏览器，但是浏览器不要了。拒收了。并不是服务器不发了。 - 找不到了。每一次请求都会获取到新的session对象。 - cookie禁用了，session机制还能实现吗？----&gt; URL重写机制 - 可以。需要使用URL重写机制。 - http://localhost:8080/servlet12/test/session;jsessionid=19D1C99560DCBF84839FA43D58F56E16 - URL重写机制会提高开发者的成本。开发人员在编写任何请求路径的时候，后面都要添加一个sessionid，给开发带来了很大的难度，很大的成本。所以大部分的网站都是这样设计的：你要是禁用cookie，你就别用了。- 总结一下到目前位置我们所了解的域对象： - request（对应的类名：HttpServletRequest） - 请求域（请求级别的）---&gt; 每次请求都会产生一个新的。 - session（对应的类名：HttpSession） - 会话域（用户级别的） - application（对应的类名：ServletContext） - 应用域（项目级别的，所有用户共享的。） - 这三个域对象的大小关系 - request &lt; session &lt; application - 他们三个域对象都有以下三个公共的方法： - setAttribute（向域当中绑定数据） - getAttribute（从域当中获取数据） - removeAttribute（删除域当中的数据） - 使用原则：尽量使用小的域。尽量小，减少服务器压力。- session掌握之后，我们怎么解决oa项目中的登录问题，怎么能让登录起作用。 - 登录成功之后，可以将用户的登录信息存储到session当中。也就是说session中如果有用户的信息就代表用户登录成功了。session中没有用户信息，表示用户没有登录过。则跳转到登录页面。- 销毁session对象： - ```java session.invalidate(); 1.Session的实现原理 —&gt; 我想要一直拿到想要的篮球。 1.在篮球上做标记（web服务器） 2.在脑子中记忆该标记（浏览器）一次会话: ​ 从 Session 对象的创建到销毁 A1:为什么关闭浏览器，会话会结束？ 关闭浏览器之后，浏览器中保存的 Session 消失，下次重新打开浏览器之后，浏览器缓存中没有这个 seesion Map 表的 sessionid，自然就找逼到服务器中对应的 session 对象， session 找不到就等同于会话结束。 A2：session 对象什么时候被销毁 超时销毁 手动销毁 2.Session 的配置web.xml文件中 123&lt;session-config&gt;&lt;session-timout&gt;xxx（minutes）&lt;/session-timout&gt;&lt;/session-config&gt; ３．Ｓｅｓｓｉｏｎ对象的获取12341.HttpSession session = request.getSession();如果有则返回，没有则创建2.HttpSession session1 = request.getSession(false);有则返回，没有就返回 null Cookie session的实现原理中，每一个session对象都会关联一个sessionid，例如： JSESSIONID&#x3D;41C481F0224664BDB28E95081D23D5B8 以上的这个键值对数据其实就是cookie对象。 对于session关联的cookie来说，这个cookie是被保存在浏览器的“运行内存”当中。 只要浏览器不关闭，用户再次发送请求的时候，会自动将运行内存中的cookie发送给服务器。 例如，这个Cookie: JSESSIONID&#x3D;41C481F0224664BDB28E95081D23D5B8就会再次发送给服务器。 服务器就是根据41C481F0224664BDB28E95081D23D5B8这个值来找到对应的session对象的。 cookie怎么生成？cookie保存在什么地方？cookie有啥用？浏览器什么时候会发送cookie，发送哪些cookie给服务器？？？？？？？ cookie最终是保存在浏览器客户端上的。 可以保存在运行内存中。（浏览器只要关闭cookie就消失了。） 也可以保存在硬盘文件中。（永久保存。） cookie有啥用呢？ cookie和session机制其实都是为了保存会话的状态。 cookie是将会话的状态保存在浏览器客户端上。（cookie数据存储在浏览器客户端上的。） session是将会话的状态保存在服务器端上。（session对象是存储在服务器上。） 为什么要有cookie和session机制呢？因为HTTP协议是无状态 无连接协议。 cookie的经典案例 京东商城，在未登录的情况下，向购物车中放几件商品。然后关闭商城，再次打开浏览器，访问京东商城的时候，购物车中的商品还在，这是怎么做的？我没有登录，为什么购物车中还有商品呢？ 将购物车中的商品编号放到cookie当中，cookie保存在硬盘文件当中。这样即使关闭浏览器。硬盘上的cookie还在。下一次再打开京东商城的时候，查看购物车的时候，会自动读取本地硬盘中存储的cookie，拿到商品编号，动态展示购物车中的商品。 京东存储购物车中商品的cookie可能是这样的：productIds&#x3D;xxxxx,yyyy,zzz,kkkk 注意：cookie如果清除掉，购物车中的商品就消失了。 126邮箱中有一个功能：十天内免登录 这个功能也是需要cookie来实现的。 怎么实现的呢？ 用户输入正确的用户名和密码，并且同时选择十天内免登录。登录成功后。浏览器客户端会保存一个cookie，这个cookie中保存了用户名和密码等信息，这个cookie是保存在硬盘文件当中的，十天有效。在十天内用户再次访问126的时候，浏览器自动提交126的关联的cookie给服务器，服务器接收到cookie之后，获取用户名和密码，验证，通过之后，自动登录成功。 怎么让cookie失效？ 十天过后自动失效。 或者改密码。 或者在客户端浏览器上清除cookie。 cookie机制和session机制其实都不属于java中的机制，实际上cookie机制和session机制都是HTTP协议的一部分。php开发中也有cookie和session机制，只要是你是做web开发，不管是什么编程语言，cookie和session机制都是需要的。 HTTP协议中规定：任何一个cookie都是由name和value组成的。name和value都是字符串类型的。 在java的servlet中，对cookie提供了哪些支持呢？ 提供了一个Cookie类来专门表示cookie数据。jakarta.servlet.http.Cookie; java程序怎么把cookie数据发送给浏览器呢？response.addCookie(cookie); 在HTTP协议中是这样规定的：当浏览器发送请求的时候，会自动携带该path下的cookie数据给服务器。（URL。） 关于cookie的有效时间 怎么用java设置cookie的有效时间 cookie.setMaxAge(60 * 60); 设置cookie在一小时之后失效。 没有设置有效时间：默认保存在浏览器的运行内存中，浏览器关闭则cookie消失。 只要设置cookie的有效时间 &gt; 0，这个cookie一定会存储到硬盘文件当中。 设置cookie的有效时间 &#x3D; 0 呢？ cookie被删除，同名cookie被删除。 设置cookie的有效时间 &lt; 0 呢？ 保存在运行内存中。和不设置一样。 关于cookie的path，cookie关联的路径： 假设现在发送的请求路径是“http://localhost:8080/servlet13/cookie/generate”生成的cookie，如果cookie没有设置path，默认的path是什么？ 默认的path是：http://localhost:8080/servlet13/cookie 以及它的子路径。 也就是说，以后只要浏览器的请求路径是http://localhost:8080/servlet13/cookie 这个路径以及这个路径下的子路径，cookie都会被发送到服务器。 手动设置cookie的path cookie.setPath(“&#x2F;servlet13”); 表示只要是这个servlet13项目的请求路径，都会提交这个cookie给服务器。 浏览器发送cookie给服务器了，服务器中的java程序怎么接收？ &#96;&#96;&#96;javaCookie[] cookies &#x3D; request.getCookies(); &#x2F;&#x2F; 这个方法可能返回nullif(cookies !&#x3D; null){for(Cookie cookie : cookies){ &#x2F;&#x2F; 获取cookie的name String name &#x3D; cookie.getName(); &#x2F;&#x2F; 获取cookie的value String value &#x3D; cookie.getValue();}} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147- 使用cookie实现一下十天内免登录功能。 - 先实现登录功能 - 登录成功 - 跳转到部门列表页面 - 登录失败 - 跳转到登录失败页面 - 修改前端页面 - 在登录页面给一个复选框，复选框后面给一句话：十天内免登录。 - 用户选择了复选框：表示要支持十天内免登录。 - 用户没有选择复选框：表示用户不想使用十天内免登录功能。 - 修改Servlet中的login方法 - 如果用户登录成功了，并且用户登录时选择了十天内免登录功能，这个时候应该在Servlet的login方法中创建cookie，用来存储用户名和密码，并且设置路径，设置有效期，将cookie响应给浏览器。（浏览器将其自动保存在硬盘文件当中10天） - 用户再次访问该网站的时候，访问这个网站的首页的时候，有两个走向: - 要么跳转到部门列表页面 - 要么跳转到登录页面 - 以上分别有两个走向，这显然是需要编写java程序进行控制的。# JSP&gt; JSP 具有九个内置对象，包括 Session 等，在进入 jsp 页面时，会自动创建一个 session 对象- 我的第一个JSP程序： - 在WEB-INF目录之外创建一个index.jsp文件，然后这个文件中没有任何内容。 - 将上面的项目部署之后，启动服务器，打开浏览器，访问以下地址： - http://localhost:8080/jsp/index.jsp 展现在大家面前的是一个空白。 - 实际上访问以上的这个：index.jsp，底层执行的是：index_jsp.class 这个java程序。 - 这个index.jsp会被tomcat翻译生成index_jsp.java文件，然后tomcat服务器又会将index_jsp.java编译生成index_jsp.class文件 - 访问index.jsp，实际上执行的是index_jsp.class中的方法。 - JSP实际上就是一个Servlet。 - index.jsp访问的时候，会自动翻译生成index_jsp.java，会自动编译生成index_jsp.class，那么index_jsp 这就是一个类。 - index_jsp 类继承 HttpJspBase，而HttpJspBase类继承的是HttpServlet。所以index_jsp类就是一个Servlet类。 - jsp的生命周期和Servlet的生命周期完全相同。完全就是一个东西。没有任何区别。 - jsp和servlet一样，都是单例的。（假单例。） - jsp文件第一次访问的时候是比较慢的，为什么？ - 为什么大部分的运维人员在给客户演示项目的时候，为什么提前先把所有的jsp文件先访问一遍。 - 第一次比较麻烦： - 要把jsp文件翻译生成java源文件 - java源文件要编译生成class字节码文件 - 然后通过class去创建servlet对象 - 然后调用servlet对象的init方法 - 最后调用servlet对象的service方法。 - 第二次就比较快了，为什么？ - 因为第二次直接调用单例servlet对象的service方法即可。 - JSP是什么？ - JSP是java程序。（JSP本质还是一个Servlet） - JSP是：JavaServer Pages的缩写。（基于Java语言实现的服务器端的页面。） - Servlet是JavaEE的13个子规范之一，那么JSP也是JavaEE的13个子规范之一。 - JSP是一套规范。所有的web容器/web服务器都是遵循这套规范的，都是按照这套规范进行的“翻译” - 每一个web容器/web服务器都会内置一个JSP翻译引擎。 - 对JSP进行错误调试的时候，还是要直接打开JSP文件对应的java文件，检查java代码。- 开发JSP的最高境界： - 眼前是JSP代码，但是脑袋中呈现的是java代码。 - JSP既然本质上是一个Servlet，那么JSP和Servlet到底有什么区别呢？ - 职责不同： - Servlet的职责是什么：收集数据。（Servlet的强项是逻辑处理，业务处理，然后链接数据库，获取/收集数据。） - JSP的职责是什么：展示数据。（JSP的强项是做数据的展示） - JSP的基础语法 - 在jsp文件中直接编写文字，都会自动被翻译到哪里？ - 翻译到servlet类的service方法的out.write(&quot;翻译到这里&quot;)，直接翻译到双引号里，被java程序当做普通字符串打印输出到浏览器。 - 在JSP中编写的HTML CSS JS代码，这些代码对于JSP来说只是一个普通的字符串。但是JSP把这个普通的字符串一旦输出到浏览器，浏览器就会对HTML CSS JS进行解释执行。展现一个效果。 - JSP的page指令（这个指令后面再详细说，这里先解决一下中文乱码问题），解决响应时的中文乱码问题： - 通过page指令来设置响应的内容类型，在内容类型的最后面添加：charset=UTF-8 - &lt;%@page contentType=&quot;text/html;charset=UTF-8&quot;%&gt;，表示响应的内容类型是text/html，采用的字符集UTF-8 - &lt;%@page import=&quot;java.util.List,java.util.ArrayList&quot;%&gt; - 怎么在JSP中编写Java程序： - &lt;% java语句; %&gt; - 在这个符号当中编写的被视为java程序，被翻译到Servlet类的service方法内部。 - 这里你要细心点，你要思考，在&lt;% %&gt;这个符号里面写java代码的时候，你要时时刻刻的记住你正在“方法体”当中写代码，方法体中可以写什么，不可以写什么，你心里是否明白呢？ - 在service方法当中编写的代码是有顺序的，方法体当中的代码要遵循自上而下的顺序依次逐行执行。 - service方法当中不能写静态代码块，不能写方法，不能定义成员变量。。。。。。 - 在同一个JSP当中 &lt;%%&gt; 这个符号可以出现多个。 - &lt;%! %&gt; - 在这个符号当中编写的java程序会自动翻译到service方法之外。 - 这个语法很少用，为什么？不建议使用，因为在service方法外面写静态变量和实例变量，都会存在线程安全问题，因为JSP就是servlet，servlet是单例的，多线程并发的环境下，这个静态变量和实例变量一旦有修改操作，必然会存在线程安全问题。 - JSP的输出语句 - 怎么向浏览器上输出一个java变量。 - &lt;% String name = “jack”; out.write(&quot;name = &quot; + name); %&gt; - 注意：以上代码中的out是JSP的九大内置对象之一。可以直接拿来用。当然，必须只能在service方法内部使用。 - 如果向浏览器上输出的内容中没有“java代码”，例如输出的字符串是一个固定的字符串，可以直接在jsp中编写，不需要写到&lt;%%&gt; 这里。 - 如果输出的内容中含有“java代码”，这个时候可以使用以下语法格式： - &lt;%= %&gt; 注意：在=的后面编写要输出的内容。 - &lt;%= %&gt; 这个符号会被翻译到哪里？最终翻译成什么？ - 翻译成了这个java代码： out.print(); - 翻译到service方法当中了。 - 什么时候使用&lt;%=%&gt; 输出呢？输出的内容中含有java的变量，输出的内容是一个动态的内容，不是一个死的字符串。如果输出的是一个固定的字符串，直接在JSP文件中编写即可。 - 在JSP中如何编写JSP的专业注释 - &lt;%--JSP的专业注释，不会被翻译到java源代码当中。--%&gt; - &lt;!--这种注释属于HTML的注释，这个注释信息仍然会被翻译到java源代码当中，不建议。--&gt; - JSP基础语法总结： - JSP中直接编写普通字符串 - 翻译到service方法的out.write(&quot;这里&quot;) - &lt;%%&gt; - 翻译到service方法体内部，里面是一条一条的java语句。 - &lt;%! %&gt; - 翻译到service方法之外。 - &lt;%= %&gt; - 翻译到service方法体内部，翻译为：out.print(); - &lt;%@page contentType=&quot;text/html;charset=UTF-8&quot;%&gt; - page指令，通过contentType属性用来设置响应的内容类型。 - 使用Servlet + JSP完成oa项目的改造。 - 使用Servlet处理业务，收集数据。 使用JSP展示数据。 - 将之前原型中的html文件，全部修改为jsp，然后在jsp文件头部添加page指令（指定contentType防止中文乱码），将所有的JSP直接拷贝到web目录下。 - 完成所有页面的正常流转。（页面仍然能够正常的跳转。修改超链接的请求路径。） - &lt;%=request.getContextPath() %&gt; 在JSP中动态的获取应用的根路径。 - Servlet中连接数据库，查询所有的部门，遍历结果集。 - 遍历结果集的过程中，取出部门编号、部门名、位置等信息，封装成java对象。 - 将java对象存放到List集合中。 - 将List集合存储到request域当中。 - 转发forward到jsp。 - 在JSP中： - 从request域当中取出List集合。 - 遍历List集合，取出每个部门对象。动态生成tr。 - 思考一个问题：如果我只用JSP这一个技术，能不能开发web应用？ - 当然可以使用JSP来完成所有的功能。因为JSP就是Servlet，在JSP的&lt;%%&gt;里面写的代码就是在service方法当中的，所以在&lt;%%&gt;当中完全可以编写JDBC代码，连接数据库，查询数据，也可以在这个方法当中编写业务逻辑代码，处理业务，都是可以的，所以使用单独的JSP开发web应用完全没问题。 - 虽然JSP一个技术就可以完成web应用，但是不建议，还是建议采用servlet + jsp的方式进行开发。这样都能将各自的优点发挥出来。JSP就是做数据展示。Servlet就是做数据的收集。（JSP中编写的Java代码越少越好。）一定要职责分明。 - JSP文件的扩展名必须是xxx.jsp吗？ - jsp文件的扩展名是可以配置的。不是固定的。 - 在CATALINA_HOME/conf/web.xml，在这个文件当中配置jsp文件的扩展名。 - ```xml &lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; xxx.jsp文件对于小猫咪来说，只是一个普通的文本文件，web容器会将xxx.jsp文件最终生成java程序，最终调用的是java对象相关的方法，真正执行的时候，和jsp文件就没有关系了。 小窍门：JSP如果看不懂，建议把jsp翻译成java代码，就能看懂了。 同学问：包名bean是什么意思？ javabean（java的logo是一杯冒着热气的咖啡。javabean被翻译为：咖啡豆） java是一杯咖啡，咖啡又是由一粒一粒的咖啡豆研磨而成。 整个java程序中有很多bean的存在。由很多bean组成。 什么是javabean？实际上javabean你可以理解为符合某种规范的java类，比如： 有无参数构造方法 属性私有化 对外提供公开的set和get方法 实现java.io.Serializable接口 重写toString 重写hashCode+equals …. javabean其实就是java中的实体类。负责数据的封装。 由于javabean符合javabean规范，具有更强的通用性。 完成剩下所有功能的改造。 当前的oa应用存在的问题： 任何一个用户都可以访问这个系统，都可以对这个系统当中的数据进行增删改这些危险的操作。我只想让合法的用户去使用这个系统，不合法的用户不能访问这个系统，怎么办？ 加一个登录功能。登录成功的可以访问该系统，登录失败不能访问。 实现登录功能： 步骤1：数据库当中添加一个用户表：t_user t_user表当中存储的是用户的登录信息，最基本的也包括：登录的用户名和登录的密码。 密码一般在数据库表当中存储的是密文。一般不以明文的形式存储。（这里先使用明文方式。） 向t_user表中插入数据。 步骤2：再实现一个登录页面。 登录页面上应该有一个登录的表单。有用户名和密码输入的框。 用户点击登录，提交表单，提交用户名和密码。form是post方式提交。 步骤3：后台要有一个对应的Servlet来处理登录的请求。 登录成功：跳转到部门列表页面。 登录失败：跳转到失败的页面。 步骤4：再提供一个登录失败的页面。 登录功能实现了，目前存在的最大的问题： 这个登录功能目前只是一个摆设，没有任何作用。只要用户知道后端的请求路径，照样可以在不登录的情况下访问。 这个登录没有真正起到拦截的作用。怎么解决？ JSP的指令 指令的作用：指导JSP的翻译引擎如何工作（指导当前的JSP翻译引擎如何翻译JSP文件。） 指令包括哪些呢？ include指令：包含指令，在JSP中完成静态包含，很少用了。（这里不讲） taglib指令：引入标签库的指令。这个到JJSTL标签库的时候再学习。现在先不管。 page指令：目前重点学习一个page指令。 指令的使用语法是什么？ &lt;%@指令名 属性名&#x3D;属性值 属性名&#x3D;属性值 属性名&#x3D;属性值….%&gt; 关于page指令当中都有哪些常用的属性呢？ &lt;%@page session=&quot;true|false&quot; %&gt; true表示启用JSP的内置对象session，表示一定启动session对象。没有session对象会创建。 如果没有设置，默认值就是session=&quot;true&quot; session=&quot;false&quot; 表示不启动内置对象session。当前JSP页面中无法使用内置对象session。 123456- ``` &lt;%@page contentType=&quot;text/json&quot; %&gt; contentType属性用来设置响应的内容类型 但同时也可以设置字符集。 &lt;%@page contentType=&quot;text/json;charset=UTF-8&quot; %&gt; &lt;%@page pageEncoding=&quot;UTF-8&quot; %&gt; pageEncoding=&quot;UTF-8&quot; 表示设置响应时采用的字符集。 12345- ``` &lt;%@page import=&quot;java.util.List, java.util.Date, java.util.ArrayList&quot; %&gt; &lt;%@page import=&quot;java.util.*&quot; %&gt; import语句，导包。 &#96;&#96;&#96;&lt;%@page errorPage&#x3D;”&#x2F;error.jsp” %&gt;当前页面出现异常之后，跳转到error.jsp页面。errorPage属性用来指定出错之后的跳转位置。 12345- ``` &lt;%@page isErrorPage=&quot;true&quot; %&gt; 表示启用JSP九大内置对象之一：exception 默认值是false。 JSP的九大内置对象 jakarta.servlet.jsp.PageContext pageContext 页面作用域 jakarta.servlet.http.HttpServletRequest request 请求作用域 jakarta.servlet.http.HttpSession session 会话作用域 jakarta.servlet.ServletContext application 应用作用域 pageContext &lt; request &lt; session &lt; application 以上四个作用域都有：setAttribute、getAttribute、removeAttribute方法。 以上作用域的使用原则：尽可能使用小的域。 java.lang.Throwable exception jakarta.servlet.ServletConfig config java.lang.Object page （其实是this，当前的servlet对象） jakarta.servlet.jsp.JspWriter out （负责输出） jakarta.servlet.http.HttpServletResponse response （负责响应） EL表达式 EL表达式是干什么用的？ Expression Language（表达式语言） EL表达式可以代替JSP中的java代码，让JSP文件中的程序看起来更加整洁，美观。 JSP中夹杂着各种java代码，例如&lt;% java代码 %&gt;、&lt;%&#x3D;%&gt;等，导致JSP文件很混乱，不好看，不好维护。所以才有了后期的EL表达式。 EL表达式可以算是JSP语法的一部分。EL表达式归属于JSP。 EL表达式出现在JSP中主要是： 从某个作用域中取数据，然后将其转换成字符串，然后将其输出到浏览器。这就是EL表达式的功效。三大功效： 第一功效：从某个域中取数据。 四个域： pageContext request session application 第二功效：将取出的数据转成字符串。 如果是一个java对象，也会自动调用java对象的toString方法将其转换成字符串。 第三功效：将字符串输出到浏览器。 和这个一样：&lt;%&#x3D; %&gt;，将其输出到浏览器。 EL表达式很好用，基本的语法格式： ${表达式} EL表达式的使用： &lt;% // 创建User对象 User user = new User(); user.setUsername(&quot;jackson&quot;); user.setPassword(&quot;1234&quot;); user.setAge(50); // 将User对象存储到某个域当中。一定要存，因为EL表达式只能从某个范围中取数据。 // 数据是必须存储到四大范围之一的。 request.setAttribute(&quot;userObj&quot;, user); %&gt; &lt;%--使用EL表达式取--%&gt; $&#123;这个位置写什么？？？？这里写的一定是存储到域对象当中时的name&#125; 要这样写： $&#123;userObj&#125; 等同于java代码：&lt;%=request.getAttribute(&quot;userObj&quot;)%&gt; 你不要这样写：$&#123;&quot;userObj&quot;&#125; 面试题： $&#123;abc&#125; 和 $&#123;&quot;abc&quot;&#125;的区别是什么？ $&#123;abc&#125;表示从某个域中取出数据，并且被取的这个数据的name是&quot;abc&quot;，之前一定有这样的代码: 域.setAttribute(&quot;abc&quot;, 对象); $&#123;&quot;abc&quot;&#125; 表示直接将&quot;abc&quot;当做普通字符串输出到浏览器。不会从某个域中取数据了。 $&#123;userObj&#125; 底层是怎么做的？从域中取数据，取出user对象，然后调用user对象的toString方法，转换成字符串，输出到浏览器。 &lt;%--如果想输出对象的属性值，怎么办？--%&gt; $&#123;userObj.username&#125; 使用这个语法的前提是：User对象有getUsername()方法。 $&#123;userObj.password&#125; 使用这个语法的前提是：User对象有getPassword()方法。 $&#123;userObj.age&#125; 使用这个语法的前提是：User对象有getAge()方法。 $&#123;userObj.email&#125; 使用这个语法的前提是：User对象有getEmail()方法。 EL表达式中的. 这个语法，实际上调用了底层的getXxx()方法。 注意：如果没有对应的get方法，则出现异常。报500错误。 $&#123;userObj.addr222.zipcode&#125; 以上EL表达式对应的java代码： user.getAddr222().getZipcode() 123456789101112131415161718192021222324252627282930313233343536373839404142- EL表达式优先从小范围中读取数据。 - pageContext &lt; request &lt; session &lt; application- EL表达式中有四个隐含的隐式的范围： - pageScope 对应的是 pageContext范围。 - requestScope 对应的是 request范围。 - sessionScope 对应的是 session范围。 - applicationScope 对应的是 application范围。- EL表达式对null进行了预处理。如果是null，则向浏览器输出一个空字符串。- EL表达式取数据的时候有两种形式： - 第一种：. （大部分使用这种方式） - 第二种：[ ] （如果存储到域的时候，这个name中含有特殊字符，可以使用 [ ]） - request.setAttribute(&quot;abc.def&quot;, &quot;zhangsan&quot;); - $&#123;requestScope.abc.def&#125; 这样是无法取值的。 - 应该这样：$&#123;requestScope[&quot;abc.def&quot;]&#125;- 掌握使用EL表达式，怎么从Map集合中取数据： - $&#123;map.key&#125;- 掌握使用EL表达式，怎么从数组和List集合中取数据： - $&#123;数组[0]&#125; - $&#123;数组[1]&#125; - $&#123;list[0]&#125;- page指令当中，有一个属性，可以忽略EL表达式 - ``` &lt;%@page contentType=&quot;text/html;charset=UTF-8&quot; isELIgnored=&quot;true&quot; %&gt; isELIgnored=&quot;true&quot; 表示忽略EL表达式 isELIgnored=&quot;false&quot; 表示不忽略EL表达式。（这是默认值） isELIgnored=&quot;true&quot; 这个是全局的控制。 可以使用反斜杠进行局部控制：\\$&#123;username&#125; 这样也可以忽略EL表达式。 通过EL表达式获取应用的根： ${pageContext.request.contextPath} EL表达式中其他的隐式对象： pageContext param paramValues initParam EL表达式的运算符 算术运算符 +、-、*、&#x2F;、% 关系运算符 &#x3D;&#x3D; eq !&#x3D; &gt; &gt;&#x3D; &lt; &lt;&#x3D; 逻辑运算符 ! &amp;&amp; || not and or 条件运算符 ? : 取值运算符 [ ]和. empty运算符 empty运算符的结果是boolean类型 ${empty param.username} ${not empty param.username} ${!empty param.password} JSTL标签库 什么是JSTL标签库？ Java Standard Tag Lib（Java标准的标签库） JSTL标签库通常结合EL表达式一起使用。目的是让JSP中的java代码消失。 标签是写在JSP当中的，但实际上最终还是要执行对应的java程序。（java程序在jar包当中。） 使用JSTL标签库的步骤： 第一步：引入JSTL标签库对应的jar包。 tomcat10之后引入的jar包是： jakarta.servlet.jsp.jstl-2.0.0.jar jakarta.servlet.jsp.jstl-api-2.0.0.jar 在IDEA当中怎么引入？ 在WEB-INF下新建lib目录，然后将jar包拷贝到lib当中。然后将其“Add Lib…” 一定是要和mysql的数据库驱动一样，都是放在WEB-INF&#x2F;lib目录下的。 什么时候需要将jar包放到WEB-INF&#x2F;lib目录下？如果这个jar是tomcat服务器没有的。 第二步：在JSP中引入要使用标签库。（使用taglib指令引入标签库。） JSTL提供了很多种标签，你要引入哪个标签？？？？重点掌握核心标签库。 &#96;&#96;&#96;&lt;%@taglib prefix&#x3D;”c” uri&#x3D;”http://java.sun.com/jsp/jstl/core&quot; %&gt;这个就是核心标签库。prefix&#x3D;”这里随便起一个名字就行了，核心标签库，大家默认的叫做c，你随意。” 123456789101112 - 第三步：在需要使用标签的位置使用即可。表面使用的是标签，底层实际上还是java程序。 - JSTL标签的原理 - ``` &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 以上uri后面的路径实际上指向了一个xxx.tld文件。 tld文件实际上是一个xml配置文件。 在tld文件中描述了“标签”和“java类”之间的关系。 以上核心标签库对应的tld文件是：c.tld文件。它在哪里。 在jakarta.servlet.jsp.jstl-2.0.0.jar里面META-INF目录下，有一个c.tld文件。 源码解析：配置文件tld解析 &#96;&#96;&#96; 对该标签的描述 catch 标签的名字 org.apache.taglibs.standard.tag.common.core.CatchTag 标签对应的java类。 JSP 标签体当中可以出现的内容，如果是JSP，就表示标签体中可以出现符合JSP所有语法的代码。例如EL表达式。 对这个属性的描述 var 属性名 false false表示该属性不是必须的。true表示该属性是必须的。 false 这个描述说明了该属性是否支持EL表达式。false表示不支持。true表示支持EL表达式。 &lt;c:catch var&#x3D;””&gt;JSP….1234567891011121314151617181920212223242526272829 - jstl中的核心标签库core当中有哪些常用的标签呢？ - c:if - &lt;c:if test=&quot;boolean类型，支持EL表达式&quot;&gt;&lt;/c: if&gt; - c:forEach - &lt;c:forEach items=&quot;集合，支持EL表达式&quot; var=&quot;集合中的元素&quot; varStatus=&quot;元素状态对象&quot;&gt; $&#123;元素状态对象.count&#125; &lt;/c: forEach&gt; - &lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;10&quot; step=&quot;2&quot;&gt; $&#123;i&#125; &lt;/c: forEach&gt; - c:choose c:when c:otherwise - ``` &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;param.age &lt; 18&#125;&quot;&gt; 青少年 &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;param.age &lt; 35&#125;&quot;&gt; 青年 &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;param.age &lt; 55&#125;&quot;&gt; 中年 &lt;/c:when&gt; &lt;c:otherwise&gt; 老年 &lt;/c:otherwise&gt; &lt;/c:choose&gt; 改造OA 使用什么技术改造呢？ Servlet + JSP + EL表达式 + JSTL标签。进行改造。 在前端HTML代码中，有一个标签，叫做base标签，这个标签可以设置整个网页的基础路径。 这是Java的语法，也不是JSP的语法。是HTML中的一个语法。HTML中的一个标签。通常出现在head标签中。 &lt; base href&#x3D;”http://localhost:8080/oa/&quot;&gt; 在当前页面中，凡是路径没有以“&#x2F;”开始的，都会自动将base中的路径添加到这些路径之前。 &lt; a href&#x3D;”ab&#x2F;def”&gt;&lt;&#x2F; a&gt; 等同于：&lt; a href&#x3D;”http://localhost:8080/oa/ab/def&quot;&gt;&lt;&#x2F; a&gt; 需要注意：在JS代码中的路径，保险起见，最好不要依赖base标签。JS代码中的路径最好写上全路径。 &#96;&#96;&#96; 12345678910111213141516171819202122232425262728293031# Filter过滤器- 当前的OA项目存在什么缺陷？ - DeptServlet、EmpServlet、OrderServlet。每一个Servlet都是处理自己相关的业务。在这些Servlet执行之前都是需要判断用户是否登录了。如果用户登录了，可以继续操作，如果没有登录，需要用户登录。这段判断用户是否登录的代码是固定的，并且在每一个Servlet类当中都需要编写，显然代码没有得到重复利用。包括每一个Servlet都要解决中文乱码问题，也有公共的代码。这些代码目前都是重复编写，并没有达到复用。怎么解决这个问题? - 可以使用Servlet规范中的Filter过滤器来解决这个问题。 - Filter是什么，有什么用，执行原理是什么？ - Filter是过滤器。 - Filter可以在Servlet这个目标程序执行之前添加代码。也可以在目标Servlet执行之后添加代码。之前之后都可以添加过滤规则。 - 一般情况下，都是在过滤器当中编写公共代码。 - 一个过滤器怎么写呢？ - 第一步：编写一个Java类实现一个接口：jarkata.servlet.Filter。并且实现这个接口当中所有的方法。 - init方法：在Filter对象第一次被创建之后调用，并且只调用一次。 - doFilter方法：只要用户发送一次请求，则执行一次。发送N次请求，则执行N次。在这个方法中编写过滤规则。 - destroy方法：在Filter对象被释放/销毁之前调用，并且只调用一次。 - 第二步：在web.xml文件中对Filter进行配置。这个配置和Servlet很像。 - ``` &lt;filter&gt; &lt;filter-name&gt;filter2&lt;/filter-name&gt; &lt;filter-class&gt;com.bjpowernode.javaweb.servlet.Filter2&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter2&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 或者使用注解：@WebFilter({“*.do”}) 注意： Servlet对象默认情况下，在服务器启动的时候是不会新建对象的。 Filter对象默认情况下，在服务器启动的时候会新建对象。 Servlet是单例的。Filter也是单例的。（单实例。） 目标Servlet是否执行，取决于两个条件： 第一：在过滤器当中是否编写了：chain.doFilter(request, response); 代码。 第二：用户发送的请求路径是否和Servlet的请求路径一致。 chain.doFilter(request, response); 这行代码的作用： 执行下一个过滤器，如果下面没有过滤器了，执行最终的Servlet。 注意：Filter的优先级，天生的就比Servlet优先级高。 &#x2F;a.do 对应一个Filter，也对应一个Servlet。那么一定是先执行Filter，然后再执行Servlet。 关于Filter的配置路径： &#x2F;a.do、&#x2F;b.do、&#x2F;dept&#x2F;save。这些配置方式都是精确匹配。 &#x2F;* 匹配所有路径。 *.do 后缀匹配。不要以 &#x2F; 开始 &#x2F;dept&#x2F;* 前缀匹配。 在web.xml文件中进行配置的时候，Filter的执行顺序是什么？ 依靠filter-mapping标签的配置位置，越靠上优先级越高。 过滤器的调用顺序，遵循栈数据结构。 使用@WebFilter的时候，Filter的执行顺序是怎样的呢？ 执行顺序是：比较Filter这个类名。 比如：FilterA和FilterB，则先执行FilterA。 比如：Filter1和Filter2，则先执行Filter1. Filter的生命周期？ 和Servlet对象生命周期一致。 唯一的区别：Filter默认情况下，在服务器启动阶段就实例化。Servlet不会。 Filter过滤器这里有一个设计模式： 责任链设计模式。 过滤器最大的优点： 在程序编译阶段不会确定调用顺序。因为Filter的调用顺序是配置到web.xml文件中的，只要修改web.xml配置文件中filter-mapping的顺序就可以调整Filter的执行顺序。显然Filter的执行顺序是在程序运行阶段动态组合的。那么这种设计模式被称为责任链设计模式。 责任链设计模式最大的核心思想： 在程序运行阶段，动态的组合程序的调用顺序。 使用过滤器改造OA项目。 Listener监听器 什么是监听器？ 监听器是Servlet规范中的一员。就像Filter一样。Filter也是Servlet规范中的一员。 在Servlet中，所有的监听器接口都是以“Listener”结尾。 监听器有什么用？ 监听器实际上是Servlet规范留给我们javaweb程序员的特殊时机。 特殊的时刻如果想执行这段代码，你需要想到使用对应的监听器。 Servlet规范中提供了哪些监听器？ jakarta.servlet包下： ServletContextListener ServletContextAttributeListener ServletRequestListener ServletRequestAttributeListener jakarta.servlet.http包下： HttpSessionListener HttpSessionAttributeListener 该监听器需要使用@WebListener注解进行标注。 该监听器监听的是什么？是session域中数据的变化。只要数据变化，则执行相应的方法。主要监测点在session域对象上。 HttpSessionBindingListener 该监听器不需要使用@WebListener进行标注。 假设User类实现了该监听器，那么User对象在被放入session的时候触发bind事件，User对象从session中删除的时候，触发unbind事件。 假设Customer类没有实现该监听器，那么Customer对象放入session或者从session删除的时候，不会触发bind和unbind事件。 HttpSessionIdListener session的id发生改变的时候，监听器中的唯一一个方法就会被调用。 HttpSessionActivationListener 监听session对象的钝化和活化的。 钝化：session对象从内存存储到硬盘文件。 活化：从硬盘文件把session恢复到内存。 实现一个监听器的步骤：以ServletContextListener为例。 第一步：编写一个类实现ServletContextListener接口。并且实现里面的方法。 void contextInitialized(ServletContextEvent event) void contextDestroyed(ServletContextEvent event) 1234567- 第二步：在web.xml文件中对ServletContextListener进行配置，如下： - ``` &lt;listener&gt; &lt;listener-class&gt;com.bjpowernode.javaweb.listener.MyServletContextListener&lt;/listener-class&gt; &lt;/listener&gt; 当然，第二步也可以不使用配置文件，也可以用注解，例如：@WebListener 注意：所有监听器中的方法都是不需要javaweb程序员调用的，由服务器来负责调用？什么时候被调用呢？ 当某个特殊的事件发生（特殊的事件发生其实就是某个时机到了。）之后，被web服务器自动调用。 思考一个业务场景： 请编写一个功能，记录该网站实时的在线用户的个数。 我们可以通过服务器端有没有分配session对象，因为一个session代表了一个用户。有一个session就代表有一个用户。如果你采用这种逻辑去实现的话，session有多少个，在线用户就有多少个。这种方式的话：HttpSessionListener够用了。session对象只要新建，则count++，然后将count存储到ServletContext域当中，在页面展示在线人数即可。 业务发生改变了，只统计登录的用户的在线数量，这个该怎么办？ session.setAttribute(“user”, userObj); 用户登录的标志是什么？session中曾经存储过User类型的对象。那么这个时候可以让User类型的对象实现HttpSessionBindingListener监听器，只要User类型对象存储到session域中，则count++，然后将count++存储到ServletContext对象中。页面展示在线人数即可。 实现oa项目中当前登录在线的人数。 什么代表着用户登录了？ session.setAttribute(“user”, userObj); User类型的对象只要往session中存储过，表示有新用户登录。 什么代表着用户退出了？ session.removeAttribute(“user”); User类型的对象从session域中移除了。 或者有可能是session销毁了。（session超时）","categories":[],"tags":[]},{"title":"","slug":"JAVA/9-集合/6-hashset","date":"2022-11-22T13:33:19.568Z","updated":"2022-11-24T06:30:30.798Z","comments":true,"path":"2022/11/22/JAVA/9-集合/6-hashset/","link":"","permalink":"https://jhfuture.github.io/2022/11/22/JAVA/9-%E9%9B%86%E5%90%88/6-hashset/","excerpt":"","text":"equals 方法可以根据程序猿重写 &#x3D;&#x3D;对应类中的equals&#x3D;&#x3D;方法进行判断。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class HashSetSource &#123;public static void main(String[] args) &#123;HashSet hashSet = new HashSet();hashSet.add(&quot;java&quot;);//到此位置，第 1 次 add 分析完毕. hashSet.add(&quot;php&quot;);//到此位置，第 2 次 add 分析完毕hashSet.add(&quot;java&quot;);System.out.println(&quot;set=&quot; + hashSet);/*老韩对 HashSet 的源码解读1. 执行 HashSet()public HashSet() &#123;map = new HashMap&lt;&gt;();&#125;2. 执行 add()public boolean add(E e) &#123;//e = &quot;java&quot;return map.put(e, PRESENT)==null;//(static) PRESENT = new Object();&#125;3.执行 put() , 该方法会执行 hash(key) 得到 key 对应的 hash 值 算法 h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)public V put(K key, V value) &#123;//key = &quot;java&quot; value = PRESENT 共享return putVal(hash(key), key, value, false, true);&#125;韩顺平循序渐进学 Java 零基础第 649页4.执行 putValfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //定义了辅助变量//table 就是 HashMap 的一个数组，类型是 Node[]//if 语句表示如果当前 table 是 null, 或者 大小=0//就是第一次扩容，到 16 个空间. if ((tab = table) == null || (n = tab.length) == 0)n = (tab = resize()).length;//(1)根据 key，得到 hash 去计算该 key 应该存放到 table 表的哪个索引位置//并把这个位置的对象，赋给 p//(2)判断 p 是否为 null//(2.1) 如果 p 为 null, 表示还没有存放元素, 就创建一个 Node (key=&quot;java&quot;,value=PRESENT)//(2.2) 就放在该位置 tab[i] = newNode(hash, key, value, null)if ((p = tab[i = (n - 1) &amp; hash]) == null)tab[i] = newNode(hash, key, value, null);else &#123;//一个开发技巧提示： 在需要局部变量(辅助变量)时候，在创建Node&lt;K,V&gt; e; K k; ////如果当前索引位置对应的链表的第一个元素和准备添加的 key 的 hash 值一样//并且满足 下面两个条件之一://(1) 准备加入的 key 和 p 指向的 Node 结点的 key 是同一个对象//(2) p 指向的 Node 结点的 key 的 equals() 和准备加入的 key 比较后相同//就不能加入韩顺平循序渐进学 Java 零基础第 650页if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))e = p;//再判断 p 是不是一颗红黑树, //如果是一颗红黑树，就调用 putTreeVal , 来进行添加else if (p instanceof TreeNode)e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);else &#123;//如果 table 对应索引位置，已经是一个链表, 就使用 for 循环比较//(1) 依次和该链表的每一个元素比较后，都不相同, 则加入到该链表的最后// 注意在把元素添加到链表后，立即判断 该链表是否已经达到 8 个结点// , 就调用 treeifyBin() 对当前这个链表进行树化(转成红黑树)// 注意，在转成红黑树时，要进行判断, 判断条件// if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY(64))// resize();// 如果上面条件成立，先 table 扩容. // 只有上面条件不成立时，才进行转成红黑树//(2) 依次和该链表的每一个元素比较过程中，如果有相同情况,就直接 breakfor (int binCount = 0; ; ++binCount) &#123;if ((e = p.next) == null) &#123;p.next = newNode(hash, key, value, null);if (binCount &gt;= TREEIFY_THRESHOLD(8) - 1) // -1 for 1sttreeifyBin(tab, hash);break;&#125;if (e.hash == hash &amp;&amp;韩顺平循序渐进学 Java 零基础第 651页((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))break;p = e;&#125;&#125;if (e != null) &#123; // existing mapping for keyV oldValue = e.value;if (!onlyIfAbsent || oldValue == null)e.value = value;afterNodeAccess(e);return oldValue;&#125;&#125;++modCount;//size 就是我们每加入一个结点 Node(k,v,h,next), size++if (++size &gt; threshold)resize();//扩容afterNodeInsertion(evict);return null;&#125;*/&#125;&#125; public class HashSetSource {public static void main(String[] args) {HashSet hashSet &#x3D; new HashSet();hashSet.add(“java”);&#x2F;&#x2F;到此位置，第 1 次 add 分析完毕. hashSet.add(“php”);&#x2F;&#x2F;到此位置，第 2 次 add 分析完毕hashSet.add(“java”);System.out.println(“set&#x3D;” + hashSet);&#x2F;*老韩对 HashSet 的源码解读 执行 HashSet() public HashSet() { map &#x3D; new HashMap&lt;&gt;(); } 执行 add() public boolean add(E e) {&#x2F;&#x2F;e &#x3D; “java” return map.put(e, PRESENT)&#x3D;&#x3D;null;&#x2F;&#x2F;(static) PRESENT &#x3D; new Object(); } 3.执行 put() , 该方法会执行 hash(key) 得到 key 对应的 hash 值 算法 h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16) public V put(K key, V value) {&#x2F;&#x2F;key &#x3D; “java” value &#x3D; PRESENT 共享 return putVal(hash(key), key, value, false, true); } 4.执行 putVal final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; &#x2F;&#x2F;定义了辅助变量 &#x2F;&#x2F;table 就是 HashMap 的一个数组，类型是 Node[] &#x2F;&#x2F;if 语句表示如果当前 table 是 null, 或者 大小&#x3D;0 &#x2F;&#x2F;就是第一次扩容，到 16 个空间. if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) n &#x3D; (tab &#x3D; resize()).length; &#x2F;&#x2F;(1)根据 key，得到 hash 去计算该 key 应该存放到 table 表的哪个索引位置 &#x2F;&#x2F;并把这个位置的对象，赋给 p &#x2F;&#x2F;(2)判断 p 是否为 null &#x2F;&#x2F;(2.1) 如果 p 为 null, 表示还没有存放元素, 就创建一个 Node (key&#x3D;”java”,value&#x3D;PRESENT) &#x2F;&#x2F;(2.2) 就放在该位置 tab[i] &#x3D; newNode(hash, key, value, null) if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null) tab[i] &#x3D; newNode(hash, key, value, null); else { &#x2F;&#x2F;一个开发技巧提示： 在需要局部变量(辅助变量)时候，在创建 Node&lt;K,V&gt; e; K k; &#x2F;&#x2F; &#x2F;&#x2F;如果当前索引位置对应的链表的第一个元素和准备添加的 key 的 hash 值一样 &#x2F;&#x2F;并且满足 下面两个条件之一: &#x2F;&#x2F;(1) 准备加入的 key 和 p 指向的 Node 结点的 key 是同一个对象 &#x2F;&#x2F;(2) p 指向的 Node 结点的 key(&#x3D;&#x3D;动态绑定机制&#x3D;&#x3D;)的 equals() 和准备加入的 key 比较后相同 &#x2F;&#x2F;就不能加入 这里可以自定义 对象中的 equals 方法去判断要放入的对象是否相同。 例如两个不同的 Dog 对象，可以设置 一个 equal 方法，来根据某一些特性进行判断。使其判断结果为相同的对象。 if (p.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) e &#x3D; p; &#x2F;&#x2F;再判断 p 是不是一颗红黑树, &#x2F;&#x2F;如果是一颗红黑树，就调用 putTreeVal , 来进行添加 else if (p instanceof TreeNode) e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else {&#x2F;&#x2F;如果 table 对应索引位置，已经是一个链表, 就使用 for 循环比较 &#x2F;&#x2F;(1) 依次和该链表的每一个元素比较后，都不相同, 则加入到该链表的最后 &#x2F;&#x2F; 注意在把元素添加到链表后，立即判断 该链表是否已经达到 8 个结点 &#x2F;&#x2F; , 就调用 treeifyBin() 对当前这个链表进行树化(转成红黑树) &#x2F;&#x2F; 注意，在转成红黑树时，要进行判断, 判断条件 &#x2F;&#x2F; if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY(64)) &#x2F;&#x2F; resize(); &#x2F;&#x2F; 如果上面条件成立，先 table 扩容. &#x2F;&#x2F; 只有上面条件不成立时，才进行转成红黑树 &#x2F;&#x2F;(2) 依次和该链表的每一个元素比较过程中，如果有相同情况,就直接 break for (int binCount &#x3D; 0; ; ++binCount) { if ((e &#x3D; p.next) &#x3D;&#x3D; null) { p.next &#x3D; newNode(hash, key, value, null); if (binCount &gt;&#x3D; TREEIFY_THRESHOLD(8) - 1) &#x2F;&#x2F; -1 for 1st treeifyBin(tab, hash); break; } if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) break; p &#x3D; e; } } if (e !&#x3D; null) { &#x2F;&#x2F; existing mapping for key V oldValue &#x3D; e.value; if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null) e.value &#x3D; value; afterNodeAccess(e); return oldValue; } } ++modCount; &#x2F;&#x2F;size 就是我们每加入一个结点 Node(k,v,h,next), size++ if (++size &gt; threshold) resize();&#x2F;&#x2F;扩容 afterNodeInsertion(evict); return null; } *&#x2F; } }","categories":[],"tags":[]},{"title":"5-set接口","slug":"JAVA/9-集合/5-set接口","date":"2022-11-22T04:28:35.000Z","updated":"2022-11-22T06:37:38.531Z","comments":true,"path":"2022/11/22/JAVA/9-集合/5-set接口/","link":"","permalink":"https://jhfuture.github.io/2022/11/22/JAVA/9-%E9%9B%86%E5%90%88/5-set%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"——–进度 522截止 一、简要介绍 &#x3D;&#x3D;无序、没有索引，不允许重复元素（重复添加，内容只会有一个）&#x3D;&#x3D; 可以添加 null 二、常用方法 set isempty size 迭代器 remove(Object ) –&gt;指定删除某一个对象。 遍历方式 1234567891011Iterator iterator = set.iterator();while (iterator.hasNext()) &#123;Object obj = iterator.next();System.out.println(&quot;obj=&quot; + obj);&#125;set.remove(null);//方式 2: 增强 forSystem.out.println(&quot;=====增强 for====&quot;);for (Object o : set) &#123;System.out.println(&quot;o=&quot; + o);&#125; 三、原理分析 String对象添加失败的原因12hashset.add(new String(&quot;john&quot;))Thashset.add(new String(&quot;john&quot;))F 因为 String 类中的 equal 方法已经被重写，当 hashset 调用判断时，就会得到两个对象是相同的结果。","categories":[],"tags":[]},{"title":"4-LinkedList","slug":"JAVA/9-集合/4-LinkedList","date":"2022-11-21T14:13:12.000Z","updated":"2022-11-22T04:27:24.789Z","comments":true,"path":"2022/11/21/JAVA/9-集合/4-LinkedList/","link":"","permalink":"https://jhfuture.github.io/2022/11/21/JAVA/9-%E9%9B%86%E5%90%88/4-LinkedList/","excerpt":"","text":"一、LinkedList 底层实现了双向链表和双端队列等特点。 可以添加任意元素（元素可以重复），包括&#x3D;&#x3D;null&#x3D;&#x3D; 线程不安全，没有实现同步。 二、底层源码分析1)底层原理底层维护了一个&#x3D;&#x3D;双向链表&#x3D;&#x3D;。 2)简单案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class LinkedList01 &#123;public static void main(String[] args) &#123;//模拟一个简单的双向链表Node jack = new Node(&quot;jack&quot;);Node tom = new Node(&quot;tom&quot;);Node hsp = new Node(&quot;老韩&quot;);//连接三个结点，形成双向链表//jack -&gt; tom -&gt; hspjack.next = tom;tom.next = hsp;//hsp -&gt; tom -&gt; jackhsp.pre = tom;tom.pre = jack;Node first = jack;//让 first 引用指向 jack,就是双向链表的头结点Node last = hsp; //让 last 引用指向 hsp,就是双向链表的尾结点//演示，从头到尾进行遍历System.out.println(&quot;===从头到尾进行遍历===&quot;);while (true) &#123;韩顺平循序渐进学 Java 零基础第 632页if(first == null) &#123;break;&#125;//输出 first 信息System.out.println(first);first = first.next;&#125;//演示，从尾到头的遍历System.out.println(&quot;====从尾到头的遍历====&quot;);while (true) &#123;if(last == null) &#123;break;&#125;//输出 last 信息System.out.println(last);last = last.pre;&#125;//演示链表的添加对象/数据，是多么的方便//要求，是在 tom --------- 老韩直接，插入一个对象 smith//1. 先创建一个 Node 结点，name 就是 smithNode smith = new Node(&quot;smith&quot;);//下面就把 smith 加入到双向链表了smith.next = hsp;韩顺平循序渐进学 Java 零基础第 633页smith.pre = tom;hsp.pre = smith;tom.next = smith;//让 first 再次指向 jackfirst = jack;//让 first 引用指向 jack,就是双向链表的头结点System.out.println(&quot;===从头到尾进行遍历===&quot;);while (true) &#123;if(first == null) &#123;break;&#125;//输出 first 信息System.out.println(first);first = first.next;&#125;last = hsp; //让 last 重新指向最后一个结点//演示，从尾到头的遍历System.out.println(&quot;====从尾到头的遍历====&quot;);while (true) &#123;if(last == null) &#123;break;&#125;//输出 last 信息System.out.println(last);韩顺平循序渐进学 Java 零基础第 634页last = last.pre;&#125;&#125;&#125;//定义一个 Node 类，Node 对象 表示双向链表的一个结点class Node &#123;public Object item; //真正存放数据public Node next; //指向后一个结点public Node pre; //指向前一个结点public Node(Object name) &#123;this.item = name;&#125;public String toString() &#123;return &quot;Node name=&quot; + item;&#125;&#125; 三、选择","categories":[],"tags":[]},{"title":"3-List接口","slug":"JAVA/9-集合/3-List接口","date":"2022-11-21T08:45:34.000Z","updated":"2022-11-22T04:35:13.404Z","comments":true,"path":"2022/11/21/JAVA/9-集合/3-List接口/","link":"","permalink":"https://jhfuture.github.io/2022/11/21/JAVA/9-%E9%9B%86%E5%90%88/3-List%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"使用 System.out.println(arrayList); 打印 ArrayList 时，调用的也是 ArrayList 类的 &#x3D;&#x3D;toString&#x3D;&#x3D;方法 一、简要介绍 有序且可重复 支持索引，且&#x3D;&#x3D;索引从 0 开始&#x3D;&#x3D;,可以使用 索引读取指定数据。 二、常用方法 void add(int index, Object ele):在 index 位置插入 ele 元素 boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来 Object get(int index):获取指定 index 位置的元素 int indexOf(Object obj):返回 obj 在集合中&#x3D;&#x3D;首次&#x3D;&#x3D;出现的位置 int lastIndexOf(Object obj):返回 obj 在当前集合中&#x3D;&#x3D;末次&#x3D;&#x3D;出现的位置 Object remove(&#x3D;&#x3D;int index&#x3D;&#x3D;):移除指定 index 位置的元素，并&#x3D;&#x3D;返回此元素&#x3D;&#x3D; Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换. list.set(1, “玛丽”); List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合 12345678910111213141516171819202122232425262728293031323334353637ublic class ListMethod &#123;@SuppressWarnings(&#123;&quot;all&quot;&#125;)public static void main(String[] args) &#123;List list = new ArrayList();list.add(&quot;张三丰&quot;);list.add(&quot;贾宝玉&quot;); // void add(int index, Object ele):在 index 位置插入 ele 元素//在 index = 1 的位置插入一个对象list.add(1, &quot;韩顺平&quot;);System.out.println(&quot;list=&quot; + list);// boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来List list2 = new ArrayList();list2.add(&quot;jack&quot;);list2.add(&quot;tom&quot;);list.addAll(1, list2);System.out.println(&quot;list=&quot; + list);// Object get(int index):获取指定 index 位置的元素//说过// int indexOf(Object obj):返回 obj 在集合中首次出现的位置System.out.println(list.indexOf(&quot;tom&quot;));//2// int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置list.add(&quot;韩顺平&quot;);System.out.println(&quot;list=&quot; + list);System.out.println(list.lastIndexOf(&quot;韩顺平&quot;));// Object remove(int index):移除指定 index 位置的元素，并返回此元素list.remove(0);System.out.println(&quot;list=&quot; + list);// Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换. list.set(1, &quot;玛丽&quot;);System.out.println(&quot;list=&quot; + list);// List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndexList returnlist = list.subList(0, 2);System.out.println(&quot;returnlist=&quot; + returnlist);&#125;&#125; 三、练习demo1 12345678910111213141516171819202122232425262728293031323334public class ListExercise &#123;@SuppressWarnings(&#123;&quot;all&quot;&#125;)public static void main(String[] args) &#123;/*添加 10 个以上的元素(比如 String &quot;hello&quot; )，在 2 号位插入一个元素&quot;韩顺平教育&quot;，获得第 5 个元素，删除第 6 个元素，修改第 7 个元素，在使用迭代器遍历集合，要求:使用 List 的实现类 ArrayList 完成。*/List list = new ArrayList();for (int i = 0; i &lt; 12; i++) &#123;list.add(&quot;hello&quot; + i);&#125;System.out.println(&quot;list=&quot; + list);//在 2 号位插入一个元素&quot;韩顺平教育&quot;list.add(1, &quot;韩顺平教育&quot;);System.out.println(&quot;list=&quot; + list);//获得第 5 个元素System.out.println(&quot;第五个元素=&quot; + list.get(4));//删除第 6 个元素list.remove(5);System.out.println(&quot;list=&quot; + list);//修改第 7 个元素list.set(6, &quot;三国演义&quot;);System.out.println(&quot;list=&quot; + list);//在使用迭代器遍历集合Iterator iterator = list.iterator();while (iterator.hasNext()) &#123;Object obj = iterator.next();System.out.println(&quot;obj=&quot; + obj);&#125;&#125;&#125; demo2 12345678910111213141516```### 四、普通 for 循环#### what?使用 get 方法#### how```java for (int i = 0; i &lt;arrayList.size() ; i++) &#123; System.out.println(arrayList.get(i)); &#125; 五、注意 线程不安全 123456 public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125;没有 synchronized 六、底层分析1)ArrayList 不会被序列化 维护一个elementData 扩充 0(默认构造器)—&gt;10 —&gt;15 —&gt; 22 8(指定)—&gt;14—-&gt;21 Arrays.copy(url , int newlength)方法。且会保留原有的数据。 一个利用移位扩容。 1234567891011121314151617181920212223242526//默认为空的调试代码 默认不为空的调试代码public static void main(String[] args) &#123;//老韩解读源码//注意，注意，注意，Idea 默认情况下，Debug 显示的数据是简化后的，如果希望看到完整的数据//需要做设置. //使用无参构造器创建 ArrayList 对象//ArrayList list = new ArrayList();ArrayList list = new ArrayList(8);//使用 for 给 list 集合添加 1-10 数据for (int i = 1; i &lt;= 10; i++) &#123;list.add(i);&#125;//使用 for 给 list 集合添加 11-15 数据for (int i = 11; i &lt;= 15; i++) &#123;list.add(i);&#125;list.add(100);list.add(200);list.add(null);&#125; 2)vector自定义扩容12345678910int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?capacityIncrement : oldCapacity);=================有构造器中可以设置 increment=========================public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement; &#125; 详细123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@SuppressWarnings(&#123;&quot;all&quot;&#125;)public class Vector_ &#123;public static void main(String[] args) &#123;//无参构造器//有参数的构造Vector vector = new Vector(8);for (int i = 0; i &lt; 10; i++) &#123;vector.add(i);韩顺平循序渐进学 Java 零基础第 628页&#125;vector.add(100);System.out.println(&quot;vector=&quot; + vector);//老韩解读源码//1. new Vector() 底层/*public Vector() &#123;this(10);&#125;补充：如果是 Vector vector = new Vector(8);走的方法:public Vector(int initialCapacity) &#123;this(initialCapacity, 0);&#125;2. vector.add(i)2.1 //下面这个方法就添加数据到 vector 集合public synchronized boolean add(E e) &#123;modCount++;ensureCapacityHelper(elementCount + 1);elementData[elementCount++] = e;return true;&#125;2.2 //确定是否需要扩容 条件 ： minCapacity - elementData.length&gt;0private void ensureCapacityHelper(int minCapacity) &#123;// overflow-conscious codeif (minCapacity - elementData.length &gt; 0)韩顺平循序渐进学 Java 零基础第 629页grow(minCapacity);&#125;2.3 //如果 需要的数组大小 不够用，就扩容 , 扩容的算法//newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?// capacityIncrement : oldCapacity);//就是扩容两倍. private void grow(int minCapacity) &#123;// overflow-conscious codeint oldCapacity = elementData.length;int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?capacityIncrement : oldCapacity);if (newCapacity - minCapacity &lt; 0)newCapacity = minCapacity;if (newCapacity - MAX_ARRAY_SIZE &gt; 0)newCapacity = hugeCapacity(minCapacity);elementData = Arrays.copyOf(elementData, newCapacity);&#125;*/&#125;&#125; 3)ArrayList 和 vector","categories":[],"tags":[]},{"title":"2-集合的遍历","slug":"JAVA/9-集合/2-集合的遍历","date":"2022-11-21T08:26:58.000Z","updated":"2022-11-21T10:57:01.507Z","comments":true,"path":"2022/11/21/JAVA/9-集合/2-集合的遍历/","link":"","permalink":"https://jhfuture.github.io/2022/11/21/JAVA/9-%E9%9B%86%E5%90%88/2-%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86/","excerpt":"","text":"一、iter ———-&gt; Iterable 接口里的方法。how?123456789101112131415161718192021222324//1. 先得到 col 对应的 迭代器Iterator iterator = col.iterator();//2. 使用 while 循环遍历// while (iterator.hasNext()) &#123;//判断是否还有数据// //返回下一个元素，类型是 Object// Object obj = iterator.next();// System.out.println(&quot;obj=&quot; + obj);// &#125;//老师教大家一个快捷键，快速生成 while =&gt; itit//显示所有的快捷键的的快捷键 ctrl + jwhile (iterator.hasNext()) &#123;Object obj = iterator.next();System.out.println(&quot;obj=&quot; + obj);&#125;//3. 当退出 while 循环后 , 这时 iterator 迭代器，指向最后的元素// iterator.next();//NoSuchElementException//4. 如果希望再次遍历，需要重置我们的迭代器iterator = col.iterator();System.out.println(&quot;===第二次遍历===&quot;);while (iterator.hasNext()) &#123;Object obj = iterator.next();System.out.println(&quot;obj=&quot; + obj);&#125; 二、for 增强循环What?​ 底层依然是迭代器。可以在 &#x3D;&#x3D;集合、数组&#x3D;&#x3D;中使用。 快捷键—-&gt; 输入 &#x3D;&#x3D;I（大写I）&#x3D;&#x3D; How1234for (Object object:col)&#123;System.out.println(object);&#125; 三、普通 for 循环what?使用 get 方法 how123for (int i = 0; i &lt;arrayList.size() ; i++) &#123; System.out.println(arrayList.get(i)); &#125; 四、练习","categories":[],"tags":[]},{"title":"1-集合入门","slug":"JAVA/9-集合/1-集合入门","date":"2022-11-20T09:11:52.000Z","updated":"2022-11-22T04:39:06.608Z","comments":true,"path":"2022/11/20/JAVA/9-集合/1-集合入门/","link":"","permalink":"https://jhfuture.github.io/2022/11/20/JAVA/9-%E9%9B%86%E5%90%88/1-%E9%9B%86%E5%90%88%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、简介 集合主要是两组(单列集合 , 双列集合) Collection 接口有两个重要的子接口 List Set , 他们的实现子类都是单列集合 &#x2F;&#x2F; 单列集合123456//Collection//MapArrayList arrayList = new ArrayList();arrayList.add(&quot;jack&quot;);arrayList.add(&quot;tom&quot;); Map 接口的实现子类 是双列集合，存放的 K-V &#x2F;&#x2F; 双列集合123HashMap hashMap = new HashMap();hashMap.put(&quot;NO1&quot;, &quot;北京&quot;);hashMap.put(&quot;NO2&quot;, &quot;上海&quot;); &#x3D;&#x3D;把两张图记住&#x3D;&#x3D; 二、特点 子类可以存放多个元素 存与取的顺序问题。 没有直接实现的子类。 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.hspedu.collection_;import java.util.ArrayList;import java.util.List;/*** @author 韩顺平* @version 1.0*/public class CollectionMethod &#123;@SuppressWarnings(&#123;&quot;all&quot;&#125;)public static void main(String[] args) &#123;List list = new ArrayList();// add:添加单个元素list.add(&quot;jack&quot;);list.add(10);//list.add(new Integer(10))list.add(true);System.out.println(&quot;list=&quot; + list);// remove:删除指定元素//list.remove(0);//删除第一个元素list.remove(true);//指定删除某个元素System.out.println(&quot;list=&quot; + list);// contains:查找元素是否存在System.out.println(list.contains(&quot;jack&quot;));//T// size:获取元素个数System.out.println(list.size());//2// isEmpty:判断是否为空System.out.println(list.isEmpty());//F// clear:清空list.clear();System.out.println(&quot;list=&quot; + list);// addAll:添加多个元素ArrayList list2 = new ArrayList();list2.add(&quot;红楼梦&quot;);list2.add(&quot;三国演义&quot;);list.addAll(list2);System.out.println(&quot;list=&quot; + list);// containsAll:查找多个元素是否都存在System.out.println(list.containsAll(list2));//T// removeAll：删除多个元素list.add(&quot;聊斋&quot;);list.removeAll(list2);System.out.println(&quot;list=&quot; + list);//[聊斋]// 说明：以 ArrayList 实现类来演示. &#125;&#125; list.add(10);&#x2F;&#x2F;list.add(new Integer(10)),—&gt; 放入的是一个&#x3D;&#x3D;对象&#x3D;&#x3D;，只是默认有&#x3D;&#x3D;自动装箱的过程&#x3D;&#x3D; Sytem.out.println(arraylist)—&gt;逐个输出，自动拆箱。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://jhfuture.github.io/categories/JAVA/"}],"tags":[{"name":"集合","slug":"集合","permalink":"https://jhfuture.github.io/tags/%E9%9B%86%E5%90%88/"}]},{"title":"3-String结构剖析","slug":"JAVA/8-包装类/3-String结构剖析","date":"2022-11-19T08:44:18.000Z","updated":"2022-11-19T09:03:42.603Z","comments":true,"path":"2022/11/19/JAVA/8-包装类/3-String结构剖析/","link":"","permalink":"https://jhfuture.github.io/2022/11/19/JAVA/8-%E5%8C%85%E8%A3%85%E7%B1%BB/3-String%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90/","excerpt":"","text":"一、简介 serializable:网络传输 comparable：比较 charsequence: 字符序列 String String 对象用于保存字符串，也就是一组字符序列 “jack” 字符串常量, 双引号括起的字符序列 &#x2F;&#x2F; 字符串的字符使用 Unicode 字符编码，一个字符(不区分字母还是汉字)占两个字节 &#x2F;&#x2F; String 类有&#x3D;&#x3D;很多构造器&#x3D;&#x3D;，构造器的重载 &#x2F;常用的有 String s1 &#x3D; new String(); &#x2F;&#x2F; &#x2F;&#x2F; String s2 &#x3D; new String(String original); &#x2F;&#x2F; String s3 &#x3D; new String(char[] a); &#x2F;&#x2F; String s4 &#x3D; new String(char[] a,int startIndex,int count) &#x2F;&#x2F; String s5 &#x3D; new String(byte[] b) &#x2F;&#x2F; String 类实现了接口 Serializable【String 可以串行化:可以在网络传输】 &#x2F;&#x2F; 接口 Comparable [String 对象可以比较大小] &#x2F;&#x2F;6. String 是 final 类，不能被其他的类继承 &#x2F;&#x2F;7. ！！！！！！！！String 有属性 private final char value[]; 用于存放字符串内容 ！！！！！！！！！！！！！！！ &#x3D;&#x3D;一定要注意：value 是一个 final 类型， 不可以修改(需要功力)：即 value 不能指向 &#x2F;&#x2F; 新的地址，但是单个字符内容是可以变化&#x3D;&#x3D; 1234567String name = &quot;jack&quot;;name = &quot;tom&quot;;final char[] value = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;char[] v2 = &#123;&#x27;t&#x27;,&#x27;o&#x27;,&#x27;m&#x27;&#125;;value[0] = &#x27;H&#x27;; √ value=v2 × 不可以修改 value 地址//value = v2; 不可以修改 value 地址 how？","categories":[],"tags":[]},{"title":"2-Integer创建机制","slug":"JAVA/8-包装类/2-Integer创建机制","date":"2022-11-19T08:01:32.000Z","updated":"2022-11-19T08:36:27.401Z","comments":true,"path":"2022/11/19/JAVA/8-包装类/2-Integer创建机制/","link":"","permalink":"https://jhfuture.github.io/2022/11/19/JAVA/8-%E5%8C%85%E8%A3%85%E7%B1%BB/2-Integer%E5%88%9B%E5%BB%BA%E6%9C%BA%E5%88%B6/","excerpt":"","text":"案例12345678910111213141516171819202122232425262728293031323334/*** @author 韩顺平* @version 1.0*/public class WrapperExercise02 &#123;public static void main(String[] args) &#123;Integer i = new Integer(1);Integer j = new Integer(1);System.out.println(i == j); //False --&gt;比较内存地址。 // valueof（手动装箱和自动装箱的原理）的源码 public static Integer valueOf(int i) &#123;if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)return IntegerCache.cache[i + (-IntegerCache.low)];return new Integer(i);&#125;/*老韩解读//1. 如果 i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从数组返回//2. 如果不在 -128~127,就直接 new Integer(i)*/Integer m = 1; //底层 Integer.valueOf(1); -&gt; 阅读源码Integer n = 1;//底层 Integer.valueOf(1);System.out.println(m == n); //Ttru//所以，这里主要是看范围 -128 ~ 127 就是直接返回//，否则，就 new Integer(xx);Integer x = 128;//底层 Integer.valueOf(1);Integer y = 128;//底层 Integer.valueOf(1);System.out.println(x == y);//False&#125;&#125; 源码中 integercache.cache在类加载时完成了加载 二、面试题123456789101112131415161718192021222324252627282930313233343536373839404142看看下面代码，输出什么结果.WrapperExercise03.java 5minpackage com.hspedu.wrapper;/*** @author 韩顺平* @version 1.0*/public class WrapperExercise03 &#123;public static void main(String[] args) &#123;//示例一Integer i1 = new Integer(127);Integer i2 = new Integer(127);System.out.println(i1 == i2);//F//示例二Integer i3 = new Integer(128);Integer i4 = new Integer(128);System.out.println(i3 == i4);//F//示例三Integer i5 = 127;//底层 Integer.valueOf(127)Integer i6 = 127;//-128~127System.out.println(i5 == i6); //T//示例四Integer i7 = 128;Integer i8 = 128;System.out.println(i7 == i8);//F//示例五Integer i9 = 127; //Integer.valueOf(127)Integer i10 = new Integer(127);System.out.println(i9 == i10);//F//示例六Integer i11=127;int i12=127; =========================================== 只要有基本数据类型，判断的是 值是否相等。 这里 i11 自动调用了 intValue 方法System.out.println(i11==i12); //T//示例七Integer i13=128;int i14=128;System.out.println(i13==i14);//T&#125;&#125;","categories":[],"tags":[]},{"title":"1-包装类入门","slug":"JAVA/8-包装类/1-包装类入门","date":"2022-11-19T06:52:07.000Z","updated":"2022-11-19T07:21:24.749Z","comments":true,"path":"2022/11/19/JAVA/8-包装类/1-包装类入门/","link":"","permalink":"https://jhfuture.github.io/2022/11/19/JAVA/8-%E5%8C%85%E8%A3%85%E7%B1%BB/1-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、基本介绍包装类—&gt; 基本数据类型的扩展 二、装箱 123456789101112 int i=10;//手动装箱 Integer integer = new Integer(i); Integer integer1 = Integer.valueOf(i); //手动拆箱 int i1=integer.intValue(); //自动装箱 ---&gt; 直接将 int 类型 转换为 Integer intetger3=i; //自动拆箱 int i2=intetger3; 自动装箱底层 –&gt; 依然走的 valueof方法 自动拆箱 —&gt; Intvalue 三、包装类测试 1234567891011 Object object=true?new Integer(1):new Double(2.0); System.out.println(object); Object object1; if (true)&#123; object1=new Integer(1); &#125;else &#123; object1=new Double(2.0); &#125; System.out.println(object1);1.01","categories":[],"tags":[]},{"title":"5-自定义异常","slug":"JAVA/7-Exception/5-自定义异常","date":"2022-11-19T05:48:05.000Z","updated":"2023-01-10T07:19:52.474Z","comments":true,"path":"2022/11/19/JAVA/7-Exception/5-自定义异常/","link":"","permalink":"https://jhfuture.github.io/2022/11/19/JAVA/7-Exception/5-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8/","excerpt":"","text":"自定义异常 1.基本概念 2.自定义异常的步骤 1.定义异常类，并继承 Exception 或 runtimeException Excepetion 一般为编译异常 RuntimeExcetion 一般为运行异常 3.案例 两个题目","categories":[],"tags":[]},{"title":"4-throws异常处理","slug":"JAVA/7-Exception/4-throws异常处理","date":"2022-11-19T05:33:23.000Z","updated":"2022-11-19T05:46:52.268Z","comments":true,"path":"2022/11/19/JAVA/7-Exception/4-throws异常处理/","link":"","permalink":"https://jhfuture.github.io/2022/11/19/JAVA/7-Exception/4-throws%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"3. 案例 编译异常一定要进行处理。—&gt;必须进行显示处理 throws 给调用此方法的方法 调用此方法的方法进行处理 throws try catch try catch 运行异常 —&gt; java 中具有默认处理 —&gt;throws 显示处理 try cathch throws 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.hspedu.throws_;import java.io.FileInputStream;import java.io.FileNotFoundException;/*** @author 韩顺平* @version 1.0*/public class ThrowsDetail &#123;public static void main(String[] args) &#123;f2();&#125;public static void f2() /*throws ArithmeticException*/ &#123;//1.对于编译异常，程序中必须处理，比如 try-catch 或者 throws//2.对于运行时异常，程序中如果没有处理，默认就是 throws 的方式处理int n1 = 10;int n2 = 0;double res = n1 / n2;&#125;public static void f1() throws FileNotFoundException &#123;//这里大家思考问题 调用 f3() 报错//老韩解读//1. 因为 f3() 方法抛出的是一个编译异常//2. 即这时，就要 f1() 必须处理这个编译异常//3. 在 f1() 中，要么 try-catch-finally ,或者继续 throws 这个编译异常f3(); // 抛出异常&#125;public static void f3() throws FileNotFoundException &#123;FileInputStream fis = new FileInputStream(&quot;d://aa.txt&quot;);&#125;public static void f4() &#123;//老韩解读://1. 在 f4()中调用方法 f5() 是 OK//2. 原因是 f5() 抛出的是运行异常//3. 而 java 中，并不要求程序员显示处理,因为有默认处理机制f5();&#125;public static void f5() throws ArithmeticException &#123;&#125;&#125;韩顺平循序渐进学 Java 零基础第 528页class Father &#123; //父类public void method() throws RuntimeException &#123;&#125;&#125;class Son extends Father &#123;//子类//3. 子类重写父类的方法时，对抛出异常的规定:子类重写的方法，// 所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常类型的子类型//4. 在 throws 过程中，如果有方法 try-catch , 就相当于处理异常，就可以不必 throws@Overridepublic void method() throws ArithmeticException &#123;&#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"MySQL/JDBC/1-JDBC概述/0-JDBC的一些问题/1-模糊查询","date":"2022-11-18T12:19:25.706Z","updated":"2022-11-18T12:22:41.958Z","comments":true,"path":"2022/11/18/MySQL/JDBC/1-JDBC概述/0-JDBC的一些问题/1-模糊查询/","link":"","permalink":"https://jhfuture.github.io/2022/11/18/MySQL/JDBC/1-JDBC%E6%A6%82%E8%BF%B0/0-JDBC%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/1-%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"基本 sql 语句 1select field, from table_name where fielid3 like &#x27;%xxx%&#x27; JDBC中的使用 12345 String sql=&quot;select * from blogTable where title like ?&quot;;preparedStatement=connection.prepareStatement(sql); String keyword_v2=&quot;%&quot;+keyword+&quot;%&quot;; preparedStatement.setString(1,keyword_v2);","categories":[],"tags":[]},{"title":"3-两种异常处理机制","slug":"JAVA/7-Exception/3-两种异常处理机制","date":"2022-11-16T13:37:59.000Z","updated":"2022-11-19T05:28:21.569Z","comments":true,"path":"2022/11/16/JAVA/7-Exception/3-两种异常处理机制/","link":"","permalink":"https://jhfuture.github.io/2022/11/16/JAVA/7-Exception/3-%E4%B8%A4%E7%A7%8D%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","excerpt":"","text":"一、try-catch-finnally1)try-catch-finallyctrl + alt + t 程序员在代码中捕获发生的异常，自行处理。 12345678910111213141516try&#123; 可能有异常的代码块 &#125;catch(Exception e)&#123; //捕获到异常 1.当一场发生时 2.系统将异常封装成 exception 对象 e，传递给catch 3.得到异常对象后，程序猿，自己处理 ！！4.注意，如果没有发生异常，catch 代码快不执行！！！！ &#125;finally&#123; 1.不管try代码快是否发生异常，都会执行finally代码快里的。 2.通常将释放资源的代码放在 finally。&#125; 2)throws 将发生的异常抛出，交给调用者(方法)来处理，最顶级的处理者就是 JVM。 2)注意点 如果异常发生了那，异常后面的代码不会执行，直接进入catch快。 1234567891011121314151617181920public class exception2 &#123; public static void main(String[] args) &#123; try&#123; String str=&quot;13a&quot;; int i =Integer.parseInt(str); System.out.println(&quot;前面发生后面这个不会执行了&quot;); &#125;catch (Exception e)&#123; System.out.println(&quot;出现异常进入catch&quot;+e.getMessage()); &#125; System.out.println(&quot;代码继续执行trycatch后面的代码&quot;); &#125;&#125;finally &#123; System.out.println(&quot;finaly被执行了&quot;); &#125;=====出现异常进入catchFor input string: &quot;13a&quot; finaly被执行了代码继续执行trycatch后面的代码 可以由多个 catch 语句，捕获不同的异常。 但要求&#x3D;&#x3D;父类异常在后，子类异常在前&#x3D;&#x3D;。比如(EXCEPTION 在后，nullpointexception 在前。) 。如果报错，&#x3D;&#x3D;只会匹配一个 catch&#x3D;&#x3D; 不管结果怎么样，最终都要执行 finally 的方法案例这里出现异常没有进行 catch ，则直接到 finally ，然后就退出该方法了，不会继续执行后面的代码。 二、throw 如果程序抛出了异常，而没有进行异常捕获处理，那默认就是 throw 抛出这个异常。 三、案例分析1.try&#x2F;catch finally 1.1 finally 优先级很高，必须执行！！！！。 1.2 return i++; ，i++会执行，但因为必须执行 finally ，所以先不能执行 return。 四、总结","categories":[],"tags":[]},{"title":"2-五大常见异常","slug":"JAVA/7-Exception/2-五大常见异常","date":"2022-11-16T13:30:26.000Z","updated":"2022-11-16T13:37:21.582Z","comments":true,"path":"2022/11/16/JAVA/7-Exception/2-五大常见异常/","link":"","permalink":"https://jhfuture.github.io/2022/11/16/JAVA/7-Exception/2-%E4%BA%94%E5%A4%A7%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/","excerpt":"","text":"一、运行异常 4-类型转换异常 —-&gt;将对象强制转换为不是实例的子类。 5.数字格式不正确异常。 二、编译异常。","categories":[],"tags":[]},{"title":"1-异常入门","slug":"JAVA/7-Exception/1-异常入门","date":"2022-11-16T12:41:14.000Z","updated":"2023-01-10T07:12:23.533Z","comments":true,"path":"2022/11/16/JAVA/7-Exception/1-异常入门/","link":"","permalink":"https://jhfuture.github.io/2022/11/16/JAVA/7-Exception/1-%E5%BC%82%E5%B8%B8%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、简要介绍1)引出：1234567891011121314151617对异常进行捕获，保证程序可以继续运行. 看老师的代码演示 try-catchpackage com.hspedu.exception_;/*** @author 韩顺平* @version 1.0*/public class Exception01 &#123;public static void main(String[] args) &#123;int num1 = 10;int num2 = 0;//Scanner();//老韩解读//1. num1 / num2 =&gt; 10 / 0//2. 当执行到 num1 / num2 因为 num2 = 0, 程序就会出现(抛出)异常 ArithmeticException//3. 当抛出异常后，程序就退出，崩溃了 , 下面的代码就不在执行//4. 大家想想这样的程序好吗? 不好，不应该出现了一个不算致命的问题，就导致整个系统崩溃 java 设计者，提供了一个叫 异常处理机制来解决该问题 try catch 1234567891011121314// int res = num1 / num2;如果程序员，认为一段代码可能出现异常/问题，可以使用 try-catch 异常处理机制来解决从而保证程序的健壮性将该代码块-&gt;选中-&gt;快捷键 ctrl + alt + t -&gt; 选中 try-catch6. 如果进行异常处理(c)，那么即使出现了异常，程序可以继续执行。try &#123;int res = num1 / num2;&#125; catch (Exception e) &#123;//e.printStackTrace();System.out.println(&quot;出现异常的原因=&quot; + e.getMessage());//输出异常信息&#125;System.out.println(&quot;程序继续运行....&quot;);&#125;&#125; 2)分类 Error(错误)：java 虚拟机无法解决的问题。如：jvm系统内部错误、资源耗尽等严重情况。比如：stackovererror[栈溢出]和 OOM（out of memory），error 是严重错误，程序会奔溃。 Exception：其他因编程错误或偶然的外在因素导致的。 编译时异常[&#x3D;&#x3D;编译时&#x3D;&#x3D;，编译器检查出的异常] 运行时异常[程序&#x3D;&#x3D;运行时&#x3D;&#x3D;，程序出现的异常] –&gt; 例如空指针 Throwable–&gt;本类 。 —虚线为实现了接口 ——为子类 小结 123456789101112131415161718192021222324252627282930package com.jhfuture.Exception;public class customerexctpion &#123; /** * @author 韩顺平 * @version 1.0 */ public static void main(String[] args) /*throws AgeException*/ &#123; int age = 180;//要求范围在 18 – 120 之间，否则抛出一个自定义异常 if(!(age &gt;= 18 &amp;&amp; age &lt;= 120)) &#123;//这里我们可以通过构造器，设置信息 throw new AgeException(&quot;年龄需要在 18~120 之间&quot;); &#125; System.out.println(&quot;你的年龄范围正确.&quot;); &#125; &#125; //自定义一个异常//老韩解读//1. 一般情况下，我们自定义异常是继承 RuntimeException//2. 即把自定义异常做成 运行时异常，好处时，我们可以使用默认的处理机制//3. 即比较方便 class AgeException extends RuntimeException &#123; public AgeException(String message) &#123;//构造器 super(message); &#125; &#125;","categories":[],"tags":[]},{"title":"6-服务器端转发和客户端重定向","slug":"JavaWeb/servlet/6-服务器端转发和客户端重定向","date":"2022-11-16T03:06:52.000Z","updated":"2022-11-16T06:51:26.295Z","comments":true,"path":"2022/11/16/JavaWeb/servlet/6-服务器端转发和客户端重定向/","link":"","permalink":"https://jhfuture.github.io/2022/11/16/JavaWeb/servlet/6-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%BD%AC%E5%8F%91%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E5%AE%9A%E5%90%91/","excerpt":"","text":"服务端转发 &#x3D;&#x3D;request.getRequestDispatcher(“demo7”).forward(request,response);&#x3D;&#x3D; 123456789101112131415161718192021222324demo6public class demo6Servlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //内部转发 System.out.println(&quot;demo6&quot;); request.getRequestDispatcher(&quot;demo7&quot;).forward(request,response); &#125;&#125;dmeo7public class demo7Servlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //内部转发 System.out.println(&quot;demo7&quot;); &#125;&#125; 路径不发生改变 客户端重定向 发送改变并且有两个请求","categories":[],"tags":[]},{"title":"1-局部内部类入门","slug":"JAVA/5-面向对象(高级)/9-内部类/1-局部内部类/1-局部内部类入门","date":"2022-11-15T14:17:31.000Z","updated":"2022-11-15T14:36:04.898Z","comments":true,"path":"2022/11/15/JAVA/5-面向对象(高级)/9-内部类/1-局部内部类/1-局部内部类入门/","link":"","permalink":"https://jhfuture.github.io/2022/11/15/JAVA/5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E9%AB%98%E7%BA%A7)/9-%E5%86%85%E9%83%A8%E7%B1%BB/1-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB/1-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、简要介绍 记住： (1)局部内部类定义在方法&#x2F;代码块中 (2) 作用域在方法体&#x2F;代码块中。—&gt;定义它的地方 (3)本质还是一个方法 ()","categories":[],"tags":[]},{"title":"1-枚举","slug":"JAVA/6-枚举和注解/1-枚举","date":"2022-11-15T13:44:45.000Z","updated":"2022-11-16T08:15:45.081Z","comments":true,"path":"2022/11/15/JAVA/6-枚举和注解/1-枚举/","link":"","permalink":"https://jhfuture.github.io/2022/11/15/JAVA/6-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/1-%E6%9E%9A%E4%B8%BE/","excerpt":"","text":"toString:Enum 类已经重写过了，返回的是当前对象 名,子类可以重写该方法，用于返回对象的属性信息 name：返回当前对象名（常量名），子类中不能重写 ordinal：返回当前对象的位置号，默认从 0 开始 values：返回当前枚举类中所有的常量 valueOf：将字符串转换成枚举对象，要求字符串必须 为已有的常量名，否则报异常！ compareTo：比较两个枚举常量，比较的就是编号！ 7) 代码","categories":[{"name":"java","slug":"java","permalink":"https://jhfuture.github.io/categories/java/"}],"tags":[{"name":"枚举","slug":"枚举","permalink":"https://jhfuture.github.io/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"2-注解","slug":"JAVA/6-枚举和注解/2-注解","date":"2022-11-15T13:44:45.000Z","updated":"2022-11-16T12:40:30.080Z","comments":true,"path":"2022/11/15/JAVA/6-枚举和注解/2-注解/","link":"","permalink":"https://jhfuture.github.io/2022/11/15/JAVA/6-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/2-%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"一、基本介绍注解的理解 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角 色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。 基本的 Annotation 介绍使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素三个基本的 Annotation: @Override: 限定某个方法，是重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示某个程序元素(类, 方法等)已过时 @SuppressWarnings: 抑制编译器警告 二、逐个分析1.override重写 2.Deprecated @Deprecated 修饰某个元素, 表示该元素已经过时 &#x2F;&#x2F; 即不在推荐使用，但是仍然可以使用 查看 @Deprecated 注解类的源码 韩顺平循序渐进学 Java 零基础 第 495页 可以修饰方法，类，字段, 包, 参数 等等 @Deprecated 可以做版本升级过渡使用 1234567891011121314@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125;*/@Deprecatedclass A &#123;@Deprecatedpublic int n1 = 10;@Deprecatedpublic void hi()&#123;&#125;&#125; 3. SuppressWarnings 抑制编译警告。​ &#x2F;&#x2F;1. 当我们不希望看到这些警告的时候，可以使用 SuppressWarnings 注解来抑制警告信息&#x2F;&#x2F;2. 在{“”} 中，可以写入你希望抑制(不显示)警告信息 1@SuppressWarnings(&quot;&#123;all,boxing,&#125;&quot;) 可以指定的警告类型有: all，抑制所有警告 boxing，抑制与封装&#x2F;拆装作业相关的警告 cast，抑制与强制转型作业相关的警告 dep-ann，抑制与淘汰注释相关的警告 deprecation，抑制与淘汰的相关警告 fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告 finally，抑制与未传回 finally 区块相关的警告 hiding，抑制与隐藏变数的区域变数相关的警告 incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告 javadoc，抑制与 javadoc 相关的警告 nls，抑制与非 nls 字串文字相关的警告 null，抑制与空值分析相关的警告 rawtypes，抑制与使用 raw 类型相关的警告 resource，抑制与使用 Closeable 类型的资源相关的警告 restriction，抑制与使用不建议或禁止参照相关的警告 serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告 static-access，抑制与静态存取不正确相关的警告 static-method，抑制与可能宣告为 static 的方法相关的警告 super，抑制与置换方法相关但不含 super 呼叫的警告 synthetic-access，抑制与内部类别的存取未最佳化相关的警告 sync-override，抑制因为置换同步方法而遗漏同步化的警告 unchecked，抑制与未检查的作业相关的警告 unqualified-field-access，抑制与栏位存取不合格相关的警告 unused，抑制与未用的程式码及停用的程式码相关的警告 作用范围和放置的位置有关。 —-&gt;通常放在 具体的语句&#x2F;方法&#x2F;类 &#x3D;&#x3D;上&#x3D;&#x3D; &#x2F;比如 @SuppressWarnings 放置在 main 方法，那么抑制警告的范围就是 main &#x2F;&#x2F; 通常我们可以放置具体的语句, 三、元注解 元注解：修饰注解的注解 123456789Target --&gt; 在哪地方使用@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)Retention --&gt; 注解的作用范围 source 源码 class 类 runtime 运行时@Retention(RetentionPolicy.SOURCE)Documented 指定该注解是否会在 javadoc 体现@Inherited 子类会继承父类注解。 1.Retention source编译器使用后，直接丢弃这种策略的注释。 class编译器将注释记录放在 class 文件中，当运行 java 程序时，jvm 不会保留注解。 runtime编译器保留在 class 文件中，jvm 会保留，可以通过反射获取该注释。 2.Target 3.Documented 4.inherited A 具有 inherited 注解，B是 A 的子类，那么它将自动拥有这个注解","categories":[{"name":"java","slug":"java","permalink":"https://jhfuture.github.io/categories/java/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://jhfuture.github.io/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"2-内部类总结","slug":"JAVA/5-面向对象(高级)/9-内部类/0-内部类总结","date":"2022-11-15T13:44:45.000Z","updated":"2022-11-15T14:45:36.947Z","comments":true,"path":"2022/11/15/JAVA/5-面向对象(高级)/9-内部类/0-内部类总结/","link":"","permalink":"https://jhfuture.github.io/2022/11/15/JAVA/5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E9%AB%98%E7%BA%A7)/9-%E5%86%85%E9%83%A8%E7%B1%BB/0-%E5%86%85%E9%83%A8%E7%B1%BB%E6%80%BB%E7%BB%93/","excerpt":"","text":"一、简要一、类型（1）内部类有四种 局部内部类 匿名内部类！！！！ new 类&#x2F;接口(参数列表){|} 成员内部类 静态内部类 二、自我总结要点 成员内部类和静态内部类 都是放在外部类的&#x3D;&#x3D;成员位置&#x3D;&#x3D;，本质上就是一个成员 可以使用修饰符进行修饰 静态类拥有 static 的属性。 只能访问 外部类中 static 修饰的静态属性。 使用 &#x3D;&#x3D;外部类.成员名&#x3D;&#x3D; 访问内外同名成员（本内部类中和外部类同名的属性&#x2F;方法） 当 外部类和子类的成员重名时。!!!!! 不重名就直接&#x3D;&#x3D;就近原则&#x3D;&#x3D; outerClss.&#x3D;&#x3D;this&#x3D;&#x3D;.memberName 局部内部类 成员内部类 匿名内部类 outerClass.memberName 静态成员内部类，因为 静态属性可以直接使用 &#x3D;&#x3D;类名.xxx&#x3D;&#x3D;。","categories":[],"tags":[]},{"title":"1-静态内部类入门","slug":"JAVA/5-面向对象(高级)/9-内部类/4-静态内部类/1-静态内部类入门","date":"2022-11-15T13:15:15.000Z","updated":"2022-11-15T13:43:52.904Z","comments":true,"path":"2022/11/15/JAVA/5-面向对象(高级)/9-内部类/4-静态内部类/1-静态内部类入门/","link":"","permalink":"https://jhfuture.github.io/2022/11/15/JAVA/5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E9%AB%98%E7%BA%A7)/9-%E5%86%85%E9%83%A8%E7%B1%BB/4-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB/1-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、简要介绍 what? ​ 定义在 outer类 的&#x3D;&#x3D;成员位置&#x3D;&#x3D;，并且有 static 修饰。 how 12345678910class Outer&#123; private String outerName=&quot;我是一个外部类的私有属性&quot;; //1.放在成员位置 //2.static 修饰 static class inner&#123; private String name=&quot;我是一个内部类的私有属性&quot;; void innerprint()&#123; System.out.println(outerName); &#125; &#125; 二、特点 使用 static 修饰，符合 static 修饰的原则。 只能访问 外部类的 &#x3D;&#x3D;所有静态成员&#x3D;&#x3D;，无法访问非静态。 可以添加任意的 访问修饰符 (public、protected、private、默认) 作用域的问题 外部类 –&gt;访问 –&gt;静态成员 [访问方式：1. 创建对象 2.使用方法名访问。] 1231.创建对象 2.对象名.xxx 内部成员—&gt; 访问 —&gt; 外部成员 [访问方式：直接访问所有静态成员] &#x3D;&#x3D;就近原则&#x3D;&#x3D;。如果重名，使用 &#x3D;&#x3D;外部类.属性名&#x3D;&#x3D;进行访问。 12345678910111213class outer&#123;static String Staticname=&quot;外部类的属性&quot;;String name=&quot;外部类非静态属性&quot;; static class staticInner&#123; static String Staticname=&quot;静态内部类的属性&quot;; void print()&#123; System.out.println(Staticname); System.out.println(outer.staticname); &#125; &#125;&#125; 外部其他类 使用静态内部类。 123456789101112131415161718192021222324252627282930313233343536package com.jhfuture.innerclass.staticInnerclass;public class staticner &#123; public static void main(String[] args) &#123;//其他外部类访问静态成员内部类的三种方法 //1.使用 外部类名.静态类名 方法创建 outer.staticInner staticInner = new outer.staticInner(); staticInner.print(); //2.在外部类里 创建一个方法/静态方法 使用外部类对象名/外部类名 . 方法名来创建。 //2.1 outer outerObject = new outer(); outer.staticInner staticInner1 = outerObject.getstaticInnerInstace_commonly(); staticInner1.print(); //2.2 outer.staticInner staticInner2= outer.getstaticInnerInstace_StaticVersion(); staticInner2.print(); &#125;&#125;class outer&#123;static String Staticname=&quot;外部类的属性&quot;;String name=&quot;外部类非静态属性&quot;; static class staticInner&#123; void print()&#123; System.out.println(Staticname); &#125; &#125; staticInner getstaticInnerInstace_commonly()&#123; return new staticInner(); &#125; static staticInner getstaticInnerInstace_StaticVersion()&#123; return new staticInner(); &#125;&#125;","categories":[],"tags":[]},{"title":"1-成员内部类入门","slug":"JAVA/5-面向对象(高级)/9-内部类/3-成员内部类/1-成员内部类入门","date":"2022-11-15T12:38:35.000Z","updated":"2022-11-15T13:34:22.902Z","comments":true,"path":"2022/11/15/JAVA/5-面向对象(高级)/9-内部类/3-成员内部类/1-成员内部类入门/","link":"","permalink":"https://jhfuture.github.io/2022/11/15/JAVA/5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E9%AB%98%E7%BA%A7)/9-%E5%86%85%E9%83%A8%E7%B1%BB/3-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB/1-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、简要介绍what? 成员内部类定义在在 outer类 成员属性 的位置，属于类成员的内部类。 how? 123456789class Outer&#123; //内部类 class inner&#123; private String name=&quot;我是一个内部类的私有属性&quot;; void innerprint()&#123; System.out.println(outerName); &#125; &#125;&#125; 二、特点说明：成员内部类定义在在 outer类 成员属性 的位置，并且没有 static 修饰。 作用域问题： 在 成员内部类 中可以随意访问 outer类 中的内容，outer类也可以使用 成员内部类。 成员内部类访问 outer类 的属性。 直接使用属性名 &#x3D;&#x3D;—-&gt;包括private属性–&gt;因为在同一个类中&#x3D;&#x3D; &#x3D;&#x3D;就近原则&#x3D;&#x3D;&gt;如果外部类的属性成员名字 和 内部类相同 通过&#x3D;&#x3D;外部类.this.属性&#x3D;&#x3D;来访问外部类的成员 外部类的成员使用成员内部类 &#x3D;&#x3D;同样包括 private 属性&#x3D;&#x3D; 123451.创建内部类的对象 neinner inner = new inner();2.使用 inner.xx即可System.out.println(inner.name); 外部其他类–访问—-&gt;成员内部类 外部类名.成员内部类 xxx &#x3D;new 外部类对象.new 成员内部类 1234567891011121314151617181920212223242526272829303132public class memberClass_1 &#123; public static void main(String[] args) &#123; Outer outer = new Outer(); outer.print(); //外部其他类访问成员内部类的两种方法 //1.使用外部类的对象创建---&gt;成员内部类也是外部类对象的一个成员。 Outer.inner inner = outer.new inner(); inner.innerprint(); //2.在外部类中创建一个方法---&gt;返回成员内部类对象 Outer.inner inner1= outer.getinnerInstace(); inner1.innerprint(); &#125;&#125;class Outer&#123; private String outerName=&quot;我是一个外部类的私有属性&quot;; class inner&#123; private String name=&quot;我是一个内部类的私有属性&quot;; void innerprint()&#123; System.out.println(outerName); &#125; &#125; void print()&#123; inner inner = new inner(); System.out.println(inner.name); inner.innerprint(); &#125; public inner getinnerInstace()&#123; return new inner(); &#125;&#125; 可以添加任意修饰符(public、protected、默认、private)，因为它的地位就是&#x3D;&#x3D;一个成员&#x3D;&#x3D;","categories":[],"tags":[]},{"title":"3-JDBC批处理","slug":"MySQL/JDBC/3-JDBC批处理","date":"2022-11-14T11:34:15.000Z","updated":"2022-11-14T12:42:26.706Z","comments":true,"path":"2022/11/14/MySQL/JDBC/3-JDBC批处理/","link":"","permalink":"https://jhfuture.github.io/2022/11/14/MySQL/JDBC/3-JDBC%E6%89%B9%E5%A4%84%E7%90%86/","excerpt":"","text":"一、基本介绍what? how? 12345671.添加语句到批处理包 preparestatement.addBatch() 2.执行批处理包中的 sql 语句 preparestatement.executeBatch()3.清空批处理包中的内容。 preparestatement.clea","categories":[],"tags":[]},{"title":"2-JDBC中的事务","slug":"MySQL/JDBC/2-JDBC中的事务","date":"2022-11-14T11:00:50.000Z","updated":"2022-11-16T02:07:41.400Z","comments":true,"path":"2022/11/14/MySQL/JDBC/2-JDBC中的事务/","link":"","permalink":"https://jhfuture.github.io/2022/11/14/MySQL/JDBC/2-JDBC%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"一、简要介绍 how? 12345678910111213141516//1.在获取连接后，设置自动提交为off connection.setAutoCommit(false);//2.在异常处理中进行回滚。try&#123; &#125;catch(SQLException e)&#123; coonection.rollback(); &#125;//3.没有问题在 sql执行的最后进行提交connectio 案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.hspedu.jdbc.transaction_;import com.hspedu.jdbc.utils.JDBCUtils;import org.junit.jupiter.api.Test;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;/*** @author 韩顺平* @version 1.0* 演示 jdbc 中如何使用事务*/public class Transaction_ &#123; /没有使用事务. @Testpublic void noTransaction() &#123;//操作转账的业务//1. 得到连接Connection connection = null;//2. 组织一个 sqlString sql = &quot;update account set balance = balance - 100 where id = 1&quot;;String sql2 = &quot;update account set balance = balance + 100 where id = 2&quot;;PreparedStatement preparedStatement = null;//3. 创建 PreparedStatement 对象try &#123;connection = JDBCUtils.getConnection(); // 在默认情况下，connection 是默认自动提交preparedStatement = connection.prepareStatement(sql);preparedStatement.executeUpdate(); // 执行第 1 条 sqlint i = 1 / 0; //抛出异常preparedStatement = connection.prepareStatement(sql2);preparedStatement.executeUpdate(); // 执行第 3 条 sql&#125; catch (SQLException e) &#123;e.printStackTrace();&#125; finally &#123;//关闭资源 DBCUtils.close(null, preparedStatement, connection);&#125;&#125;//事务来解决@Testpublic void useTransaction() &#123;//操作转账的业务//1. 得到连接Connection connection = null;//2. 组织一个 sqlString sql = &quot;update account set balance = balance - 100 where id = 1&quot;;String sql2 = &quot;update account set balance = balance + 100 where id = 2&quot;;PreparedStatement preparedStatement = null;//3. 创建 PreparedStatement 对象try &#123;connection = JDBCUtils.getConnection(); // 在默认情况下，connection 是默认自动提交//将 connection 设置为不自动提交connection.setAutoCommit(false); //开启了事务preparedStatement = connection.prepareStatement(sql);preparedStatement.executeUpdate(); // 执行第 1 条 sqlint i = 1 / 0; //抛出异常preparedStatement = connection.prepareStatement(sql2);preparedStatement.executeUpdate(); // 执行第 3 条 sql //这里提交事务connection.commit();&#125; catch (SQLException e) &#123;//这里我们可以进行回滚，即撤销执行的 SQL//默认回滚到事务开始的状态. System.out.println(&quot;执行发生了异常，撤销执行的 sql&quot;);try &#123;connection.rollback();&#125; catch (SQLException throwables) &#123;throwables.printStackTrace();&#125;e.printStackTrace();&#125; finally &#123;//关闭资源JDBCUtils.close(null, preparedStatement, connection);&#125;&#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://jhfuture.github.io/categories/JDBC/"}],"tags":[{"name":"事务","slug":"事务","permalink":"https://jhfuture.github.io/tags/%E4%BA%8B%E5%8A%A1/"}]},{"title":"MySQL\\JDBC\\2-JDBC中的事务.md","slug":"MySQL-JDBC-2-JDBC中的事务-md","date":"2022-11-14T11:00:28.000Z","updated":"2022-11-14T11:00:28.136Z","comments":true,"path":"2022/11/14/MySQL-JDBC-2-JDBC中的事务-md/","link":"","permalink":"https://jhfuture.github.io/2022/11/14/MySQL-JDBC-2-JDBC%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1-md/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"1-数据库三范式基本介绍","slug":"MySQL/11-设计三范式/1-数据库三范式基本介绍","date":"2022-11-14T07:21:31.000Z","updated":"2023-01-16T15:34:33.017Z","comments":true,"path":"2022/11/14/MySQL/11-设计三范式/1-数据库三范式基本介绍/","link":"","permalink":"https://jhfuture.github.io/2022/11/14/MySQL/11-%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/1-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"用 时间 换 空间 几亿。 数据量可能是几个T，但是你如果数据库设计的得当，这个储存量是可以减少，可能只有几百G 1000G&#x3D;1T 硬盘产商计算。 操作系统计算 1024G&#x3D;1T 很多东西 sql里面有一个概念叫 笛卡尔积。 n* n * n 第一张表里有100条数据，我只相查一条 。 那100遍。 分数&#x3D;90分。 学生名字 分数 小名 12 小华 50 李华 60 李四 12 第一条开始， 假如说我要的数据在第50条，计算机认为你后面50条至100条可能还会有符合条件的数据。 我要查两个表，并且，我要用第一张表查到的数据，再去查第二张表。 n * n&#x3D;n² 我一开始的数据，用一张表，储存很多数据，会造成数据的冗余，—&gt;n 优化后，用多张表储存，避免了数据的冗余，但是我原来只需要查一张表，那我现在就要查多张表。 时间就变成了 n² 一、一览第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。 第二范式：建立在第一范式的基础上，要求所有非主键字段完全依赖主键，不要产生部分依赖。 第三范式：建立在第二范式基础，要求所有非主键字段直接依赖主键，不要产生传递依赖。 避免数据的冗余，空间的浪费。 什么叫依赖： 如果确定一个表中的某个数据（A），则就可以确定该表中的其他另一个数据（B），则我们说：B依赖于A。 实际上，一个表只要有主键，则其他非主键一定是依赖于主键的。 什么叫“部分依赖”： 如果确定一个表中的某个数据组合（A，B），则就可以确定该表中的其他另一个数据（C），则我们说：C依赖于（A，B）（此时A，B通常就是做出主键）。 但：如果某个数据D，它只依赖于数据A，或者说，A一确定，则D也可以确定，此时我们就称为“数据D部分依赖于数据A——可见部分依赖是指某个非主键字段，依赖于联合主键字段的其中部分字段。 依赖—————&gt; 一种关系 二、逐个分析1、第一范式 （1NF）：原子性（存储的数据应该具有“不可再分性”）1必须有主键，且2.每个字段是原子性的不能再分。 不符合第一范式的示例 主键：主键是唯一的。可以为一个字段，也可以为多个字段一起组合成一个主键—&gt;复合主键。 学生编号 学生姓名 联系方式 1001 张三 &#x7a;&#115;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;,1359999999 1002 李四 &#x6c;&#x73;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;,13699999999 1001 王五 &#119;&#x77;&#x40;&#x31;&#x36;&#51;&#x2e;&#x6e;&#101;&#x74;,13488888888 存在问题： 最后一条记录和第一条重复（不唯一，没有主键） 联系方式字段可以再分，不是原子性的 解决方案： 学生编号(pk) 学生姓名 email 联系电话 1001 张三 &#x7a;&#x73;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d; 1359999999 1002 李四 &#x6c;&#x73;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109; 13699999999 1003 王五 &#119;&#x77;&#x40;&#x31;&#54;&#x33;&#x2e;&#x6e;&#101;&#116; 13488888888 关于第一范式: 每一行必须唯一，也就是每个表必须有主键，这是我们数据库设计的最基本要求，主要通常采用数值 型或定长字符串表示，关于列不可再分，应该根据具体的情况来决定。如联系方式，为了开发上的便利可能就采用 一个字段了。 2、第二范式 唯一性 (消除非主键部分依赖联合主键中的部分字段)（一定要在第一范式已经满足的情况下）二范式是建立在第一范式基础上的，另外要求所有非主键字段完全依赖主键，不能产生&#x3D;&#x3D;部分依赖&#x3D;&#x3D;。 1.学生和教师的表 示例： 这里涉及到一个关系 &#x3D;&#x3D;多对多&#x3D;&#x3D; 学生编号 学生姓名 教师编号 教师姓名 1001 张三 001 王老师 1002 李四 002 赵老师 1003 王五 001 王老师 1001 张三 002 赵老师 1001 张三 003 陈老师 2个中文字符一个中文字符对应3个字节，1Byte&#x3D;8bit 分析以上的表满足第一范式吗？不满足，没有主键 情况一 修改建议 确定主键： —&gt;使用复合主键 学生编号 教师姓名 学生姓名 教师编号 1001王老师 张三 001 1002赵老师 李四 002 1003王老师 王五 001 1001赵老师 张三 002 情况二、 修改建议 确定主键： —&gt;使用复合主键 依赖于一部分。 考虑—&gt;数据冗余 原来的作用 这张表是要描述一个 学生 与老师的关系对应。 学生与老师的对应关系。 Final 假如 一、我想确定这个老师跟这个学生是否有关系？ 我有学生的编号和教师的编号。 学生编号(PK) 教师编号(PK) 学生姓名 教师姓名 1001 001 张三 王老师 1002 002 李四 赵老师 1003 001 王五 王老师 1001 002 张三 赵老师 SQL例子。 SELECT stuName FROM test_table WHERE StuID&#x3D;1001; 这张表描述了学生和老师的关系：一个学生可能有多个老师，一个老师有多个学生。 张三依赖1001 王老师依赖001 产生了部分依赖。 有什么缺点？数据冗余，空间浪费。大量的冗余， 主要涉及到的冗余字段为“学生姓名”和“教师姓名”。 出现冗余的原因在于： 学生姓名部分依赖了主键的一个字段学生编号，而没有依赖教师编号，而教师姓名部门依赖了主键的一个 字段教师编号，这就是第二范式部分依赖。 学生姓名依赖于学生编号，老师名字依赖于教师编号，都是&#x3D;&#x3D;主键的一部分&#x3D;&#x3D;，——&gt;部分依赖。 即&#x3D;&#x3D;多对多的问题&#x3D;&#x3D; how ？ 建立多张表 一个学生表、一个教师表、一个学生关系关系表。 学生信息表 学生编号 学生姓名 1001 张三 1002 李四 1003 王五 学生名字和一个教师名字 次数n1* n2* *n3 —&gt; 时间复杂度的问题。 n1 用空间换时间。 SQL 有索引进制。 教师信息表 教师编号 教师姓名 001 王老师 002 赵老师 003 陈老师 教师学生关系表 id(fk) 学生编号(fk) –&gt;学生表的学生编号 教师编号(PK) 教师编号(fk) –&gt;教师表的教师编号 1 1001 001 2 1002 002 3 1001 003 多对多，三张表，关系表两个外键。 小练习 看另一个案例 student_course student_number student_name course_name credit（课程代码） 100 小明 马克思 1aaa 102 小花 马克思 1aaa 100 小明 毛泽东思想 2bbbb 多对多，三张表，关系表两个外键。 3.第三范式 （独立性，消除传递依赖）第三范式建立在第二范式的基础上。 ​ 要求非主键字段必须直接依赖主键，不要产生传递依赖。 在一个具有主键的表中，假设主键为A，其必然其他非主键都依赖于该主键，比如：B依赖于A，C依赖于A，D依赖于A。。。。。。 但同时：如果该表中的某个字段B的值一确定，就能够确定另一个字段的值C，则我们称为C依赖于B。 那么，就出现了： C依赖B，B依赖A——这就是传递依赖。 则消除该传递依赖的的通常做法，就是将C依赖于B的数据，分离到另一个表中。 学生班级对应表 一对多。一个班级可以包含多个学生，一个学生只能对应一个班级。 学生与班级。 学生编号 学生姓名 班级编号 班级名称 1001 张三 01 一年级一班 1002 李四 01 一年级一班 1003 王五 03 一年级三班 1004 六 03 一年级三班 一个教室中有多个学生。 —-&gt;一对多。 A1:符合第一范式吗？ ​ Q:符合，只有一个外键。 A2:符合第二范式吗？ ​ Q:没有部分依赖。符合 A3:符合第三范式吗？ ​ Q：班级名称依赖于班级编号，班级编号依赖于学生编号—&gt;存在&#x3D;&#x3D;传递依赖&#x3D;&#x3D; 解决方法 一对多，两张表，多的表加外键。 一、学生表 学生编号（pk） 学生姓名 班级编号(fk) 1001 张三 01 1002 李四 02 1003 王五 03 1004 老六 03 二、班级信息表 班级编号(pk) 班级名称 01 一年级一班 02 一年级二班 03 一年级三班 三、总结学生与班级 ， 一对多： ​ 两张表，多的表加外键。 学生与课程。一个学生可能有多门课程，一门课程会有多个学生。 多对多： ​ 三张表，关系表两个外键。 一对一： ​ 一对一、拆分表，外键唯一！ ​ 在实际开发中，可能存在一张表字段太多，太庞大，这个时候要拆分表。 一对一怎么设计？ 没有查分表之前：一张表 id(pk) account password email realname address 1 zhangsang 123 &#49;&#x34;&#49;&#50;&#56;&#x34;&#x32;&#x33;&#x32;&#x33;&#x34;&#x39;&#x31;&#64;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d; 张三 广东省xxx 2 lisi 123 &#49;&#x34;&#49;&#x32;&#56;&#50;&#x31;&#x33;&#50;&#57;&#x31;&#x40;&#x71;&#x71;&#46;&#99;&#111;&#x6d; 李四 广东省xxx 这种庞大的表建议拆分为两张： t_login 登录表 id(pk) account password 1 1235 123 2 1234 123 t_user 用户信息表 id(pk) realname email address loginid(fk) unique –&gt;以t_login表中的id为外键 account 1001 张三 &#x31;&#52;&#x31;&#x32;&#x38;&#52;&#50;&#51;&#x32;&#51;&#x34;&#57;&#49;&#64;&#113;&#113;&#46;&#99;&#111;&#x6d; 广东省 1 1235 1002 李四 &#49;&#x34;&#49;&#50;&#56;&#x32;&#x31;&#51;&#50;&#x39;&#x31;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#109; 广东省 2 1234 四、老杜一些嘱咐的话数据库设计尽量遵循三范式，但是还是根据实际情况进行取舍，有时可能会拿冗余换速度，最终用目的要满足客户需 求。 因为在 sql 当中，表和表之间链接次数越多，效率越低（笛卡尔积） 有的时候可能会存在冗余，但为了减少表的连接次数，这样子做也是合理的，并且对于开发人员来说，sql 语句的编写难度也会降低。","categories":[],"tags":[]},{"title":"1-DBA基本介绍","slug":"MySQL/10-DBA/1-DBA的基本介绍","date":"2022-11-14T07:13:16.000Z","updated":"2022-11-14T07:20:08.710Z","comments":true,"path":"2022/11/14/MySQL/10-DBA/1-DBA的基本介绍/","link":"","permalink":"https://jhfuture.github.io/2022/11/14/MySQL/10-DBA/1-DBA%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"一、创建二、权限管理三、导入导出（常用 ）1.备份数据库1)导出数据库 1mysqldump databaseName &gt; path -uroot -ppassword 2)导入数据库 1231.先创建一个数据表 create database xxx2.使用该数据表 use xxxx;3.导入.sql文件初始化数据库 source .sql文件路径 2.备份指定表1)导出指定表 1","categories":[{"name":"mysql","slug":"mysql","permalink":"https://jhfuture.github.io/categories/mysql/"}],"tags":[{"name":"DBA","slug":"DBA","permalink":"https://jhfuture.github.io/tags/DBA/"}]},{"title":"3-索引失效","slug":"MySQL/7-MySQL索引/3-索引失效","date":"2022-11-14T05:54:13.000Z","updated":"2022-11-14T06:27:02.840Z","comments":true,"path":"2022/11/14/MySQL/7-MySQL索引/3-索引失效/","link":"","permalink":"https://jhfuture.github.io/2022/11/14/MySQL/7-MySQL%E7%B4%A2%E5%BC%95/3-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/","excerpt":"","text":"一、引入​ 索引可以在一些查询情况下加速查询速度，但某一些情况下索引也会失效，我们需要知道这些特殊情况，以更好的优化 sql 语句。 模糊匹配以 &#x3D;&#x3D;%开头&#x3D;&#x3D; 1select * from account where ename like &quot;%T&quot;; 使用 or ，如果 or 的两边存在有一个字段 &#x3D;&#x3D;没有索引&#x3D;&#x3D;，那它会导致 另一个 &#x3D;&#x3D;有索引&#x3D;&#x3D;的字段&#x3D;&#x3D;索引失效&#x3D;&#x3D;。解决办法： 不使用 or 给 or 两边的字段&#x3D;&#x3D;都 建立索引&#x3D;&#x3D; 1select * from emp where ename =&#x27;king &#x27;or job= &#x27;manager&#x27;; 使用复合索引时，没有使用 &#x3D;&#x3D;左侧&#x3D;&#x3D;的列进行查找，索引失效。什么是复合索引？ 两个字段，或者更多的字段联合起来，添加一个索引，叫做复合索引。———-&gt;多个字段，一个索引 12345678910111213141516171819202122#建立复合索引create index emp_job_sal_index on emp(job,sal);#查询左侧&gt; 以下的 type ref 表示索引 all 表示遍历mysql&gt; explain select * from emp where job =&#x27;manager&#x27;;+----+-------------+-------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------+| 1 | SIMPLE | emp | NULL | ref(ref代表索引) | emp_job_sal_index | emp_job_sal_index | 39 | const | 3 | 100.00 | NULL |+----+-------------+-------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.00 sec)#查询右侧mysql&gt; explain select * from emp where sal =800;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL(表示遍历) | NULL | NULL | NULL | NULL | 14 | 10.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec) 在 where 中，索引列参加了运算，索引失效 12345678910111213141516171819create index emp_sal_index on emp(sal);##普通mysql&gt; explain select * from emp where sal=800;+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+| 1 | SIMPLE | emp | NULL | ref | emp_sal_index | emp_sal_index | 9 | const | 1 | 100.00 | NULL |+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.00 sec)#加了运算mysql&gt; explain select * from emp where sal+1=800;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | NULL | NULL | NULL | NULL | 14 | 100.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec) 在 where 当中索引使用了 &#x3D;&#x3D;函数&#x3D;&#x3D;。12345678910create index emp_ename_index on emp(ename);# 转小写mysql&gt; explain select * from emp where lower(ename)=&#x27;smith&#x27;;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | NULL | NULL | NULL | NULL | 14 | 100.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)","categories":[{"name":"mysql","slug":"mysql","permalink":"https://jhfuture.github.io/categories/mysql/"}],"tags":[{"name":"mysql索引失效","slug":"mysql索引失效","permalink":"https://jhfuture.github.io/tags/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/"}]},{"title":"mysql事务隔离级别","slug":"MySQL/8-mysql事务/2-事务隔离级别/1-基本介绍","date":"2022-11-13T06:38:30.000Z","updated":"2022-11-13T14:02:19.774Z","comments":true,"path":"2022/11/13/MySQL/8-mysql事务/2-事务隔离级别/1-基本介绍/","link":"","permalink":"https://jhfuture.github.io/2022/11/13/MySQL/8-mysql%E4%BA%8B%E5%8A%A1/2-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"一、基本介绍what? &#x3D;&#x3D;多个链接&#x3D;&#x3D;开启各自事务操作数据库，数据库系统要负责 &#x3D;&#x3D;隔离操作&#x3D;&#x3D;，以保证各个链接在获取数据时的准确性。 隔离级别：定义了事务与事务之间的隔离程度。 不考虑隔离性,可能会引发一下问题： 脏读一个事务读取到了另一个事务，&#x3D;&#x3D;尚未提交的修改&#x3D;&#x3D;。 不可重复读不可重复读对应的操作为 &#x3D;&#x3D;修改&#x2F;删除&#x3D;&#x3D; 幻读幻读对应的操作为 &#x3D;&#x3D;插入&#x3D;&#x3D; 二、具体分析 查看隔离级别 123456789旧版 select @@tx_isolation;新版 (5.7以后及8) select @@transaction_isolation;+-------------------------+| @@transaction_isolation |+-------------------------+| REPEATABLE-READ |+-------------------------+1 row in set (0.00 sec) 隔离级别的设置操作必须在&#x3D;&#x3D;开启事务之前&#x3D;&#x3D;,否则会不生效！！！。 1.读未提交 ——–set session transactionread committed12设置命令set session transaction isolation level read uncommitted 有A、B两个链接，B的链接为 &#x3D;&#x3D;Read uncommitted&#x3D;&#x3D;. ALTER TABLE account ADD name VARCHAR(255); A 连接的事务还在修改，但未提交， B 处的链接就可以查看到 A 事务所做的修改—- 看到未提交的修改–脏读、不可重复读 看到插入的新数据—幻读 2.读已经提交1set session transaction isolation level read committed A 、B:为 read commited A、B均为commit A未提交时，B不可以读到A修改的数据。 A提交后，B可以读到。 3.可重复读——-&gt; mysql 默认级别1set session transaction isolation level repeatable read; 4.序列化synchronized，线程同步（事务同步） 每一次读取到的数据都是最真实的，并且&#x3D;&#x3D;效率最低的&#x3D;&#x3D;. 当有另一个事务在进行的时候 三、怎么启动事务三、操作 查看系统隔离级别 1select @@global.transaction_isolation; 查看会话的级别 1select @@transaction_isolation; 修改系统隔离 1set global transaction isolation level 级别; 设置会话隔离级别 1set ==session== transaction isolation level 级别;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jhfuture.github.io/categories/MySQL/"}],"tags":[{"name":"sql约束","slug":"sql约束","permalink":"https://jhfuture.github.io/tags/sql%E7%BA%A6%E6%9D%9F/"}]},{"title":"1-匿名内部类入门","slug":"JAVA/5-面向对象(高级)/9-内部类/2-匿名内部类/1-匿名内部类入门","date":"2022-11-13T04:48:08.000Z","updated":"2022-11-25T16:39:24.590Z","comments":true,"path":"2022/11/13/JAVA/5-面向对象(高级)/9-内部类/2-匿名内部类/1-匿名内部类入门/","link":"","permalink":"https://jhfuture.github.io/2022/11/13/JAVA/5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E9%AB%98%E7%BA%A7)/9-%E5%86%85%E9%83%A8%E7%B1%BB/2-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/1-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%85%A5%E9%97%A8/","excerpt":"","text":"匿名内部类 综合性强：1继承 2 多态 3 动态绑定 4内部类 what? 本质还是类 属于内部类 该类没有名字 &#x3D;&#x3D;同时还是一个对象&#x3D;&#x3D; —-&gt; 在创建过程中使用了 new xxx()。类似创建对象的方法 位置：外部类的&#x3D;&#x3D;局部位置&#x3D;&#x3D;，比如方法中。 why? 一个需求： &#x2F;&#x2F;1.如果想使用 IA 接口。 2.传统方式 ：创建一个 class 实现这个接口，然后再创建对象。 3.使用匿名内部类 直接 IA ia &#x3D; new IA(){ } 就完成了一个 实现了接口的类的对象实例。 老韩的需求是 Tiger&#x2F;Dog 类只是使用一次，后面不再使用。 –&gt;.使用匿名内部类来简化 开发 How? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112new 类或接口(参数列表)&#123; 类体。&#125;package com.hspedu.innerclass;/*** 演示匿名内部类的使用*/public class AnonymousInnerClass &#123;public static void main(String[] args) &#123;Outer04 outer04 = new Outer04();outer04.method();&#125;&#125;class Outer04 &#123; //外部类private int n1 = 10;//属性public void method() &#123;//方法//基于接口的匿名内部类//老韩解读//1.需求： 想使用 IA 接口,并创建对象//2.传统方式，是写一个类，实现该接口，并创建对象//3.老韩需求是 Tiger/Dog 类只是使用一次，后面再不使用//4. 可以使用匿名内部类来简化开发//5. tiger 的编译类型 ? IA//6. tiger 的运行类型 ? 就是匿名内部类 Outer04$1/*我们看底层 会分配 类名 Outer04$1class Outer04$1 implements IA &#123;@Overridepublic void cry() &#123;System.out.println(&quot;老虎叫唤...&quot;);&#125;&#125; *///7. jdk 底层在创建匿名内部类 Outer04$1,立即马上就创建了 Outer04$1 实例，并且把地址// 返回给 tiger//8. 匿名内部类使用一次，就不能再使用演示基于接口的匿名内部类。IA tiger = new IA() &#123;@Overridepublic void cry() &#123;System.out.println(&quot;老虎叫唤...&quot;);&#125;&#125;;System.out.println(&quot;tiger 的运行类型=&quot; + tiger.getClass());tiger.cry();tiger.cry();tiger.cry();// IA tiger = new Tiger();// tiger.cry(); 演示基于类的匿名内部类//分析//1. father 编译类型 Father//2. father 运行类型 Outer04$2//3. 底层会创建匿名内部类/*class Outer04$2 extends Father&#123;@Overridepublic void test() &#123;System.out.println(&quot;匿名内部类重写了 test 方法&quot;);&#125;&#125;*///4. 同时也直接返回了 匿名内部类 Outer04$2 的对象//5. 注意(&quot;jack&quot;) 参数列表会传递给 构造器Father father = new Father(&quot;jack&quot;)&#123;@Overridepublic void test() &#123;System.out.println(&quot;匿名内部类重写了 test 方法&quot;);&#125;&#125;;System.out.println(&quot;father 对象的运行类型=&quot; + father.getClass());//Outer04$2father.test(); 基于抽象类的匿名内部类Animal animal = new Animal()&#123;@Override void eat() &#123;System.out.println(&quot;小狗吃骨头...&quot;);&#125;&#125;;animal.eat();&#125;&#125;interface IA &#123;//接口public void cry();&#125;//class Tiger implements IA &#123;//// @Override// public void cry() &#123;// System.out.println(&quot;老虎叫唤...&quot;);// &#125;//&#125;//class Dog implements IA&#123;// @Override// public void cry() &#123;// System.out.println(&quot;小狗汪汪...&quot;);// &#125;//&#125;class Father &#123;//类 public Father(String name) &#123;//构造器System.out.println(&quot;接收到 name=&quot; + name);&#125;public void test() &#123;//方法&#125;&#125;abstract class Animal &#123; //抽象类abstract void eat();&#125; 一、接口的匿名内部类使用123456789101112131415161718192021222324252627282930public class AnnoymouslnnerClass &#123; public static void main(String[] args) &#123; tiger tiger = new tiger(); tiger.cry(); //使用匿名内部类实现 // 底层 会分配类名 /*class outerName+$1 implements IA&#123; * @Override * public void cry() &#123; * System.out.println(&quot;tigger&quot;); * &#125; *&#125; * * * 7 dk 底层在创建了 匿名内部类立即马上就创建了它的实例，并且把地址返回。 * 8.匿名内部类使用一次就没有了，不能再使用， ---但是匿名内部类的对象还可以使用 * 就没有了 不能使用 new outerclass$1这个方法再来调用 * */ IA tigger=new IA() &#123; @Override public void cry() &#123; System.out.println(&quot;tigger&quot;); &#125; &#125;; tigger.cry(); //验证 // getclass 获取运行类型 System.out.println(&quot;tigger的运行类型&quot;+tigger.getClass()); &#125; &#125; 二、类的匿名内部类。123456789101112131415161718192021222324252627282930313233343536 基于类的匿名内部类 //1.father --编译类型 //2.编译类型 outerClass$2 --&gt; extend father //这个类只能使用一次，且是 继承了father的 //m //1. father 编译类型 Father //2. father 运行类型 Outer04$2 //3. 底层会创建匿名内部类 /* class Outer04$2 extends Father&#123; @Override public void test() &#123; System.out.println(&quot;匿名内部类重写了 test 方法&quot;); &#125; &#125;*///4. 同时也直接返回了 匿名内部类 Outer04$2 的对象//5. 注意(&quot;jack&quot;) 参数列表会传递给 构造器 Father father = new Father(&quot;hello&quot;) &#123;@Override public void test() &#123; System.out.println(&quot;匿名内部类重写了 test 方法&quot;); &#125;;基于抽闲类的匿名内部类 Animal animal = new Animal() &#123; //必须实现抽象方法 @Override void eat() &#123; &#125; &#125;;abstract class Animal&#123; abstract void eat();&#125; 二、匿名内部类的细节。 匿名内部类是一个对象。—&gt; 创建的过程中也有 new xx的操作。 创建的内部类 为 &#x3D;&#x3D;extend 了该类的 一个子类&#x3D;&#x3D;。 使用的过程中遵循多态的特点。 可以访问外部类的所有成员。包括私有的 不能&#x3D;&#x3D;添加访问修饰符&#x3D;&#x3D;，它的堤围就是一个局部变量。 作用域：仅仅在定义它的方法或代码块中，且只能使用一次。—&gt; 即 new 的那个操作。 如果外部内的成员和匿名内部类的成员重名时，匿名内部类遵循&#x3D;&#x3D;就近原则&#x3D;&#x3D;，如果想访问外部类的成员，则可以使用&#x3D;&#x3D;(外部类名.this.成员)&#x3D;&#x3D; 外部类名.this 就是调用 &#x3D;&#x3D;匿名内部类所在方法&#x3D;&#x3D;的 对象。 三、案例1)接口参数 12345678910111213141516171819202122232425262728293031323334做实参直接传递，简洁高效。 InnerClassExercise01.javapackage com.hspedu.innerclass;import com.hspedu.abstract_.AA;public class InnerClassExercise01 &#123;public static void main(String[] args) &#123;//当做实参直接传递，简洁高效f1(new IL() &#123;@Overridepublic void show() &#123; System.out.println(&quot;这是一副名画~~...&quot;);&#125;&#125;);//传统方法需要先创建一个实现该接口的类，然后再使用 new创建对象。f1(new Picture());&#125;//静态方法,形参是接口类型public static void f1(IL il) &#123;il.show();&#125;&#125;//接口interface IL &#123;void show();&#125;类-&gt;实现 IL =&gt; 编程领域 (硬编码)class Picture implements IL &#123;@Overridepublic void show() &#123;System.out.println(&quot;这是一副名画 XX...&quot;);&#125;&#125; 2)类 123456789101112131415161718192021222324252627282930313233343536373839404142package com.hspedu.innerclass;public class InnerClassExercise02 &#123;public static void main(String[] args) &#123;/*1.有一个铃声接口 Bell，里面有个 ring 方法。(右图)2.有一个手机类 Cellphone，具有闹钟功能 alarmClock，参数是 Bell 类型(右图)3.测试手机类的闹钟功能，通过匿名内部类(对象)作为参数，打印：懒猪起床了4.再传入另一个匿名内部类(对象)，打印：小伙伴上课了*/CellPhone cellPhone = new CellPhone();//老韩解读//1. 传递的是实现了 Bell 接口的匿名内部类 InnerClassExercise02$1//2. 重写了 ring//3. Bell bell = new Bell() &#123;// @Override// public void ring() &#123;// System.out.println(&quot;懒猪起床了&quot;);// &#125;// &#125;cellPhone.alarmClock(new Bell() &#123;@Overridepublic void ring() &#123;System.out.println(&quot;懒猪起床了&quot;);&#125;&#125;);cellPhone.alarmClock(new Bell() &#123;@Overridepublic void ring() &#123;System.out.println(&quot;小伙伴上课了&quot;);&#125;&#125;);&#125;&#125;interface Bell&#123; //接口void ring();//方法&#125;class CellPhone&#123;//类public void alarmClock(Bell bell)&#123;//形参是 Bell 接口类型System.out.println(bell.getClass());bell.ring();//动态绑定&#125;&#125;","categories":[],"tags":[]},{"title":"1-内部类入门","slug":"JAVA/5-面向对象(高级)/9-内部类/0-内部类入门","date":"2022-11-13T04:46:20.000Z","updated":"2022-11-15T14:13:20.673Z","comments":true,"path":"2022/11/13/JAVA/5-面向对象(高级)/9-内部类/0-内部类入门/","link":"","permalink":"https://jhfuture.github.io/2022/11/13/JAVA/5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E9%AB%98%E7%BA%A7)/9-%E5%86%85%E9%83%A8%E7%B1%BB/0-%E5%86%85%E9%83%A8%E7%B1%BB%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、基本介绍1.简介类的五大成员 属性 方法 构造器 方法块 内部类 2.根据定义的位置分类：如果定义类在局部位置(方法中&#x2F;代码块) : (1) 局部内部类 &#x3D;&#x3D;(2) 匿名内部类&#x3D;&#x3D; 定义在成员位置 (1) 成员内部类 (2) 静态内部类 3.基本使用 12345678910111213141516171819package com.hspedu.innerclass;public class InnerClass01 &#123; //外部其他类public static void main(String[] args) &#123;&#125;&#125;class Outer &#123; //外部类private int n1 = 100;//属性public Outer(int n1) &#123;//构造器this.n1 = n1;&#125;public void m1() &#123;//方法System.out.println(&quot;m1()&quot;);&#125;&#123;//代码块System.out.println(&quot;代码块...&quot;);&#125;class Inner &#123; //内部类, 在 Outer 类的内部&#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"JavaWeb/3-自己总结的经验/1-JSON篇","date":"2022-11-10T13:36:01.318Z","updated":"2023-01-08T12:42:51.789Z","comments":true,"path":"2022/11/10/JavaWeb/3-自己总结的经验/1-JSON篇/","link":"","permalink":"https://jhfuture.github.io/2022/11/10/JavaWeb/3-%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93%E7%9A%84%E7%BB%8F%E9%AA%8C/1-JSON%E7%AF%87/","excerpt":"","text":"一、如何返回一个 带有 对象数组的 JSON 数据 先创建一个 Arraylist 挨个创建 JSONproject 把创建好的JSONproject 使用 ArrayList.add方法加入到 Arraylist中 将 ArrayList 加入 JSONProject中 12345678910111213141516171819202122231ArrayList&lt;JSONObject&gt; dataArrary=new ArrayList&lt;&gt;();//| bid | uid | publishtime | title | content | like | unlike | see | tagname //+-----+-----+---------------------+-------+---------+------+--------+------+---------//| 1 | 1 | 2022-11-10 20:00:00 | Nihao | nihao | 1 | 4 | 5 | hotkey //+-----+-----+---------------------+-------+---------+------+--------+------+---------+ while (resultSet_forBlog.next()) &#123; count++; 2 JSONObject jsonObject1 = new JSONObject(); jsonObject1.put(&quot;bid&quot;,resultSet_forBlog.getString(1)); jsonObject1.put(&quot;publishtime&quot;,resultSet_forBlog.getString(2)); jsonObject1.put(&quot;title&quot;,resultSet_forBlog.getString(3)); jsonObject1.put(&quot;content&quot;,resultSet_forBlog.getString(4)); jsonObject1.put(&quot;like&quot;,resultSet_forBlog.getString(5)); jsonObject1.put(&quot;unlike&quot;,resultSet_forBlog.getString(6)); jsonObject1.put(&quot;see&quot;,resultSet_forBlog.getString(7)); jsonObject1.put(&quot;tagname&quot;,resultSet_forBlog.getString(8)); 3 dataArrary.add(jsonObject1); &#125; jsonObject.put(&quot;code&quot;,100000); jsonObject.put(&quot;message&quot;,&quot;正常&quot;); 4 jsonObject.put(&quot;data&quot;,dataArrary); jsonObject.put(&quot;total&quot;,count); 二、前段如何传输 一个数组&#x2F;对象数组，让 servlet 可以直接使用 getParameter读取到使用 JSON 的序列化。 1234data:&#123;JSON.stringfy()&#125; 三、使用 axios post请求时， servlet 也无法直接通过 getparamter 方法获得参数使用 qs 模块将 请求数据转换为 form-data 12345&#123;data:qs.stringify&#125;","categories":[],"tags":[]},{"title":"mysqsl事务","slug":"MySQL/8-mysql事务/mysql事务","date":"2022-11-10T04:03:38.000Z","updated":"2022-11-13T14:01:15.607Z","comments":true,"path":"2022/11/10/MySQL/8-mysql事务/mysql事务/","link":"","permalink":"https://jhfuture.github.io/2022/11/10/MySQL/8-mysql%E4%BA%8B%E5%8A%A1/mysql%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"一、基本介绍​ 事务用于保证数据的&#x3D;&#x3D;一致性&#x3D;&#x3D;,它由&#x3D;&#x3D;一组相关的dml语句组成&#x3D;&#x3D;，该组的 dml 语句要么&#x3D;&#x3D;全部&#x3D;&#x3D;成功，要么&#x3D;&#x3D;全部&#x3D;&#x3D;失败。 如转账业务 事务的理解当有一个需求，需要多个操作一起完成 一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失 二、基本使用启动事务 123456789101112start transaction;---开始一个事务(这里会设置一个默认保存点)orSET AUTOCOMMIT=0savepoint 保存节点名--设置保存点rollback to 保存结点名 --回退到指定的保存结点()A--&gt;B---&gt;C注意：1.如果直接从 C 回退到 A 。那 A 之后的保存点会被全部删除。即不能再回滚到 B 了rollback --不加保存点名就直接回退全部事务操作commit --提交事务，所有操作生效，==不能回退== 三、注意的点","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jhfuture.github.io/categories/MySQL/"}],"tags":[{"name":"事务","slug":"事务","permalink":"https://jhfuture.github.io/tags/%E4%BA%8B%E5%8A%A1/"}]},{"title":"2-索引的入门","slug":"MySQL/7-MySQL索引/2-索引的基本介绍","date":"2022-11-09T13:32:32.000Z","updated":"2022-11-14T05:56:24.675Z","comments":true,"path":"2022/11/09/MySQL/7-MySQL索引/2-索引的基本介绍/","link":"","permalink":"https://jhfuture.github.io/2022/11/09/MySQL/7-MySQL%E7%B4%A2%E5%BC%95/2-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"一、类型 主键索引：如果某一列（字段）是主键，那它自然就是一个索引。 二、创建索引 1.主键 建表时创建CREATE TABLE &#x3D;&#x3D;表名&#x3D;&#x3D;(&#x3D;&#x3D;字段名&#x3D;&#x3D;INT PRIMARY KEY); 建表后创建ALTER TABLE &#x3D;&#x3D;表名&#x3D;&#x3D; ADD PRIMARY KEY (&#x3D;&#x3D;字段名&#x3D;&#x3D;); 1234-- 建表时创建CREATE TABLE t26( id INT PRIMARY KEY, `name` VARCHAR(32));ALTER TABLE t26 ADD PRIMARY KEY (id); 2. unique123CREATE UNIQUE INDEX id_index ON t26(`name`);ALTER TABLE t25 ADD UNIQUE(`name`); 3.普通索引CREATE INDEX 索引名 ON 表名(字段); or ALTER TABLE 表名 ADD INDEX 索引名(字段名); 12345678-- 创建普通索引CREATE INDEX id_index ON t25(id);-- 如何选择-- 1.如果某列的值不会重复则优先选择 unique 。否则 使用 普通索引。-- 添加普通方式二、ALTER TABLE t25 ADD INDEX id_index(id); 三、删除索引DROP INDEX 索引名 on 表名 1DROP INDEX id_index on t25; 删除主键索引 ALTER TABLE 表名 DROP PRIMARY KEY 四、修改索引删除，再添加即可。 五、查询索引方式一、SHOW INDEX FROM tableName; 方式二SHOW INDEXES FROM t26; 方式三SHOW KEYS FROM t26; 方式四DESC t26; 六、联系 七、小结 创建&#x3D;&#x3D;primary主键&#x3D;&#x3D;或&#x3D;&#x3D;unique&#x3D;&#x3D;，会自动创建其相应的索引。 创建了&#x3D;&#x3D;primary 主键索引&#x3D;&#x3D;或&#x3D;&#x3D;unique索引&#x3D;&#x3D;后，其对应的列（字段）会自动拥有其约束。（unique–&gt;唯一、主键-unique+not null 、） 八、老韩的小结","categories":[{"name":"mysql","slug":"mysql","permalink":"https://jhfuture.github.io/categories/mysql/"}],"tags":[{"name":"mysql索引","slug":"mysql索引","permalink":"https://jhfuture.github.io/tags/mysql%E7%B4%A2%E5%BC%95/"}]},{"title":"索引.md","slug":"MySQL/7-MySQL索引/1-索引的引出","date":"2022-11-09T13:07:57.000Z","updated":"2022-11-14T07:40:52.504Z","comments":true,"path":"2022/11/09/MySQL/7-MySQL索引/1-索引的引出/","link":"","permalink":"https://jhfuture.github.io/2022/11/09/MySQL/7-MySQL%E7%B4%A2%E5%BC%95/1-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BC%95%E5%87%BA/","excerpt":"","text":"索引的引出A1：没有索引为什么会慢？ Q1：因为全表扫描。 A2：使用索引为什么会快？ Q2：因为形成了一个索引的数据结构，比如二叉树。 索引的代价： 1.磁盘占用 2.对 dml（delete 、insert、update ） 语句 的效率影响（需要对索引进行维护）。 当没有索引时，1select * from emp where id=1; 即时它在第一行就找到了 id&#x3D;1的数据，但它不知道后面还有没有 id&#x3D;1 的数据，所以还是会进行 &#x3D;&#x3D;全表扫描&#x3D;&#x3D; 索引的原理——二叉树形成一个数据结构 —–二叉树（一种情况） 索引的优缺点优点缺点 占用内存。 对 dml( update delete insert )语句的效率影响。 修改了数据的话，会对原有的索引结构造成破坏，需要重新生成索引。—-&gt; 需要对&#x3D;&#x3D;索引进行维护&#x3D;&#x3D;。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://jhfuture.github.io/categories/mysql/"}],"tags":[{"name":"mysql索引的引出","slug":"mysql索引的引出","permalink":"https://jhfuture.github.io/tags/mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BC%95%E5%87%BA/"}]},{"title":"自增长","slug":"MySQL/12-mysql约束/auto_increase","date":"2022-11-09T12:11:00.000Z","updated":"2022-11-14T08:01:57.424Z","comments":true,"path":"2022/11/09/MySQL/12-mysql约束/auto_increase/","link":"","permalink":"https://jhfuture.github.io/2022/11/09/MySQL/12-mysql%E7%BA%A6%E6%9D%9F/auto_increase/","excerpt":"","text":"5.如果添加时制定了数据，那会以 指定的数据 开始。&#x3D;&#x3D;如果制定了自增长，一般来说就按照自增长的规则来添加数据。&#x3D;&#x3D; 但是 下一次自增长会自动 找到数据中的最大值进行 自增长。 6.修改默认的增长至： 12table 表明 auto_increment=100;从100开始","categories":[],"tags":[]},{"title":"mysqlcheck","slug":"MySQL/12-mysql约束/mysqlcheck","date":"2022-11-09T11:39:47.000Z","updated":"2022-11-10T04:06:27.230Z","comments":true,"path":"2022/11/09/MySQL/12-mysql约束/mysqlcheck/","link":"","permalink":"https://jhfuture.github.io/2022/11/09/MySQL/12-mysql%E7%BA%A6%E6%9D%9F/mysqlcheck/","excerpt":"","text":"check 约束what? 用于强制行数据必须满足的条件，假定 在 sal 列上定义了 check 约束，并且要求 sal 列值在1000~2000之间就会提示出错。 how 12345678类名 类型 check(check条件)-- check约束CREATE TABLE checkdb(id INT PRIMARY KEY, sal DOUBLE CHECK(sal &gt; 100 AND sal &lt; 2000));INSERT INTO checkdb VALUE(1,20);-- 报错Check constraint &#x27;checkdb_chk_1&#x27; is violated.","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jhfuture.github.io/categories/MySQL/"}],"tags":[{"name":"check","slug":"check","permalink":"https://jhfuture.github.io/tags/check/"}]},{"title":"mysql约束","slug":"MySQL/12-mysql约束/1-mysql约束","date":"2022-11-09T08:38:30.000Z","updated":"2023-01-15T14:59:10.697Z","comments":true,"path":"2022/11/09/MySQL/12-mysql约束/1-mysql约束/","link":"","permalink":"https://jhfuture.github.io/2022/11/09/MySQL/12-mysql%E7%BA%A6%E6%9D%9F/1-mysql%E7%BA%A6%E6%9D%9F/","excerpt":"","text":"约束 not null unique primary key foreign key check 一、主键what? ​ 用于唯一的表示表行的数据。当定义主键后，行不能重复。 how? 1234567定义方式1. 字段名 PRIMARY KEYCREATE TABLE a17 (id INT PRIMARY KEY);2. 在表定义最后写 PRIMARY KEY(列名)CREATE TABLE a178(id INT , `name` VARCHAR(32), PRIMARY KEY(id,`name`) ---复合主键 ); 特点： 主键的值不能重复 且 不能为&#x3D;&#x3D;null&#x3D;&#x3D;。 一张表只能有一个主键，但是可以是复合主键（把多个字段看成一个） 复合组件( id+name ) 的值不能相同。 1234CREATE TABLE a178(id INT , `name` VARCHAR(32), PRIMARY KEY(id,`name`) ---复合主键 );INSERT INTO a178 VALUES(1,&#x27;tom&#x27;); INSERT INTO a178 VALUES(1,&#x27;SICK&#x27;); ----合起来不同可以 INSERT INTO a178 VALUES(1,&#x27;tom&#x27;); -----合起来相同不行--Duplicate entry &#x27;1-tom&#x27; for key &#x27;a178.PRIMARY&#x27; 二、uniquewhat? ​ 不能重复的子弹 特点： 如果没有指定 not null ，则 unique 字段可以有多个 null 如果一个列（字段），是 unique not null 使用效果类似 primary key 一张表中可以有&#x3D;&#x3D;多个unique&#x3D;&#x3D; 三、外键what? ​ 定义主表和从表之间的关系：外键约束 how? 12345678910FOREIGN KEY (从表字段名)) REFERENCES 主表名(主表字段名));eg:-- 创建主表 my_classCREATE TABLE my_class(id INT PRIMARY KEY,`name` VARCHAR(32) NOT NULL DEFAULT &#x27;&#x27;);-- 创建从表 my_studentCREATE TABLE my_student(id INT PRIMARY KEY,`name` VARBINARY(32) NOT NULL DEFAULT &#x27;&#x27;,class_id INT,-- 下面指定外键关系FOREIGN KEY (class_id) REFERENCES my_class(id)); 外键约束案例： 1.这里的 300 会插入失败。 且： &#x3D;&#x3D;数据不能随意删除&#x3D;&#x3D; ​ 2.如果sn_002 中的class_id 和 id &#x3D;200 形成外键，那 班级表中 id&#x3D;200 这条记录不能直接删除。 需要先删除 sn_002 这个记录，再删除 班级表中 id&#x3D;200 的记录。 不能删除主键中 ， 在从表中的外键绑定了 的数据。 案例分析1234567891011121314151617181920INSERT INTO my_class VALUES(100,&quot;java&quot;),(200,&quot;web&quot;);SELECT * FROM my_class;+-----+------+| id | name |+-----+------+| 100 | java || 200 | web |+-----+------+2 rows in set (0.01 sec)INSERT INTO my_student VALUE(1,&quot;tom&quot;,100);INSERT INTO my_student VALUE(2,&quot;jack&quot;,200);INSERT INTO my_student VALUE(3,&quot;hsp&quot;,300); -- 这里会失败，因为 300班级不存在SELECT * FROM my_student;+----+------------+----------+| id | name | class_id |+----+------------+----------+| 1 | 0x746F6D | 100 || 2 | 0x6A61636B | 200 |+----+------------+----------+2 rows in set (0.00 sec) 要求： 主表中必须为主键或者 unique？ 外键指向的必须是唯一的。 表的类型是 innodb ，这样的表才能支持外键。 外键字段的类型要和主键字段的&#x3D;&#x3D;类型一致&#x3D;&#x3D;（长度可以不同）。 外键字段的值，必须在主段字段中出现过，或者为null【前提是外键字段允许为null] 12我一开始不知道这个学生将来是什么班级，那就为空INSERT INTO my_student VALUE4,&quot;hwc&quot;,null); 一旦建立主外键关系，数据就不能随意删除了。 上面的外键案例。 从表中有 外键 指向主表中的一条记录的字段，则该主表中的该条记录不能直接删除。 怎么解决？ 删除 从表中外键和 该主表记录有联系的 从表所有记录。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jhfuture.github.io/categories/MySQL/"}],"tags":[{"name":"sql约束","slug":"sql约束","permalink":"https://jhfuture.github.io/tags/sql%E7%BA%A6%E6%9D%9F/"}]},{"title":"mysql视图","slug":"MySQL/9-视图/1-视图的基本介绍","date":"2022-11-09T08:38:30.000Z","updated":"2022-11-14T07:12:28.822Z","comments":true,"path":"2022/11/09/MySQL/9-视图/1-视图的基本介绍/","link":"","permalink":"https://jhfuture.github.io/2022/11/09/MySQL/9-%E8%A7%86%E5%9B%BE/1-%E8%A7%86%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"基本介绍what? 从不同的角度查看同一个数据库 how? 123create view dept2_view as select * from dept2;#删除drop view dept2_view; 只有 DML 语句才能以 view 的形式创建。 create view view_name as 这里的语句必须为 DQL 语句 创建 view 的 SQL 语句，&#x3D;&#x3D;只能是 DQL&#x3D;&#x3D;。 123#复制表create table dept2 as select * from dept; why? ​ 为什么要使用视图。 ​ —-简化开发 假如有一条非常复杂的 SQL 语句，而这条 SQL 语句需要在不同的位置上&#x3D;&#x3D;反复使用&#x3D;&#x3D;。–这这条复杂的 sql 语句 写成一个视图。在需要编写这条 SQL 语句的位置直接使用视图对象，可以简化开发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107create view emp_dept_viewasselect e.ename,e.sal,d.dnamefrom emp ejoin dept dwhere e.deptno=d.deptno;一条对视图操作的 sql 语句，即可完成对两个表的操作mysql&gt; select * from dept;+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+4 rows in set (0.00 sec)mysql&gt; select * from emp;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+| 7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+------------+---------+---------+--------+14 rows in set (0.00 sec)## 展示mysql&gt; select * from emp_dept_view;+--------+---------+------------+| ename | sal | dname |+--------+---------+------------+| SMITH | 800.00 | RESEARCH || ALLEN | 1600.00 | SALES || WARD | 1250.00 | SALES || JONES | 2975.00 | RESEARCH || MARTIN | 1250.00 | SALES || BLAKE | 2850.00 | SALES || CLARK | 2450.00 | ACCOUNTING || SCOTT | 3000.00 | RESEARCH || KING | 5000.00 | ACCOUNTING || TURNER | 1500.00 | SALES || ADAMS | 1100.00 | RESEARCH || JAMES | 950.00 | SALES || FORD | 3000.00 | RESEARCH || MILLER | 1300.00 | ACCOUNTING |+--------+---------+------------+14 rows in set (0.00 sec)## 修改一个项# smith 的 sal 修改为900mysql&gt; update emp_dept_view set sal=900 where ename=&#x27;smith&#x27;;mysql&gt; select * from emp_dept_view;+--------+---------+------------+| ename | sal | dname |+--------+---------+------------+| SMITH | 900.00 | RESEARCH |----&gt;已经修改| ALLEN | 1600.00 | SALES || WARD | 1250.00 | SALES || JONES | 2975.00 | RESEARCH || MARTIN | 1250.00 | SALES || BLAKE | 2850.00 | SALES || CLARK | 2450.00 | ACCOUNTING || SCOTT | 3000.00 | RESEARCH || KING | 5000.00 | ACCOUNTING || TURNER | 1500.00 | SALES || ADAMS | 1100.00 | RESEARCH || JAMES | 950.00 | SALES || FORD | 3000.00 | RESEARCH || MILLER | 1300.00 | ACCOUNTING |+--------+---------+------------+#查看empmysql&gt; select * from emp;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+| 7369 | SMITH | CLERK | 7902 | 1980-12-17 | 900.00 | NULL | 20 | ----&gt; sal 已经被修改为900| 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 |+-------+--------+---------- 特点 对视图进行的增删改查，会导致原表被操作。 视图也是一个文件，可以看成一张表，即可以直接对其进行增删改查。 增删改查：CRUD C：create（增） R：retrive (查) U：update 改） D：delete（删）","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jhfuture.github.io/categories/MySQL/"}],"tags":[{"name":"sql视图","slug":"sql视图","permalink":"https://jhfuture.github.io/tags/sql%E8%A7%86%E5%9B%BE/"}]},{"title":"1-抽象列的入门","slug":"JAVA/5-面向对象(高级)/6-抽象类/1-抽象类的入门","date":"2022-11-08T10:38:01.000Z","updated":"2022-11-14T14:45:37.212Z","comments":true,"path":"2022/11/08/JAVA/5-面向对象(高级)/6-抽象类/1-抽象类的入门/","link":"","permalink":"https://jhfuture.github.io/2022/11/08/JAVA/5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E9%AB%98%E7%BA%A7)/6-%E6%8A%BD%E8%B1%A1%E7%B1%BB/1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、抽象类的介绍抽象类what? ​ 当用 一个 abstract 关键字来修饰一个类时，这个类就被称为 &#x3D;&#x3D;抽象类&#x3D;&#x3D; how? 123修饰符 abstract 类名&#123; &#125; 抽象方法what? ​ 当用 一个 abstract 关键字来修饰一个方法时，这个类就被称为 &#x3D;&#x3D;抽象方法&#x3D;&#x3D; 二、抽象类的注意事项 抽象类的 &#x3D;&#x3D;抽象方法一定要被子类实现&#x3D;&#x3D;or&#x3D;&#x3D;子类也是抽象类&#x3D;&#x3D;。 抽象类不能被实例化 有抽象方法的类一定是抽象方法，但抽象类不一定有抽象方法。 abstract 只能修饰类和方法 抽象类可以有类的任何成员。&#x3D;&#x3D;【其本质还是类】&#x3D;&#x3D; 抽象方法不能有方法主体 抽象方法不能使用 private、final 和 static 来修饰。 private ：子类无法访问改父类方法，也就无法完成对此方法进行重写。 final 修饰的方法不能被重写，但在子类中必须对抽象方法进行重写。 static ：静态方法本身就不能被覆盖 重写是子类对&#x3D;&#x3D;父类的允许访问的方法&#x3D;&#x3D;的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 三、应用１． 模块设计模式 需求： 答案： １. 写一个父类。然后让 dojob 方法成为抽象方法，子类实现它，并在里面写子类做的事情 12345678910abstract class test&#123;public long calculateTime()&#123; long start = System.currentTimeMillis(); dojob(); long end = System.currentTimeMillis(); long total=end-start; return total;&#125;public abstract void dojob();&#125; 2.子类 123456789class bbb extends test&#123; @Override public void dojob() &#123; for (int i = 0; i &lt; 1000; i++) &#123; &#125; &#125;&#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://jhfuture.github.io/categories/JAVA/"}],"tags":[{"name":"抽象类","slug":"抽象类","permalink":"https://jhfuture.github.io/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"}]},{"title":"注入","slug":"JAVA/JDBC与连接池/3-SQL注入","date":"2022-11-08T10:34:08.000Z","updated":"2022-11-08T14:05:09.105Z","comments":true,"path":"2022/11/08/JAVA/JDBC与连接池/3-SQL注入/","link":"","permalink":"https://jhfuture.github.io/2022/11/08/JAVA/JDBC%E4%B8%8E%E8%BF%9E%E6%8E%A5%E6%B1%A0/3-SQL%E6%B3%A8%E5%85%A5/","excerpt":"","text":"一、简要介绍 statement 是一个接口 SQL 注入及 为什么使用 preparedStatemnet 二、解决办法。PreparedStatement","categories":[],"tags":[]},{"title":"注入","slug":"JAVA/JDBC与连接池","date":"2022-11-08T10:33:49.000Z","updated":"2022-11-28T08:12:43.991Z","comments":true,"path":"2022/11/08/JAVA/JDBC与连接池/","link":"","permalink":"https://jhfuture.github.io/2022/11/08/JAVA/JDBC%E4%B8%8E%E8%BF%9E%E6%8E%A5%E6%B1%A0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"JavaWeb/libs/JSONObject","date":"2022-11-08T05:16:53.583Z","updated":"2022-11-08T05:17:58.589Z","comments":true,"path":"2022/11/08/JavaWeb/libs/JSONObject/","link":"","permalink":"https://jhfuture.github.io/2022/11/08/JavaWeb/libs/JSONObject/","excerpt":"","text":"一、下载地址二、怎么使用创建对象 JSONObjec jsonobect&#x3D; new JSONObject() 添加数据 jsonobject.put(key,value);","categories":[],"tags":[]},{"title":"","slug":"JavaWeb/libs/javamail","date":"2022-11-08T05:13:09.037Z","updated":"2022-11-08T05:16:34.335Z","comments":true,"path":"2022/11/08/JavaWeb/libs/javamail/","link":"","permalink":"https://jhfuture.github.io/2022/11/08/JavaWeb/libs/javamail/","excerpt":"","text":"下载地址 github地址 参考案例csdn博客 发送文本 &#96;&#96;&#96;javaimport javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import java.util.Date;import java.util.Properties; &#x2F;** Description: Date: 2020&#x2F;5&#x2F;27 - 下午 1:14 author: wangkanglu version: V1.0 *&#x2F;public class TestEmailUtil { public static void main(String[] args) throws Exception { &#x2F;&#x2F; 发件人的 邮箱 和 密码（替换为自己的邮箱和密码） String myEmailAccount &#x3D; “”; &#x2F;&#x2F; PS: 某些邮箱服务器为了增加邮箱本身密码的安全性，给 SMTP 客户端设置了独立密码（有的邮箱称为“授权码”）, &#x2F;&#x2F; 对于开启了独立密码的邮箱, 这里的邮箱密码必需使用这个独立密码（授权码）。 String myEmailPassword &#x3D; “”; &#x2F;&#x2F; 发件人邮箱的 SMTP 服务器地址, 必须准确, 不同邮件服务器地址不同, 一般(只是一般, 绝非绝对)格式为: smtp.xxx.com &#x2F;&#x2F;如；163邮箱是smtp.163.com，qq邮箱是smtp.qq.com。 String myEmailSMTPHost &#x3D; “smtp.qq.com”; &#x2F;&#x2F; 收件人邮箱（替换为自己知道的有效邮箱） String receiveMailAccount &#x3D; “ “; &#x2F;&#x2F; 1. 创建参数配置, 用于连接邮件服务器的参数配置 &#x2F;&#x2F; 参数配置类 Properties props &#x3D; new Properties(); &#x2F;&#x2F; 使用的协议（JavaMail规范要求） props.setProperty(“mail.transport.protocol”, “smtp”); &#x2F;&#x2F; 发件人的邮箱的 SMTP 服务器地址 props.setProperty(“mail.smtp.host”, myEmailSMTPHost); &#x2F;&#x2F; 需要请求认证 props.setProperty(“mail.smtp.auth”, “true”); &#x2F;&#x2F;某些邮箱服务器要求 SMTP 连接需要使用 SSL 安全认证 (为了提高安全性, 邮箱支持SSL连接, 也可以自己开启), &#x2F;&#x2F;如果无法连接邮件服务器, 仔细查看控制台打印的 log, 如果有有类似 “连接失败, 要求 SSL 安全连接” 等错误, &#x2F;&#x2F;打开下面 注释之间的注释代码, 开启 SSL 安全连接。 &#x2F;&#x2F;SMTP 服务器的端口 (非 SSL 连接的端口一般默认为 25, 可以不添加, 如果开启了 SSL 连接, &#x2F;&#x2F; 需要改为对应邮箱的 SMTP 服务器的端口, 具体可查看对应邮箱服务的帮助, &#x2F;&#x2F; QQ邮箱的SMTP(SLL)端口为465或587, 其他邮箱自行去查看) &#x2F;&#x2F; final String smtpPort &#x3D; “465”;&#x2F;&#x2F; props.setProperty(“mail.smtp.port”, smtpPort);&#x2F;&#x2F; props.setProperty(“mail.smtp.socketFactory.class”, “javax.net.ssl.SSLSocketFactory”);&#x2F;&#x2F; props.setProperty(“mail.smtp.socketFactory.fallback”, “false”);&#x2F;&#x2F; props.setProperty(“mail.smtp.socketFactory.port”, smtpPort); // 2. 根据配置创建会话对象, 用于和邮件服务器交互 Session session = Session.getInstance(props); // 设置为debug模式, 可以查看详细的发送 log session.setDebug(true); // 3. 创建一封邮件即邮件对象 MimeMessage message = createMimeMessage(session, myEmailAccount, receiveMailAccount); // 4. 根据 Session 获取邮件传输对象 Transport transport = session.getTransport(); // 5. 使用 邮箱账号 和 密码 连接邮件服务器, 这里认证的邮箱必须与 message 中的发件人邮箱一致, 否则报错 // // PS_01: 成败的判断关键在此一句, 如果连接服务器失败, 都会在控制台输出相应失败原因的 log, // 仔细查看失败原因, 有些邮箱服务器会返回错误码或查看错误类型的链接, 根据给出的错误 // 类型到对应邮件服务器的帮助网站上查看具体失败原因。 // // PS_02: 连接失败的原因通常为以下几点, 仔细检查代码: // (1) 邮箱没有开启 SMTP 服务; // (2) 邮箱密码错误, 例如某些邮箱开启了独立密码; // (3) 邮箱服务器要求必须要使用 SSL 安全连接; // (4) 请求过于频繁或其他原因, 被邮件服务器拒绝服务; // (5) 如果以上几点都确定无误, 到邮件服务器网站查找帮助。 // // PS_03: 仔细看log, 认真看log, 看懂log, 错误原因都在log已说明。 transport.connect(myEmailAccount, myEmailPassword); // 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人 transport.sendMessage(message, message.getAllRecipients()); // 7. 关闭连接 transport.close(); &#125; /** * 创建一封只包含文本的简单邮件 * * @param session 和服务器交互的会话对象 * @param sendMail 发件人邮箱 * @param receiveMail 收件人邮箱 * @return * @throws Exception */ public static MimeMessage createMimeMessage(Session session, String sendMail, String receiveMail) throws Exception &#123; // 1. 创建一封邮件 MimeMessage message = new MimeMessage(session); // 2. From: 发件人（昵称有广告嫌疑，避免被邮件服务器误认为是滥发广告以至返回失败，请修改昵称） message.setFrom(new InternetAddress(sendMail, &quot;昵称&quot;, &quot;UTF-8&quot;)); // 3. To: 收件人（可以增加多个收件人、抄送、密送） message.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(receiveMail, &quot;&quot;, &quot;UTF-8&quot;)); // 4. Subject: 邮件主题 message.setSubject(&quot;测试发邮件&quot;, &quot;UTF-8&quot;); // 5. Content: 邮件正文（可以使用html标签） message.setContent(&quot;邮件内容&quot;, &quot;text/html;charset=UTF-8&quot;); // 6. 设置发件时间 message.setSentDate(new Date()); // 7. 保存设置 message.saveChanges(); return message; &#125; }","categories":[],"tags":[]},{"title":"","slug":"JAVA/JDBC与连接池/1-api详解","date":"2022-11-05T12:32:04.638Z","updated":"2022-11-05T16:42:00.901Z","comments":true,"path":"2022/11/05/JAVA/JDBC与连接池/1-api详解/","link":"","permalink":"https://jhfuture.github.io/2022/11/05/JAVA/JDBC%E4%B8%8E%E8%BF%9E%E6%8E%A5%E6%B1%A0/1-api%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"DriverManager:1.注册驱动 2.获取连接 1. 2. 解决ssl报错 在路径后面添加 useSSL&#x3D;false Connectiona)获取 SQL 对象 b)事物管理。 获取SQL 对象 事物管理 setAutoCommit() 需要传入 FALSE 才能是手动开启事物","categories":[],"tags":[]},{"title":"","slug":"JAVA/JDBC与连接池/0一览大纲","date":"2022-11-05T10:29:46.150Z","updated":"2022-11-05T13:31:01.403Z","comments":true,"path":"2022/11/05/JAVA/JDBC与连接池/0一览大纲/","link":"","permalink":"https://jhfuture.github.io/2022/11/05/JAVA/JDBC%E4%B8%8E%E8%BF%9E%E6%8E%A5%E6%B1%A0/0%E4%B8%80%E8%A7%88%E5%A4%A7%E7%BA%B2/","excerpt":"","text":"一、JDBC的概述 原理图 二、第一个jdbc 基本介绍 开始 安装驱动 —将 jar 包放入 project 的 libs 文件目录下 ，然后右键 add as library 安装驱动的另一种方法，添加classpath系统变量(这个配置时针对文本编辑器，使用 idea 不用此配置) 1234classpath:&#x27;.;你的mysql-connect-java.jar包的路径&#x27;//为什么要配置 . ---&gt;当前路径# 如果不配置的话，当你想在当前路径执行编译完的.class文件执行的时候它将会直接到你设置的 mysqlxxxx 那个路径去找 编写案例1234561.连接驱动jdbc五以上用这个String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;//jdbc驱动jdbc五以前String driver = &quot;com.mysql.jdbc.Driver&quot;;Class.forName(drive)","categories":[],"tags":[]},{"title":"","slug":"JavaWeb/处理中文乱码/处理中文乱码","date":"2022-11-03T11:51:36.188Z","updated":"2022-11-07T15:57:13.311Z","comments":true,"path":"2022/11/03/JavaWeb/处理中文乱码/处理中文乱码/","link":"","permalink":"https://jhfuture.github.io/2022/11/03/JavaWeb/%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","excerpt":"","text":"处理 post 方法的乱码 1234request.setCharacterEncoding(&quot;UTF-8&quot;);//处理post的乱码//必须在所有的获取参数动作之前 处理get方法 (Tomcat8之前 ) 123456789get方式下目前不需要设置编码(基于Tomcat8) /*Tomcat 8之前的处理方式 * String fname = request.getParameter(&quot;fname&quot;); *1.将字符串打散成字节数组 *byte[] bytes = fname.getBytes(&quot;ISO-8859-1&quot;); * 2.将字符数组按照设定的编码重新组装成字符串 *fname=new String(bytes,&quot;UTF-8&quot;); * * */ 注意： ​ 设置编码必须在所有的获取参数动作之前","categories":[],"tags":[]},{"title":"1-作用域基本介绍","slug":"JAVA/3-面向对象/7-作用域/1-作用域基本介绍","date":"2022-11-03T08:25:50.000Z","updated":"2022-12-19T15:36:28.049Z","comments":true,"path":"2022/11/03/JAVA/3-面向对象/7-作用域/1-作用域基本介绍/","link":"","permalink":"https://jhfuture.github.io/2022/11/03/JAVA/3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7-%E4%BD%9C%E7%94%A8%E5%9F%9F/1-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"一、基本使用一、在 java 编程中，主要的变量就是 属性（成员变量）和局部变量。 二、我们说的局部变量一般是指成员方法中定义的变量（同时方法块中的变量也是属于局部变量） 三、java 中作用域的分类： 全局变量: ​ 也就是属性，作用域为&#x3D;&#x3D;整个类体&#x3D;&#x3D;。在类成员(属性、方法、方法块、内部类)中都可以访问 局部变量：也就是除了属性之外的其他变量，作用域为&#x3D;&#x3D;定义它的代码块中&#x3D;&#x3D; 四、&#x3D;&#x3D;全局变量（属性）&#x3D;&#x3D;可以不赋值，直接使用，因为其有 &#x3D;&#x3D;默认值&#x3D;&#x3D;。 ​ 而​ 成员变量必须进行赋值，才能使用，因为其&#x3D;&#x3D;没有默认值&#x3D;&#x3D;​ String 类型无论是全局变量还是局部变量，如果没有初始化，那值都为 “null” ，不可以使用 name.equal()方法，否则有&#x3D;&#x3D;nullPointException&#x3D;&#x3D;空指针异常。 二、注意的点 访问的就近原则如果局部变量和成员变量（属性）有重名，则在方法块中会优先访问 局部变量。 重新定义的问题：2.1如果局部变量重新对成员变量进行了定义，则方法体内访问的将是局部变量。如果没有重新定义，而是修改数值，则访问的还是成员变量。2.2在同一个作用域中，&#x3D;&#x3D;不能定义 同名的两个变量&#x3D;&#x3D; 生命周期：属性（成员变量）的生命周期较长，伴随对象的创建而创建，伴随着对象的销毁而销毁。而局部变量的生命周期较短，伴随代码块的执行而创建，伴随代码块的结束而销毁。 访问范围的问题：4.1全局变量可以被其他类访问—-&gt; 对象名.parameterName4.2全局变量可以添加修饰符，局部变量不可以。 在方法的方法块内，&#x3D;&#x3D;不可以重新定义&#x3D;&#x3D;和方法内 &#x3D;&#x3D;同名的变量&#x3D;&#x3D; 12345678 public void hello()&#123; int x=10; &#123; int x=20; &#125; &#125;&#125;&gt;报错","categories":[],"tags":[]},{"title":"","slug":"JAVA/3-面向对象/7-作用域/1-基本使用","date":"2022-11-03T08:23:53.061Z","updated":"2022-11-03T08:23:53.061Z","comments":true,"path":"2022/11/03/JAVA/3-面向对象/7-作用域/1-基本使用/","link":"","permalink":"https://jhfuture.github.io/2022/11/03/JAVA/3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7-%E4%BD%9C%E7%94%A8%E5%9F%9F/1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"饿汉模式","slug":"JAVA/5-面向对象(高级)/4-单例设计模式/1-饿汉模式","date":"2022-11-03T05:31:33.000Z","updated":"2022-11-03T07:57:46.067Z","comments":true,"path":"2022/11/03/JAVA/5-面向对象(高级)/4-单例设计模式/1-饿汉模式/","link":"","permalink":"https://jhfuture.github.io/2022/11/03/JAVA/5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E9%AB%98%E7%BA%A7)/4-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1-%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"Runtime 饿汉模式 饿汉 在对象加载时就创建对象 可能存在资源量浪费问题 懒汉 在调用 getInstance 才会创建 有线程安全问题 一、饿汉123456789101112131415161718192021222324252627282930package com.jhfuture.single_;public class SingleTon01 &#123; public static void main(String[] args) &#123;/** 饿汉模式 ---&gt;只能有一个对象* 1.构造器私有化 》防止直接 new* 2.类的内部创建对象* 3.向外暴露一个 getInstance方法。* */ System.out.println(GirlFriend.getInstance()); System.out.println(GirlFriend.getInstance()); &#125;&#125; class GirlFriend&#123; private String name; private static GirlFriend girlFriend = new GirlFriend(&quot;小谭&quot;); public static GirlFriend getInstance()&#123; return girlFriend; &#125; private GirlFriend(String name)&#123; this.name=name; &#125;&#125; 二、懒汉1234567891011121314151617181920212223242526272829package com.jhfuture.single_;//懒汉模式//public class singleTon2 &#123; public static void main(String[] args) &#123; System.out.println(Cat.getInstance()); &#125;&#125;class Cat&#123; static Cat cat; static int age=99; private String name; public static Cat getInstance()&#123; if (cat==null)&#123; cat=new Cat(&quot;小红&quot;); &#125; return cat; &#125; public Cat(String name) &#123; System.out.println(&quot;调用了&quot;); this.name = name; &#125; @Override public String toString() &#123; return name; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://jhfuture.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jhfuture.github.io/tags/Java/"}]},{"title":"代码块","slug":"JAVA/5-面向对象(高级)/3-代码块/1-基本介绍","date":"2022-11-03T02:31:33.000Z","updated":"2022-11-24T12:52:41.367Z","comments":true,"path":"2022/11/03/JAVA/5-面向对象(高级)/3-代码块/1-基本介绍/","link":"","permalink":"https://jhfuture.github.io/2022/11/03/JAVA/5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E9%AB%98%E7%BA%A7)/3-%E4%BB%A3%E7%A0%81%E5%9D%97/1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"一、基本介绍​ a) 代码块又称为&#x3D;&#x3D;初始化快&#x3D;&#x3D;，属于类中的成员(即 是类的一部分)，类似于方法，讲逻辑语句封装在方法体重，通过 {} 包裹起来。但和方法不一样，其没有方法名，没有返回值，没有参数，只有方法体，而且不用通过对象或类显示调用，而是&#x3D;&#x3D;加载类&#x3D;&#x3D;时，或在创建对象时隐式调用。 ​ b)能干嘛： 相当于另一种形式的构造器(对构造器的补充)，可以加入初始化的代码。场景：多个构造器中都有重复的语句，可以将其抽取出来，放到 &#x3D;&#x3D;代码块&#x3D;&#x3D;中，提高代码的复用性 二、基本语法1234[修饰符]&#123; 方法体&#125;; 注意: 1)修饰符 可选，只能写static 2)代码块分为两类，使用 static 修饰的称为静态代码块，没有static 修饰的，称为 普通代码块&#x2F;非静态代码块。 3)逻辑语句可以为任何语句 (输入、输出、方法调用、循环、判断等) 4);号可选 三、代码块的使用注意事项 static 代码块也叫 &#x3D;&#x3D;静态代码块&#x3D;&#x3D;，它随 &#x3D;&#x3D;类的加载&#x3D;&#x3D;而执行，并且&#x3D;&#x3D;只会执行一次&#x3D;&#x3D;,如果是普通代码块(即没有 static 修饰)，则每创建一个对象，就会执行一次。 类什么时候被加载 创建对象实例时(即 使用 new ) 创建子类对象实例时，父类也会被加载！—-&gt; 首先加载类信息&#x3D;&#x3D;从父类开始逐级向下&#x3D;&#x3D;&gt;GrandPa信息–&gt; Father—-&gt;son 在堆中开辟 内存空间 —-&gt; 储存GrandPa—&gt;储存 Father—&gt;储存son 使用类的 &#x3D;&#x3D;静态成员&#x3D;&#x3D;(静态属性、静态方法) 普通代码块：在创建对象实例时，会被&#x3D;&#x3D;隐式的调用&#x3D;&#x3D;，对象实例被创建一次，就会创建一次。(每一个new的出现，都会有一个普通代码块被拉出来毒打)。但如果是 &#x3D;&#x3D;使用类的静态成员&#x3D;&#x3D;，则它不会干活。 小结： 1. static 代码块是 ==**类加载**==时进行，只会执行一次。 1. 普通代码块是在 创建对象 时调用，有一个对象被创建就调用一次。 1. 类加载的三种情况需要记住 四、案例分析理解 静态代码块、代码块、构造器的执行过程。 单个类的执行过程分析123456789101112131415161718192021class signle&#123; private static int n1=getN1(); public static int getN1()&#123; System.out.println(&quot;静态变量初始化&quot;); return 100; &#125; static &#123; System.out.println(&quot;静态代码块初始化&quot;); &#125; private int n2=getN2(); public int getN2()&#123; System.out.println(&quot;普通变量初始化&quot;); return 200; &#125; //1.先加载类信息，即初始化静态代码块和静态变量 public signle() &#123;// 默认的super()调用父类 //调用普通方法块和 初始化普通变量 //构造器方法 &#125;&#125; 综合案例 创建一个&#x3D;&#x3D;具有继承关系的类的对象&#x3D;&#x3D; 从继承关系开始&#x3D;&#x3D;加载类的信息&#x3D;&#x3D;（从父类开始)。 父类的静态代码和属性初始化（优先级一样，按定义的顺序执行) 子类的静态代码和属性初始化（优先级一样，按定义的顺序执行) 父类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行) 父类的构造函数 子类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行) 子类的构造函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class CodeBlockDetail04 &#123;public static void main(String[] args) &#123;//老师说明//(1) 进行类的加载//1.1 先加载 父类 A02 1.2 再加载 B02//(2) 创建对象//2.1 从子类的构造器开始//new B02();//对象new C02();&#125;&#125;class A02 &#123; //父类private static int n1 = getVal01();static &#123;System.out.println(&quot;A02 的一个静态代码块..&quot;);//(2)&#125;&#123;System.out.println(&quot;A02 的第一个普通代码块..&quot;);//(5)&#125;public int n3 = getVal02();//普通属性的初始化public static int getVal01() &#123;System.out.println(&quot;getVal01&quot;);//(1)return 10;&#125;public int getVal02() &#123;System.out.println(&quot;getVal02&quot;);//(6)return 10;&#125;public A02() &#123;//构造器//隐藏//super()//普通代码和普通属性的初始化...... System.out.println(&quot;A02 的构造器&quot;);//(7)&#125;&#125;class C02 &#123;private int n1 = 100;private static int n2 = 200;private void m1() &#123;&#125;private static void m2() &#123;&#125;static &#123;//静态代码块，只能调用静态成员//System.out.println(n1);错误System.out.println(n2);//ok//m1();//错误m2();&#125;&#123;//普通代码块，可以使用任意成员System.out.println(n1);System.out.println(n2);//okm1();m2();&#125;&#125;class B02 extends A02 &#123; //private static int n3 = getVal03();static &#123;System.out.println(&quot;B02 的一个静态代码块..&quot;);//(4)&#125;public int n5 = getVal04();&#123;System.out.println(&quot;B02 的第一个普通代码块..&quot;);//(9)&#125;public static int getVal03() &#123;System.out.println(&quot;getVal03&quot;);//(3)return 10;&#125;public int getVal04() &#123;System.out.println(&quot;getVal04&quot;);//(8)return 10;&#125;//一定要慢慢的去品.. public B02() &#123;//构造器//隐藏了//super()//普通代码块和普通属性的初始化... System.out.println(&quot;B02 的构造器&quot;);//(10)// TODO Auto-generated constructor stub&#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://jhfuture.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jhfuture.github.io/tags/Java/"}]},{"title":"3-servlet整个类系.md","slug":"JavaWeb/servlet/5-ServletContext","date":"2022-11-01T14:19:45.000Z","updated":"2022-11-01T14:20:20.306Z","comments":true,"path":"2022/11/01/JavaWeb/servlet/5-ServletContext/","link":"","permalink":"https://jhfuture.github.io/2022/11/01/JavaWeb/servlet/5-ServletContext/","excerpt":"","text":"一、简要介绍","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://jhfuture.github.io/categories/JavaWeb/"},{"name":"Servlet","slug":"JavaWeb/Servlet","permalink":"https://jhfuture.github.io/categories/JavaWeb/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://jhfuture.github.io/tags/Servlet/"}]},{"title":"3-servlet整个类系.md","slug":"JavaWeb/servlet/4-ServletConfig","date":"2022-11-01T13:13:10.000Z","updated":"2022-11-01T14:14:23.106Z","comments":true,"path":"2022/11/01/JavaWeb/servlet/4-ServletConfig/","link":"","permalink":"https://jhfuture.github.io/2022/11/01/JavaWeb/servlet/4-ServletConfig/","excerpt":"","text":"一、ServltConfig 三大作用12345678910111213public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2 int初始化&quot;);// 1. 可以获取servlet程序的别名 System.out.println(&quot;HelloServlet程序的别名是&quot; + servletConfig.getServletName());// 2. 获取初始化参数 Init-param System.out.println(&quot;初始化参数username的值是&quot;+servletConfig.getInitParameter(&quot;username&quot;)); //2.2可以配置多个 System.out.println(&quot;初始化参数url的值是&quot;+servletConfig.getInitParameter(&quot;url&quot;)); //3.获取 ServletContext 对象 System.out.println(&quot;ServletContext对象是&quot;+servletConfig.getServletContext()); &#125; ​ servlet 程序和 servletConfig 对象都是由 Tomcat 负责创建，我们负责使用。 ​ Servlet 程序默认是第一次访问的时候创建，ServletConfig 是每个 servlet 程序创建时，就创建一个对应的 servletConfig 对象 ​ 二、servlet 的注意 在本 servlet 中只能获取到 本 servlet 的数据 getServletConfig 方法是父类 GenericServlet的方法，在本方法中可以直接使用 —&gt; GenericServlet 中 init 方法实现了对 config 对象的存储，如果在自定义的类中 重写该方法，则需要调用 一下 GenericServlet 中的 init 方法，否则。 &#x3D;&#x3D;getServletConfig&#x3D;&#x3D; 方法就会报错12345678public void init(ServletConfig config) throws ServletException &#123; this.config = config; this.init(); &#125; // init 方法对 config 进行了存储, getservletconfig 只是获取后进行返回.public ServletConfig getServletConfig() &#123; return this.config; &#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://jhfuture.github.io/categories/JavaWeb/"},{"name":"Servlet","slug":"JavaWeb/Servlet","permalink":"https://jhfuture.github.io/categories/JavaWeb/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://jhfuture.github.io/tags/Servlet/"}]},{"title":"3-servlet整个类的继承体系.md","slug":"JavaWeb/servlet/3-servlet整个类的继承体系","date":"2022-11-01T13:10:33.000Z","updated":"2022-11-03T12:31:31.865Z","comments":true,"path":"2022/11/01/JavaWeb/servlet/3-servlet整个类的继承体系/","link":"","permalink":"https://jhfuture.github.io/2022/11/01/JavaWeb/servlet/3-servlet%E6%95%B4%E4%B8%AA%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB/","excerpt":"","text":"","categories":[{"name":"Javaweb","slug":"Javaweb","permalink":"https://jhfuture.github.io/categories/Javaweb/"},{"name":"Servlet","slug":"Javaweb/Servlet","permalink":"https://jhfuture.github.io/categories/Javaweb/Servlet/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"https://jhfuture.github.io/tags/servlet/"}]},{"title":"2-servlet一般使用场景.md","slug":"JavaWeb/servlet/2-servlet一般使用","date":"2022-11-01T12:18:48.000Z","updated":"2022-11-01T13:11:22.600Z","comments":true,"path":"2022/11/01/JavaWeb/servlet/2-servlet一般使用/","link":"","permalink":"https://jhfuture.github.io/2022/11/01/JavaWeb/servlet/2-servlet%E4%B8%80%E8%88%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"方法一、 编写一个类去继承 HttpServlet 类 根据业务需要重写 doGet 或 doGet方法 去 web.xml 中去配置 servlet 程序的访问地址 方法二、使用idea生成 使用idea生成，生成后会在 创建 class 文件，同时在 web.xml 文件中添加 servlet 项 (没有servlet -mapping，需要手动配置）。配置 servlet 信息 配置web.xml 中的 servlet-mapping","categories":[{"name":"Javaweb","slug":"Javaweb","permalink":"https://jhfuture.github.io/categories/Javaweb/"},{"name":"Servlet","slug":"Javaweb/Servlet","permalink":"https://jhfuture.github.io/categories/Javaweb/Servlet/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"https://jhfuture.github.io/tags/servlet/"}]},{"title":"2-servlet一般使用场景.md","slug":"JavaWeb/servlet/1-servlet的生命周期","date":"2022-11-01T12:17:48.000Z","updated":"2022-12-10T14:17:29.780Z","comments":true,"path":"2022/11/01/JavaWeb/servlet/1-servlet的生命周期/","link":"","permalink":"https://jhfuture.github.io/2022/11/01/JavaWeb/servlet/1-servlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"简要介绍​ servlet 与其他函数相同，亦有自己的生命周期。 ​ servlet 是 webapp 和 webserver 通讯的协议 遵循 servlet 规范的 webapp ，这个 webapp 就可以放在不同的 web 服务器中运行(因为这个 webapp 是遵循 servlet 规范的) servlet规范包括什么？ 规范了哪些接口 规范了哪些类 规范了 webapp 应用应该有哪些配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.jhfuture.servlet;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;/** 1.执行 servlet 构造方法* 2.执行init 方法* 第一、二步只有在servlet程序创建的时候调用* 3.service方法* 第三部，每次访问都会调用* 4.destroy方法*第四部，在web工程停止的时候调用** service方法每次* */public class HelloServlet implements Servlet &#123; public HelloServlet() &#123; System.out.println(&quot;1.构造器方法&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2 int初始化&quot;); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override /* * service 方法是专门用来处理请求和响应 * */ public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;3.service方法&quot;); /* * 区分 post 和 get * */ // 类型转换（因为它有getmethod方法） HttpServletRequest httpServletRequest=(HttpServletRequest) servletRequest; //获取请求的方式 String method = httpServletRequest.getMethod(); System.out.println(method); if (method.equals(&quot;POST&quot;))&#123;// System.out.println(&quot;post&quot;); doPost(); &#125;else if (method.equals(&quot;GET&quot;))&#123;// System.out.println(&quot;get&quot;); doGet(); &#125; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;4.destroy方法&quot;); &#125; public void doGet()&#123; System.out.println(&quot;GET请求&quot;); &#125; public void doPost()&#123; System.out.println(&quot;Post请求&quot;); &#125;&#125; 开发一个 带有 servlet(java 小程序) 的webapp开发步骤 第六步：编写一个java程序，这个小程序必须实现 servlet 接口 这个 servlet 解控不在 jdk 当中。 servlet 解控 servlet 接口是 javaee 的规范中的一员。 关于javaEE 的版本 解决Tomcat服务器在DOS命令窗口中的乱码问题(控制台乱码) 向浏览器响应一段html代码二、servlet 中 web.xml文件的配置12public String getInitParameter(String name); // 通过初始化参数的name获取valuepublic Enumeration&lt;String&gt; getInitParameterNames(); // 获取所有的初始化参数的name 1234567891011&lt;!--以上两个方法是ServletContext对象的方法，这个方法获取的是什么信息？是以下的配置信息--&gt;&lt;context-param&gt; &lt;param-name&gt;pageSize&lt;/param-name&gt; &lt;param-value&gt;10&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt; &lt;param-name&gt;startIndex&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--注意：以上的配置信息属于 应用级的配置信息，一般一个项目中共享的配置信息会放到以上的标签当中。--&gt;&lt;!--如果你的配置信息只是想给某一个servlet作为参考，那么你配置到servlet标签当中即可，使用ServletConfig对象来获取。--&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://jhfuture.github.io/categories/JavaWeb/"},{"name":"Servlet","slug":"JavaWeb/Servlet","permalink":"https://jhfuture.github.io/categories/JavaWeb/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://jhfuture.github.io/tags/Servlet/"}]},{"title":"","slug":"JavaWeb/servlet/0-一些错误/Untitled 1","date":"2022-11-01T12:17:23.486Z","updated":"2022-11-01T12:17:23.486Z","comments":true,"path":"2022/11/01/JavaWeb/servlet/0-一些错误/Untitled 1/","link":"","permalink":"https://jhfuture.github.io/2022/11/01/JavaWeb/servlet/0-%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF/Untitled%201/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"JavaWeb/servlet/0-一些错误/Untitled","date":"2022-11-01T12:17:23.476Z","updated":"2022-11-01T12:17:23.476Z","comments":true,"path":"2022/11/01/JavaWeb/servlet/0-一些错误/Untitled/","link":"","permalink":"https://jhfuture.github.io/2022/11/01/JavaWeb/servlet/0-%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF/Untitled/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"JavaWeb/servlet/0-一些错误/1-","date":"2022-10-30T13:51:27.434Z","updated":"2022-10-30T13:54:00.502Z","comments":true,"path":"2022/10/30/JavaWeb/servlet/0-一些错误/1-/","link":"","permalink":"https://jhfuture.github.io/2022/10/30/JavaWeb/servlet/0-%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF/1-/","excerpt":"","text":"url-pattern 配置的路径没有以 斜杠 “&#x2F;“ 打头 servlet-name 配置的值不存在 servlet-class 标签的全类名配置错误","categories":[],"tags":[]},{"title":"1-JDBC概述.md","slug":"MySQL/JDBC/1-JDBC概述","date":"2022-10-30T13:13:11.000Z","updated":"2022-10-30T13:13:48.298Z","comments":true,"path":"2022/10/30/MySQL/JDBC/1-JDBC概述/","link":"","permalink":"https://jhfuture.github.io/2022/10/30/MySQL/JDBC/1-JDBC%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://jhfuture.github.io/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://jhfuture.github.io/tags/JDBC/"}]},{"title":"","slug":"IDEA/一些小知识","date":"2022-10-30T12:10:56.369Z","updated":"2022-11-25T16:16:55.776Z","comments":true,"path":"2022/10/30/IDEA/一些小知识/","link":"","permalink":"https://jhfuture.github.io/2022/10/30/IDEA/%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86/","excerpt":"","text":"整理的零碎的一些小知识 IDEA 在创建 project 时会自动创建一个 module ，该 module名 与项目名相同。、 IDEA 默认会对数据进行简化，如果想要查看完整数据需要进行设置。 file–&gt;setting —&gt;build,Execution,Deployment—&gt; Debugger —&gt;Data Views–&gt;JAVA–&gt; 取消Enable alternative view for Collections classes、取消 hide null elements in arrays and collections;","categories":[],"tags":[]},{"title":"1-基本概念.md","slug":"JavaWeb/1-基本概念","date":"2022-10-30T06:42:36.000Z","updated":"2022-10-30T13:27:07.218Z","comments":true,"path":"2022/10/30/JavaWeb/1-基本概念/","link":"","permalink":"https://jhfuture.github.io/2022/10/30/JavaWeb/1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"一、BS &#x2F;CS 架构 二、Tomcat简介 与 开始一个轻量化的 JavaWeb 容器 1. 安装tomcat123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113使用 tree 命令生成tree /f省略 /f 则只显示文件├─bin ---可执行二进制├─conf ---配置文件├─lib ---依赖的文件├─logs ---日志├─temp├─webapps ---web应用程序--部署应用的空间│ ├─docs│ │ ├─api│ │ ├─appdev│ │ │ └─sample│ │ │ ├─docs│ │ │ ├─src│ │ │ │ └─mypackage│ │ │ └─web│ │ │ ├─images│ │ │ └─WEB-INF│ │ ├─architecture│ │ │ ├─requestProcess│ │ │ └─startup│ │ ├─config│ │ ├─elapi│ │ ├─funcspecs│ │ ├─images│ │ │ └─fonts│ │ ├─jspapi│ │ ├─servletapi│ │ ├─tribes│ │ ├─WEB-INF│ │ └─websocketapi│ ├─examples│ │ ├─jsp│ │ │ ├─async│ │ │ ├─cal│ │ │ ├─checkbox│ │ │ ├─colors│ │ │ ├─dates│ │ │ ├─error│ │ │ ├─forward│ │ │ ├─images│ │ │ ├─include│ │ │ ├─jsp2│ │ │ │ ├─el│ │ │ │ ├─jspattribute│ │ │ │ ├─jspx│ │ │ │ ├─misc│ │ │ │ ├─simpletag│ │ │ │ └─tagfiles│ │ │ ├─jsptoserv│ │ │ ├─num│ │ │ ├─plugin│ │ │ │ └─applet│ │ │ ├─security│ │ │ │ └─protected│ │ │ ├─sessions│ │ │ ├─simpletag│ │ │ ├─snp│ │ │ ├─tagplugin│ │ │ └─xml│ │ ├─servlets│ │ │ ├─chat│ │ │ ├─images│ │ │ └─nonblocking│ │ ├─WEB-INF│ │ │ ├─classes│ │ │ │ ├─async│ │ │ │ ├─cal│ │ │ │ ├─chat│ │ │ │ ├─checkbox│ │ │ │ ├─colors│ │ │ │ ├─compressionFilters│ │ │ │ ├─dates│ │ │ │ ├─error│ │ │ │ ├─examples│ │ │ │ ├─filters│ │ │ │ ├─jsp2│ │ │ │ │ └─examples│ │ │ │ │ ├─el│ │ │ │ │ └─simpletag│ │ │ │ ├─listeners│ │ │ │ ├─nonblocking│ │ │ │ ├─num│ │ │ │ ├─sessions│ │ │ │ ├─util│ │ │ │ ├─validators│ │ │ │ └─websocket│ │ │ │ ├─chat│ │ │ │ ├─drawboard│ │ │ │ │ └─wsmessages│ │ │ │ ├─echo│ │ │ │ └─snake│ │ │ ├─jsp│ │ │ │ └─applet│ │ │ ├─jsp2│ │ │ ├─lib│ │ │ └─tags│ │ └─websocket│ ├─host-manager│ │ ├─images│ │ ├─META-INF│ │ └─WEB-INF│ │ └─jsp│ ├─manager│ │ ├─images│ │ ├─META-INF│ │ └─WEB-INF│ │ └─jsp│ └─ROOT│ └─WEB-INF└─work ----工作文件 2.配置 Java 运行环境1. JAVA_HOME 1. 在bin中配置 3. 新建 Web项目 并部署项目 在 webapp 下创建 baidu 文件夹，再在 baidu 文件夹下新建 WEB-INF文件夹 将 html、css 一系列文件放到与 WEB-INF 同级目录下 localhost:8080&#x2F;baidu&#x2F;demo09.html 访问 1localhost:8080/文件名/资源名 三、使用 IDEA 新建部署项目 先创建一个project，然后在 project 中创建 module 。选择创建 web application 配置Tomcat运行环境 添加配置选项 添加 Tomcat server -&gt;local配置 Tomcat 路径选择第一层目录即可，无需展开成功后 IDEA 会自动识别版本号 运行你的第一个 Javaweb 创建 index.html 点击运行养成使用”debug”的习惯 注意： Tomcat项目部署的文件路径 如果在 create model 时没有勾选 web application1.选择2.选择facets 添加 web 确定即可 四、将 Tomcat 中的 servlet-api.jar 包导入 jdk Tomcat 安装目录下的 lib 文件夹下 servlet-api.jar 添加 Tomcat library选择后确定 五、一些servlet报错","categories":[],"tags":[]},{"title":"2-自己编写dt文件.md","slug":"Android/2-自己写dt配置文件","date":"2022-10-29T16:30:54.000Z","updated":"2022-10-29T17:22:19.418Z","comments":true,"path":"2022/10/30/Android/2-自己写dt配置文件/","link":"","permalink":"https://jhfuture.github.io/2022/10/30/Android/2-%E8%87%AA%E5%B7%B1%E5%86%99dt%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"","text":"结构图一览 device tree 文件组成一览 BoardConfig.mk设备参数文件的组成部分，其中存放着不少与boot.img与Recovery编译的参数。正确设置这些参数，是保证TWRP正常编译的前提。Recovery和boot.img性质相同，均为Android的启动映像。","categories":[{"name":"Android","slug":"Android","permalink":"https://jhfuture.github.io/categories/Android/"},{"name":"TWRP","slug":"Android/TWRP","permalink":"https://jhfuture.github.io/categories/Android/TWRP/"}],"tags":[{"name":"twrp","slug":"twrp","permalink":"https://jhfuture.github.io/tags/twrp/"}]},{"title":"","slug":"MySQL/select的作用小结","date":"2022-10-29T12:49:38.947Z","updated":"2022-10-29T12:53:44.566Z","comments":true,"path":"2022/10/29/MySQL/select的作用小结/","link":"","permalink":"https://jhfuture.github.io/2022/10/29/MySQL/select%E7%9A%84%E4%BD%9C%E7%94%A8%E5%B0%8F%E7%BB%93/","excerpt":"","text":"select有许多操作 要查询的多个字符 对字符使用单行处理函数 对要查询的字符 —&gt; 使用多行处理函数—&gt; &#x3D;&#x3D;对数据进行处理&#x3D;&#x3D;","categories":[],"tags":[]},{"title":"6-连接查询.md","slug":"MySQL/6-连接查询","date":"2022-10-29T12:30:09.000Z","updated":"2023-02-10T08:24:30.481Z","comments":true,"path":"2022/10/29/MySQL/6-连接查询/","link":"","permalink":"https://jhfuture.github.io/2022/10/29/MySQL/6-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"[TOC] 一。关键字 distinct作用：查询结果去重位置：查询字段的前方，出现两个字段之前，表示两个字段联合查询。—-&gt; 统计岗位数量 123456789101112131415mysql&gt; select count(job) from emp;+------------+| count(job) |+------------+| 14 |+------------+1 row in set (0.01 sec)mysql&gt; select count(distinct job) from emp;+---------------------+| count(distinct job) |+---------------------+| 5 |+---------------------+1 row in set (0.00 sec) 一、什么是连接查询 二、 连接查询的分类 根据表连接的方式分类 内连接 —–&gt; 值一一对应 等值连接 非等值连接 自连接 外连接&#x3D;&#x3D;哪个&#x3D;&#x3D;外连接，表示 &#x3D;&#x3D;把哪张表当成主表&#x3D;&#x3D; 左外连接（也叫左连接） —&gt;左表为主表 右外连接（也叫右连接） —&gt;右表为主表 什么时候使用 内 外连接 判断两张表是否有 &#x3D;&#x3D;主次之分&#x3D;&#x3D; 全连接 (不常用) a 和 b 两张都是主表, 三、SQL92语法四、案例分析内连接： 完全能够匹配上这个条件的数据查询出来。( A 和 B 进行连接，A B 没有主次之分 ) ​ ​ A 内连接之等值连接 笛卡尔积现象 笛卡尔积现象：当两张表进行连接查询，没有任何条件限制的时候，最终查询结果的条数，是两张表条数的乘积，这种现象被称为：笛卡尔积现象。（笛卡尔发现的，这是一个属性现象） 1234567891011mysql&gt; select dname,ename from emp,dept;+------------+--------+| dname | ename |+------------+--------+| OPERATIONS | SMITH |………………………………………………| ACCOUNTING | MILLER |+------------+--------+56 rows in set (0.01 sec)=14*4 避免该现象：加筛选条件 查询每个员工所在部门名称，显示员工名和部门名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# SQL92写法mysql&gt; select ename,dname #这样子写查询效率会偏低，mysql会 分别去 emp 和 dept 两张表中都去查询这两个字段#提高效率# emp.ename,dept.dname;from emp,dept # 起别名 # emp xx, dept xxxwhere emp.deptno=dept.deptno; and xxx加其他条件SQL92的缺点：结构不清晰，表的链接条件，和后期进一步筛选的条件，都放到了 where 后面。+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING |+--------+------------+14 rows in set (0.00 sec) #SQL99的语法mysql&gt; select ename,dname #这样子写查询效率会偏低，mysql会 分别去 emp 和 dept 两张表中都去查询这两个字段#提高效率# emp.ename,dept.dname;from empinner join#inner 可省略 dept # 起别名 # emp xx, dept xxxon emp.deptno=dept.deptno;where xxSQL92优点：表连接的条件是独立的，连接之后如果需要进一步筛选，再往后添加where即可。+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING |+--------+------------+14 rows in set (0.00 sec) Q:dept中有4条记录，empt中有14条。最终查询的结果条数是14条，但是匹配的过程中，匹配的次数减少了吗？A:并没有，还是56次（每次匹配时，都会拿empt中的一条数据去逐一匹配dept中的4条记录。只不过进行了四选一(选符合条件的那条)_） B 内连接之非等值连接 ——&gt; 条件不是一个等量关系 找出每个员工的薪资登记，要求显示员工名、薪资、薪资登记？1234567891011121314151617181920212223242526272829303132mysql&gt; select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;+--------+---------+-------+| ename | sal | grade |+--------+---------+-------+| SMITH | 800.00 | 1 || ALLEN | 1600.00 | 3 || WARD | 1250.00 | 2 || JONES | 2975.00 | 4 || MARTIN | 1250.00 | 2 || BLAKE | 2850.00 | 4 || CLARK | 2450.00 | 4 || SCOTT | 3000.00 | 4 || KING | 5000.00 | 5 || TURNER | 1500.00 | 3 || ADAMS | 1100.00 | 1 || JAMES | 950.00 | 1 || FORD | 3000.00 | 4 || MILLER | 1300.00 | 2 |+--------+---------+-------+14 rows in set (0.00 sec) C、内连接之自连接 ——&gt; ​ 技巧：一张表看做两张表 查询员工的上级领导(mgr)，要求显示员工名和对应的领导名12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394select empno,ename,mgr from emp;+-------+--------+------+| empno | ename | mgr |+-------+--------+------+| 7369 | SMITH | 7902 || 7499 | ALLEN | 7698 || 7521 | WARD | 7698 || 7566 | JONES | 7839 || 7654 | MARTIN | 7698 || 7698 | BLAKE | 7839 || 7782 | CLARK | 7839 || 7788 | SCOTT | 7566 || 7839 | KING | NULL || 7844 | TURNER | 7698 || 7876 | ADAMS | 7788 || 7900 | JAMES | 7698 || 7902 | FORD | 7566 || 7934 | MILLER | 7782 |+-------+--------+------+14 rows in set (0.00 sec)用 mgr 的序号，去匹配 empno 得到ename ，然后填入--&gt;技巧，看成两张表emp a 员工表+-------+--------+------+| empno | ename | mgr |+-------+--------+------+| 7369 | SMITH | 7902 || 7499 | ALLEN | 7698 || 7521 | WARD | 7698 || 7566 | JONES | 7839 || 7654 | MARTIN | 7698 || 7698 | BLAKE | 7839 || 7782 | CLARK | 7839 || 7788 | SCOTT | 7566 || 7839 | KING | NULL || 7844 | TURNER | 7698 || 7876 | ADAMS | 7788 || 7900 | JAMES | 7698 || 7902 | FORD | 7566 || 7934 | MILLER | 7782 |+-------+--------+------+14 rows in set (0.00 sec)emp b领导表+-------+--------+------+| empno | ename | mgr |+-------+--------+------+| 7369 | SMITH | 7902 || 7499 | ALLEN | 7698 || 7521 | WARD | 7698 || 7566 | JONES | 7839 || 7654 | MARTIN | 7698 || 7698 | BLAKE | 7839 || 7782 | CLARK | 7839 || 7788 | SCOTT | 7566 || 7839 | KING | NULL || 7844 | TURNER | 7698 || 7876 | ADAMS | 7788 || 7900 | JAMES | 7698 || 7902 | FORD | 7566 || 7934 | MILLER | 7782 |+-------+--------+------+14 rows in set (0.00 sec)select a.ename as &#x27;员工名&#x27;, b.ename as &#x27;领导名&#x27;from emp ajoin emp bon a.mgr=b.empno;+--------+--------+| 员工名 | 领导名 |+--------+--------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+--------+--------+13 rows in set (0.01 sec)King没有领导。 外连接—-&gt; 存 在 主表(即 主表中不匹配 其他表的项也会被列举出来。) ​ A.右外连接 ​ 使用 emp 表中的 deptno 对应 ，dept 表中的 deptno 字段，显示结果匹配的，ename 和 dname 字段，并把 dept 中不匹配的 dname 也全部显示出来 123456789101112131415161718192021222324252627282930mysql&gt; select e.ename,d.dname from emp e right outer join # outer 可以省略 dept d # right：表示将 join 关键字右边的这张表看成主表，主要是为了将这张表的数据全部查询出来，捎带着关联查询左边的表。没有匹配的使用 null on e.deptno=d.deptno;+--------+------------+| ename | dname |+--------+------------+| MILLER | ACCOUNTING || KING | ACCOUNTING || CLARK | ACCOUNTING || FORD | RESEARCH || ADAMS | RESEARCH || SCOTT | RESEARCH || JONES | RESEARCH || SMITH | RESEARCH || JAMES | SALES || TURNER | SALES || BLAKE | SALES || MARTIN | SALES || WARD | SALES || ALLEN | SALES || NULL | OPERATIONS |+--------+------------+15 rows in set (0.02 sec) ​ B. 左外连接 1234567891011121314151617181920212223242526272829mysql&gt; select e.ename,d.dname from emp e left outer join # outer 可以省略 dept d on e.deptno=d.deptno;+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING |+--------+------------+14 rows in set (0.00 sec) 任何一个右连接都有左连接的写法。 任何一个左连接都有右连接的写法。 Q：外连接的查询结果条数一定是 &gt;&#x3D; 内连接的查询结果条数？ A：正确** 外连接案例 查询每个员工的上级领导，要求显示所有员工的名字和领导名？12345678910111213141516171819202122232425262728293031323334353637383940414243mysql&gt; select empno,ename,mgr from emp;+-------+--------+------+| empno | ename | mgr |+-------+--------+------+| 7369 | SMITH | 7902 || 7499 | ALLEN | 7698 || 7521 | WARD | 7698 || 7566 | JONES | 7839 || 7654 | MARTIN | 7698 || 7698 | BLAKE | 7839 || 7782 | CLARK | 7839 || 7788 | SCOTT | 7566 || 7839 | KING | NULL || 7844 | TURNER | 7698 || 7876 | ADAMS | 7788 || 7900 | JAMES | 7698 || 7902 | FORD | 7566 || 7934 | MILLER | 7782 |+-------+--------+------+14 rows in set (0.00 sec)# 1.分析思路 ---&gt; 一张表# 2.判断主表 ---&gt; a员工表mysql&gt; select a.ename as &#x27;员工名&#x27;,b.ename from emp a left join emp b on a.mgr=b.empno;+--------+-------+| ename | ename |+--------+-------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || KING | NULL || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+--------+-------+14 rows in set (0.00 sec) 五、多张表之间进行连接123456789101112131415161718select xxxfrom ajoin bon a 和 b 的连接条件join con a 和 c 的连接right join don a 和 d 的连接一条 sql 中内连接和外连接可以混合，都可以出现。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://jhfuture.github.io/categories/mysql/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://jhfuture.github.io/tags/MySQL/"}]},{"title":"5-分组查询.md","slug":"MySQL/5-分组查询","date":"2022-10-28T13:25:32.000Z","updated":"2022-11-05T16:51:55.649Z","comments":true,"path":"2022/10/28/MySQL/5-分组查询/","link":"","permalink":"https://jhfuture.github.io/2022/10/28/MySQL/5-%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"什么是分组查询一定要先分组，才能使用分组查询。在默认情况下一张表为一张表 select … from … where …. group by .. order by … 二、sql 的执行过程（顺序）1.from 2.where 3.group by （没有的时候默认为一张表） ​ …. 4.having ​ ….. 5.select ​ ….. 6.order by ​ …. 从 from 指定的表中查，经过 where 条件进行过滤出有价值的价值，过滤后进行 group by分组，分完组继续 使用 having 进行 过滤 ，然后 select 查询出来，最后进行排序。 三、sql 语句要注意的点​ 分组函数不能直接使用在 where 后面。 一个思考题 为什么这个语句会报错 &#x2F; 1select sal form emp where sal&gt;min(sal); ​ Q; min 是分组命令，要在group by执行完后才能执行。 如果写在where 中，where 执行时，group by 还没有执行。 为什么这个没有分组 ，sum 函数可以使用呢？ 1select sum(sal) from emp; Q: 因为 select 在 group by 之后执行。 执行流程分析 1. 12345678910111213141516统计不同岗位的工资和。----&gt; 俺岗位分组select job,sum(sal) from emp group by job;mysql&gt; select job,sum(sal) from emp group by job;+-----------+----------+| job | sum(sal) |+-----------+----------+| CLERK | 4150.00 || SALESMAN | 5600.00 || MANAGER | 8275.00 || ANALYST | 6000.00 || PRESIDENT | 5000.00 |+-----------+----------+5 rows in set (0.00 sec)1. 先从 emp 表中查询数据 (from 和 where)2. 根据 job 进行分组3. 对每一组的数据进行 sum(sal) select 字段要求 在一条 select 语句当中，如果有 group by 语句的话，select 后面只能跟： 参加分组的字段（job），以及分组函数(sum(sal))，其他的一律不能跟。 12select ename(x错误！),job,sum(sal) from emp group by job;---&gt;Oracle会报错 案例分析 求每个部门中的最高薪资 123456789101. 先根据部门进行分组 ----&gt; 2.找出每一组中的最大值mysql&gt; select max(sal),deptno from emp group by deptno;+----------+--------+| max(sal) | deptno |+----------+--------+| 3000.00 | 20 || 2850.00 | 30 || 5000.00 | 10 |+----------+--------+3 rows in set (0.01 sec) 找出“每个部门，不同工作岗位”的最高薪资 123456789101112131415mysql&gt; select job,deptno,max(sal) from emp group by job,deptno;+-----------+--------+----------+| job | deptno | max(sal) |+-----------+--------+----------+| CLERK | 20 | 1100.00 || SALESMAN | 30 | 1600.00 || MANAGER | 20 | 2975.00 || MANAGER | 30 | 2850.00 || MANAGER | 10 | 2450.00 || ANALYST | 20 | 3000.00 || PRESIDENT | 10 | 5000.00 || CLERK | 30 | 950.00 || CLERK | 10 | 1300.00 |+-----------+--------+----------+9 rows in set (0.00 sec) 技巧：两个字段联合成 1 个字段看（两个字段联合分组） 找出每个部门最高薪资，要求显示最高薪资大于3000的 123456789101112131415161718192021222324252627282930思路一、1.找出每个部门最高薪资 按照部门编号，进行分组，然后找出最高薪资2. 要求显示薪资大于3000 ， mysql&gt; select deptno,max(sal) from emp group by deptno having max(sal)&gt;3000 ;+--------+----------+| deptno | max(sal) |+--------+----------+| 10 | 5000.00 |+--------+----------+1 row in set (0.01 sec)思路二、先将 sal&gt;3000 的都找出来，然后再进行分组select deptno,max(sal)from empwheresal&gt;3000group bydeptno; having 不能单独使用，having可以对数据进行进一步过滤. 优化策略：where和having，优先选择 where ，where 实在完成不了的，再选择having 找出每个部门的平均薪资，只显示平均薪资大于2500的 123456789101112131415161718mysql&gt; select deptno,avg(sal) from emp group by deptno ;+--------+-------------+| deptno | avg(sal) |+--------+-------------+| 20 | 2175.000000 || 30 | 1566.666667 || 10 | 2916.666667 |+--------+-------------+3 rows in set (0.00 sec)# 分组函数中无法 在where中使用，所以此处不能使用where代替mysql&gt; select deptno,avg(sal) from emp group by deptno having avg(sal)&gt;2500;+--------+-------------+| deptno | avg(sal) |+--------+-------------+| 10 | 2916.666667 |+--------+-------------+1 row in set (0.00 sec) 找出每个岗位的平均薪资，要求显示平均薪资大于 1500 的，除manager 岗位之外，要求按照平均薪资降序排 1234567891011121314151617181920212223selectjob,avg(sal)fromempwherejob&lt;&gt; &#x27;manager&#x27;group by jobhaving avg(sal)&gt;1500order byavg(sal) desc; 先使用where 中选出了job不为 manager， 然后 使用having再进行过滤，最后 select job,avg(sal) 。mysql&gt; select job,avg(sal) from emp where job&lt;&gt;&#x27;manager&#x27;group by job having avg(sal)&gt;1500 order by avg(sal) desc;+-----------+-------------+| job | avg(sal) |+-----------+-------------+| PRESIDENT | 5000.000000 || ANALYST | 3000.000000 |+-----------+-------------+2 rows in set (0.00 sec)","categories":[{"name":"mysql","slug":"mysql","permalink":"https://jhfuture.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jhfuture.github.io/tags/mysql/"}]},{"title":"4-多行处理命令.md","slug":"MySQL/4-多行处理命令","date":"2022-10-28T12:49:19.000Z","updated":"2022-10-28T13:25:00.007Z","comments":true,"path":"2022/10/28/MySQL/4-多行处理命令/","link":"","permalink":"https://jhfuture.github.io/2022/10/28/MySQL/4-%E5%A4%9A%E8%A1%8C%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/","excerpt":"","text":"一、简要介绍​ 对多行数据进行处理，单行输出。 二、常用命令 count(字段) 统计&#x3D;&#x3D;数值不为null&#x3D;&#x3D;的字段 count(* ) 统计表中的&#x3D;&#x3D;总行数&#x3D;&#x3D; sum(字段) ，对字段进行求和—-&gt; 在多行处理命令中会自动忽略null不用使用 ifnull(字段,转换值) 进行转换 avg平均值：select avg（字段名） from 表名； max最大值：select max（字段名） from 表名； min最小值：select min（字段名） from 表名； 三、注意点 分组函数不能够直接使用在 where 字句中 找出比最低工资高的员工信息。错误案例select ename,sal from emp where sal &gt; min(sal)看起来没问题，但运行Error 111(HY000 ): invalid use of group function 所有的分组函数可以组合起来一起使用","categories":[{"name":"mysql","slug":"mysql","permalink":"https://jhfuture.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jhfuture.github.io/tags/mysql/"}]},{"title":"","slug":"Linux/3-修改swap大小","date":"2022-10-27T16:33:39.088Z","updated":"2022-07-20T11:07:15.796Z","comments":true,"path":"2022/10/28/Linux/3-修改swap大小/","link":"","permalink":"https://jhfuture.github.io/2022/10/28/Linux/3-%E4%BF%AE%E6%94%B9swap%E5%A4%A7%E5%B0%8F/","excerpt":"","text":"Ubuntu 修改swap大小","categories":[],"tags":[]},{"title":"How to compile twrp(编译属于你自己的twrp_recovery)","slug":"Android/compileTwrp","date":"2022-10-27T12:18:58.000Z","updated":"2022-10-29T16:28:57.293Z","comments":true,"path":"2022/10/27/Android/compileTwrp/","link":"","permalink":"https://jhfuture.github.io/2022/10/27/Android/compileTwrp/","excerpt":"","text":"[TOC] How to compile twrp一、前言在很久之前就有了自己编译 twrp 和 rom 的想法，但碍于设备条件，一直没有机会实现。刚好这段时间有空，就开始查阅资料实现。 二、硬性要求 具有一定的科学上网能力。（必须！！！！） 硬盘空间 &gt;&#x3D; 200G。 会基本的Linux命令操作 运行内存&gt;&#x3D;16G（推荐16G以上，当然差的不是很多可以通过增大swap分区来解决） 三、教程正文 配置好Ubuntu环境 配置虚拟机或者Windows安装虚拟机都可以。网上关于此的教程较多，在此不进行过多的赘述。Ubuntu版本推荐 18.04或 22.04（自用版本) 安装必要的软件依赖 把apt 的源更换为国内的镜像 ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror 阿里&#x2F;中科大也可 &#96;&#96;&#96;shell 安装一些必要的依赖sudo apt install bc bison build-essential ccache curl flex g++-multilib gcc-multilib git gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev liblz4-tool libncurses5 libncurses5-dev libsdl1.2-dev libssl-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev git 可选 这两个工具是为了可以刷入手机sudo apt install adb fastboot 123456789101112131415161718 3. 配置git(如果你没有配置过请配置) 1. 3. 下载 repo 工具。 1. 使用清华源安装 [教程](https://mirrors.tuna.tsinghua.edu.cn/help/git-repo/) 1. ```shell # 下载 curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repo chmod +x repo mv repo ~/usr/bin/ #or mv repo ~/bin/ # 将以下内容写入 ~/.bashrc 文件内 export REPO_URL=&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo&#x27; # 重启终端模拟器 查看 PATH 可使用 echo $PATH 命令 .bashrc 文件（bash rc-running configuration）这个文件主要保存个人的一些个性化设置，如命令别名、路径等。也即在同一个服务器上，只对某个用户的个性化设置相关。普通用户为 &#x2F;home&#x2F;用户名&#x2F; 目录，root 为 &#x2F;root&#x2F; 。改文件在&#x3D;&#x3D;每次启动bash&#x3D;&#x3D;都会被加载 使用repo初始化本地仓库，使用AOSP tree 构建 TWRP。 &#96;&#96;&#96;shell创建文件夹mkdir twrp&amp;&amp;cd twrp这里使用 aosp 最小设备树repo init -u https://github.com/minimal-manifest-twrp/platform_manifest_twrp_aosp.git -b twrp-12.11234565. 同步源码 1. ```shell repo sync -j8 # -j xxx 代表使用多少个线程 准备 devices tree(dt文件) 直接从 github 获取 github 搜索 设备代号(可百度搜) + twrp —–&gt; 这里以k30pro 为例 lmi twrp 下载到 .&#x2F;device&#x2F;xiaomi(手机厂商)&#x2F;lmi(设备代号)&#x2F; &#96;&#96;&#96;shell#确保你在刚刚创建的twrp 文件内git clone 上面的链接 device&#x2F;xiaomi&#x2F;lmi&#x2F; 123456789101112132. 我是大佬自己写dt文件(大佬不需要看教程)---&gt;后续我会写一个3. 使用 twrpdtgen 生成 1. ```shell #安装python apt install python3 # 安装cpio 必须 apt install cpio #使用 pip 安装 # python2.7 及python3.4以上已内置，没有的额外安装 pip3 install twrpdtgen 提取 boot.img &#x2F;recovery.img(具有recovery独立分区的手机) 可以通过下载线刷包解包后获取 小米卡刷&#x2F;线刷包下载 使用 twrpdtgen 生成dt tree &#96;&#96;&#96;shellpython3 -m twrpdtgen recovery.img&#x2F;boot.img绝对路径 提示 Done！即成功1234562. 将 twrpdtgen 生成的 dt tree 移动到 twrp/devices中 1. ```shell mv output/xiaomi(厂商代号) device/ 开始编译 确保你现在在源码根目录 也就是 twrp 文件夹里 不确定的可以使用 pwd 命令，查看 配置环境 &#96;&#96;&#96;shell. build&#x2F;envsetup.sh1234567891011121314153. 开始编译 1. ```shell # 1.直接在命令行输入 export ALLOW_MISSING_DEPENDENCIES=true # 2. lunch #会输出一系列，选择你要编译的序号即可，一般为 omni_lmi(代号)-eng #or lunch omni_lmi-eng #3. mka recoveryimage 编译成功！ 当出现 build completed successfully 。即证明你已经编译成功了！ 刷入 recovery.img 重启设备进入 fastboot模式adb reboot fastboot 刷入 recoveryfast flash recovery &#x2F;out&#x2F;target&#x2F;product&#x2F;lmi&#x2F;recovery.img(可能会有变化) 三、常见问题 Q:为什么提示 github unable resolve 。A: 因为国内的特殊环境，github 偶尔不能访问，如果可以的话请挂好梯子后进行编译。","categories":[{"name":"Android","slug":"Android","permalink":"https://jhfuture.github.io/categories/Android/"}],"tags":[{"name":"compile","slug":"compile","permalink":"https://jhfuture.github.io/tags/compile/"},{"name":"twrp","slug":"twrp","permalink":"https://jhfuture.github.io/tags/twrp/"}]},{"title":"","slug":"JAVA/5-面向对象(高级)/1-类变量和类方法/1-类方法","date":"2022-10-26T14:02:31.995Z","updated":"2022-10-31T03:22:05.077Z","comments":true,"path":"2022/10/26/JAVA/5-面向对象(高级)/1-类变量和类方法/1-类方法/","link":"","permalink":"https://jhfuture.github.io/2022/10/26/JAVA/5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E9%AB%98%E7%BA%A7)/1-%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95/1-%E7%B1%BB%E6%96%B9%E6%B3%95/","excerpt":"","text":"一、静态方法的使用 调用方式 通过123对象名.方法名或类名.方法名 二、静态方法的注意事项 静态方法&#x3D;&#x3D;只能访问静态变量&#x3D;&#x3D;why? 静态方法和 三、静态方法和普通方法的区别 访问变量的范围 静态方法只能访问静态变量。而普通方法能同时访问静态变量和成员变量。","categories":[],"tags":[]},{"title":"","slug":"JAVA/5-面向对象(高级)/1-类变量和类方法/0-静态变量的储存位置","date":"2022-10-26T13:08:37.292Z","updated":"2022-11-24T12:48:50.577Z","comments":true,"path":"2022/10/26/JAVA/5-面向对象(高级)/1-类变量和类方法/0-静态变量的储存位置/","link":"","permalink":"https://jhfuture.github.io/2022/10/26/JAVA/5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E9%AB%98%E7%BA%A7)/1-%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95/0-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%82%A8%E5%AD%98%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"一、 使用修饰符 static type ParameterNam 二、细节 什么是类变量 类变量也叫静态变量&#x2F;静态属性，是该类的&#x3D;&#x3D;所有对象实例共享&#x3D;&#x3D;的变量，任何一个该类的对象实例去访问它时，取到的都是相同的值；同样任何一个该类的对象去修改它时，修改的也是同一个变量。 如何定义 访问修饰符 static 数据类型 变量名 static 访问修饰符 数据类型 变量名。 如何访问类变量 类名.类变量名 &#x3D;&#x3D;&#x3D;&gt; 推荐 or 对象名.类变量名 &#x3D;&#x3D;访问时需要遵守访问修饰符&#x3D;&#x3D; 类变量在什么时候生成 类变量在类被加载时就初始化了，也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量 类变量的生命周期是随类的加载开始，随类消亡 案例 public class visitStatic &#123; public static void main(String[] args) &#123; System.out.println(A.name); &#125; &#125; class A&#123; public static String name=&quot;ni hao&quot;; &#125; 什么时候加载类信息. 什么时候需要用类变量 当我们需要让某个类的所有对象都共享一个变量时。 类变量与实例变量（普通属性）区别 类变量是该类的所有对象共享的，二实例变量（普通成员变量&#x2F;非静态成员变量)）是每个对象独享的’&#x3D;’ 普通属性不能通过 类名.变量名读取 二、静态变量&#x2F; 类变量储存 版本划分 jdk7以前在方法区中 jdk7以后，静态域储存于定义类型的Class对象中，Class对象如同堆中其他对象一样存在于GO堆中。 放在class 实例的尾部，class 变量存在于堆中。 特定 所有对象变量共享 ——&gt; 同一个类生成的所有对象。 在类加载的时候就生成","categories":[],"tags":[]},{"title":"","slug":"Linux/2-配置python版本","date":"2022-10-24T17:24:10.148Z","updated":"2022-10-26T13:07:45.681Z","comments":true,"path":"2022/10/25/Linux/2-配置python版本/","link":"","permalink":"https://jhfuture.github.io/2022/10/25/Linux/2-%E9%85%8D%E7%BD%AEpython%E7%89%88%E6%9C%AC/","excerpt":"","text":"python问题 12345678910111213//update-alternatives: 使用 /usr/bin/python2 来在自动模式中提供 /usr/bin/python (python)$:sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 1//列出python的配置项$su: do update-alternatives --list python/usr/bin/python2//调整顺序$ u82:~/Py_demo$ python -VPython 2.7.18//查看软连接ls -l | grep python* apt换源问题 1. miui recover.fstab 在 &#x2F;ramdisk&#x2F;system&#x2F;e repo 使用清华源 清华源 一般path 为 ~&#x2F;usr&#x2F;bin","categories":[],"tags":[]},{"title":"","slug":"Linux/1-网络问题","date":"2022-10-24T17:12:10.709Z","updated":"2022-10-24T17:13:10.452Z","comments":true,"path":"2022/10/25/Linux/1-网络问题/","link":"","permalink":"https://jhfuture.github.io/2022/10/25/Linux/1-%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/","excerpt":"","text":"模式选择 默认使用NAT即可 不能正常使用 恢复默认设置 检查 VM 的 NAT 服务 和 DNS 服务","categories":[],"tags":[]},{"title":"","slug":"JAVA/4-面向对象(中级)/9-断点调试/1-相关快捷键","date":"2022-10-23T13:34:51.937Z","updated":"2022-07-20T11:38:23.832Z","comments":true,"path":"2022/10/23/JAVA/4-面向对象(中级)/9-断点调试/1-相关快捷键/","link":"","permalink":"https://jhfuture.github.io/2022/10/23/JAVA/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%AD%E7%BA%A7)/9-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/1-%E7%9B%B8%E5%85%B3%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"F7(跳入方法内) F8(逐行执行代码) shift + F8 (跳出方法) F9（resume 执行到下一个断点)","categories":[],"tags":[]},{"title":"finalize.md","slug":"JAVA/4-面向对象(中级)/8-Object类/3-finalize/finalize","date":"2022-10-23T13:18:23.000Z","updated":"2022-10-23T13:31:54.780Z","comments":true,"path":"2022/10/23/JAVA/4-面向对象(中级)/8-Object类/3-finalize/finalize/","link":"","permalink":"https://jhfuture.github.io/2022/10/23/JAVA/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%AD%E7%BA%A7)/8-Object%E7%B1%BB/3-finalize/finalize/","excerpt":"","text":"一、简要介绍 在对象没有任何引用时，jvm 就会调用对象的finalize方法。进行垃圾回收。 程序猿可以在 finalize 中，写自己的业务逻辑代码（比如释放资源：数据库链接，或打开文件…) 如果程序猿不重写 finalize 方法，则会默认调用 object 类的 finalize ，即默认处理。 二、小结 开发中，几乎不会运用finalize ,所以更多的是为了应对面试","categories":[{"name":"java","slug":"java","permalink":"https://jhfuture.github.io/categories/java/"}],"tags":[{"name":"finalize","slug":"finalize","permalink":"https://jhfuture.github.io/tags/finalize/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://jhfuture.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}]},{"title":"toString.md","slug":"JAVA/4-面向对象(中级)/8-Object类/2-toString方法/toString","date":"2022-10-23T13:03:45.000Z","updated":"2022-10-23T13:16:33.288Z","comments":true,"path":"2022/10/23/JAVA/4-面向对象(中级)/8-Object类/2-toString方法/toString/","link":"","permalink":"https://jhfuture.github.io/2022/10/23/JAVA/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%AD%E7%BA%A7)/8-Object%E7%B1%BB/2-toString%E6%96%B9%E6%B3%95/toString/","excerpt":"","text":"一、简要介绍 toString 源码 &#96;&#96;&#96;java&#x2F;&#x2F;（1）getClass.getName 类的全类名 （包+类）&#x2F;&#x2F; （2）Integer.toHexString(hashCode());将对象的hashcode转换为十六进制public String toString() { return getClass().getName() + “@” + Integer.toHexString(hashCode());}123456789101112131415161718192021222324252627282930313233342. 子类默认重写 1. ```java //案例 package com.jhfuture.toStringmethods; public class test &#123; public static void main(String[] args) &#123; Monster monster = new Monster(&quot;小米&quot;, 123); System.out.println(monster.toString()+&quot;hashcode&quot;+monster.hashCode()); &#125; &#125; class Monster&#123; private String name; private int age; //重写toString 方法，输出对象的属性 //使用快捷键即可 //alt+insert @Override public String toString() &#123; //一般是把对象的属性值输出 return &quot;Monster&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; public Monster(String name, int age) &#123; this.name = name; this.age = age; &#125; &#125; 当直接输出一个对象时，就会&#x3D;&#x3D;默认调用toString方法&#x3D;&#x3D; System.out.println(monster);// 等同于 monset.toString() 二、解释 全类名：包名+类名1.","categories":[{"name":"java","slug":"java","permalink":"https://jhfuture.github.io/categories/java/"}],"tags":[{"name":"toString","slug":"toString","permalink":"https://jhfuture.github.io/tags/toString/"}]},{"title":"hashCode.md","slug":"JAVA/4-面向对象(中级)/8-Object类/5-hashCode/hashCode","date":"2022-10-23T12:46:41.000Z","updated":"2022-10-23T12:54:19.367Z","comments":true,"path":"2022/10/23/JAVA/4-面向对象(中级)/8-Object类/5-hashCode/hashCode/","link":"","permalink":"https://jhfuture.github.io/2022/10/23/JAVA/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%AD%E7%BA%A7)/8-Object%E7%B1%BB/5-hashCode/hashCode/","excerpt":"","text":"一些特别的解释： hashcode是根据对象的&#x3D;&#x3D;真实地址&#x3D;&#x3D;来获得的","categories":[],"tags":[]},{"title":"字符串与基本数据类型","slug":"JAVA/1-变量/2-类型转换/字符串与基本数据类型","date":"2022-10-22T13:47:42.000Z","updated":"2022-10-22T14:16:45.708Z","comments":true,"path":"2022/10/22/JAVA/1-变量/2-类型转换/字符串与基本数据类型/","link":"","permalink":"https://jhfuture.github.io/2022/10/22/JAVA/1-%E5%8F%98%E9%87%8F/2-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"一、基本类型转换字符串 语法 将基本类型的值 + “” 即可 int n1=20; String n2=n1+&quot;&quot;; 12345678910111213141516171819### 二、字符串转换为基本数据类型1. 语法 1. 通过基本类型的 **包装类**调用parseXX方法即可。 1. ```java String ---&gt; int String s5=&quot;123&quot;; int n1= Integer.parseInt(s5); System.out.println(n1); double num2=Double.parseDouble(s5); System.out.println(num2); float num3=Float.parseFloat(s5); long num4=Long.parseLong(s5); byte num5=Byte.parseByte(s5); boolean b=Boolean.parseBoolean(&quot;true&quot;); short num6= Short.parseShort(s5); 特别的，把字符串转位字符—-&gt; 一般是将 字符串 中的第一个一个字符取出得到 &#96;&#96;&#96;javachar i &#x3D;s5.charAt(0);1234567891011122. 在转换时一定要确保string类型能转换为有效的数据。比如我们可以将“123&quot;转换为整数，但是不能将 ”hello &quot; 转换为一个整数。程序会直接报错并终止。 1. ```java String h=&quot;hello&quot;; int i=Integer.parseInt(h); Error: Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;hello&quot; at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Integer.parseInt(Integer.java:580) at java.lang.Integer.parseInt(Integer.java:615) at com.jhfuture.StringToBasetype.man.main(man.java:17)","categories":[{"name":"java","slug":"java","permalink":"https://jhfuture.github.io/categories/java/"}],"tags":[{"name":"数据类型转换","slug":"数据类型转换","permalink":"https://jhfuture.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"String字符串","slug":"String字符串","permalink":"https://jhfuture.github.io/tags/String%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"","slug":"JAVA/4-面向对象(中级)/7-==和equal的区别/练习/1-","date":"2022-10-22T13:40:55.817Z","updated":"2022-10-22T13:41:35.443Z","comments":true,"path":"2022/10/22/JAVA/4-面向对象(中级)/7-==和equal的区别/练习/1-/","link":"","permalink":"https://jhfuture.github.io/2022/10/22/JAVA/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%AD%E7%BA%A7)/7-==%E5%92%8Cequal%E7%9A%84%E5%8C%BA%E5%88%AB/%E7%BB%83%E4%B9%A0/1-/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"JAVA/一些待解决的原理问题/一些深入探讨的问题","date":"2022-10-22T13:04:03.418Z","updated":"2022-10-22T13:18:04.406Z","comments":true,"path":"2022/10/22/JAVA/一些待解决的原理问题/一些深入探讨的问题/","link":"","permalink":"https://jhfuture.github.io/2022/10/22/JAVA/%E4%B8%80%E4%BA%9B%E5%BE%85%E8%A7%A3%E5%86%B3%E7%9A%84%E5%8E%9F%E7%90%86%E9%97%AE%E9%A2%98/%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"动态绑定机制是怎么样的，为什么方法具有，而属性没有 —-&gt; 对应方法和属性的调用机制 有没有一种可能是因为向上转型时 查找属性时是在堆中直接从该父类类型（即编译类型）的堆空间中找 而调用方法是从方法区中开始找","categories":[],"tags":[]},{"title":"1-this","slug":"JAVA/4-面向对象(中级)/3-this和super/1-this","date":"2022-10-22T12:54:28.000Z","updated":"2022-10-22T13:01:20.477Z","comments":true,"path":"2022/10/22/JAVA/4-面向对象(中级)/3-this和super/1-this/","link":"","permalink":"https://jhfuture.github.io/2022/10/22/JAVA/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%AD%E7%BA%A7)/3-this%E5%92%8Csuper/1-this/","excerpt":"","text":"一些自己的小实验 即时在父类中使用this的关键字，在多态中依然会遵循动态绑定机制 调用对象方法会有动态绑定机制（和对象的内存地址&#x2F;运行类型进行绑定）—&gt;根据运行类型，从本类中开始查找—&gt;父类 调用对象属性—&gt;在哪里声明，在那里调用 package com.jhfuture.thisDetail; //Person.java //person，xiaoming ,其中person有say方法，而两则都有bye 方法， // 当使用 向上转型调用xiaoming类时，如果，say方法中使用了this，那还遵守动态绑定吗 遵循 public class Person &#123; String name=&quot;person&quot;; public void say()&#123; System.out.println(this.name); bye(); &#125; public void bye()&#123; System.out.println(&quot;here is person&quot;); &#125; &#125; //xiaoming.java package com.jhfuture.thisDetail; public class xiaoming extends Person&#123; String name=&quot;xiaoming&quot;; public void bye()&#123; System.out.println(&quot;here is xiaoming&quot;); &#125; &#125; //test.java package com.jhfuture.thisDetail; public class test &#123; public static void main(String[] args) &#123; Person xiaoming = new xiaoming(); xiaoming.say(); &#125; &#125; //结果 person here is xiaoming","categories":[{"name":"java","slug":"java","permalink":"https://jhfuture.github.io/categories/java/"}],"tags":[{"name":"this关键字","slug":"this关键字","permalink":"https://jhfuture.github.io/tags/this%E5%85%B3%E9%94%AE%E5%AD%97/"}]},{"title":"2-成员方法的细节","slug":"JAVA/3-面向对象/5-方法/2-成员方法的细节","date":"2022-10-22T12:41:18.000Z","updated":"2022-10-22T12:44:52.391Z","comments":true,"path":"2022/10/22/JAVA/3-面向对象/5-方法/2-成员方法的细节/","link":"","permalink":"https://jhfuture.github.io/2022/10/22/JAVA/3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5-%E6%96%B9%E6%B3%95/2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%86%E8%8A%82/","excerpt":"","text":"一些需要注意的细节 同一个类中的方法调用：直接调用即可。例如 print(参数) class hello&#123; public void say()&#123; println(&quot;&quot;); &#125; print()&#123; System.out.println(&quot;hello&quot;); &#125; &#125; 跨类中的方法 A 类调用 B类方法：需要通过对象名调用","categories":[{"name":"java","slug":"java","permalink":"https://jhfuture.github.io/categories/java/"}],"tags":[{"name":"成员方法","slug":"成员方法","permalink":"https://jhfuture.github.io/tags/%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95/"}]},{"title":"","slug":"JAVA/3-面向对象/2-面向对象内存机制/2-调用方法的内存机制","date":"2022-10-22T12:01:22.576Z","updated":"2022-10-22T12:10:42.797Z","comments":true,"path":"2022/10/22/JAVA/3-面向对象/2-面向对象内存机制/2-调用方法的内存机制/","link":"","permalink":"https://jhfuture.github.io/2022/10/22/JAVA/3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/2-%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"12345678910Person p1 =new person();int res =p1.getSum(10,20);System.out.println(res);public void sum(int num1,int num2)&#123; int result=num1+num2; return result;&#125; 在 main 栈里面，先执行 person p1&#x3D; new person() 在堆中创建一个新对象，并把内存地址赋值给 p1 调用p1.getSum 创建一个新的栈（全新的独立空间) 将基本数据类型 10, 20分别执行 值拷贝 给num1, num2 第二步执行完成后会将 result 返回给 res ，并释放该方法的栈。 继续执行后面的代码","categories":[],"tags":[]},{"title":"多态参数","slug":"JAVA/4-面向对象(中级)/6-多态/2-多态的应用/2-多态参数","date":"2022-10-22T11:18:56.000Z","updated":"2022-10-22T11:22:53.705Z","comments":true,"path":"2022/10/22/JAVA/4-面向对象(中级)/6-多态/2-多态的应用/2-多态参数/","link":"","permalink":"https://jhfuture.github.io/2022/10/22/JAVA/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%AD%E7%BA%A7)/6-%E5%A4%9A%E6%80%81/2-%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8/2-%E5%A4%9A%E6%80%81%E5%8F%82%E6%95%B0/","excerpt":"","text":"一、简要介绍多态形参：方法定义的形参为父类型，实参类型允许为子类类型","categories":[{"name":"java","slug":"java","permalink":"https://jhfuture.github.io/categories/java/"}],"tags":[{"name":"多态应用/多态参数","slug":"多态应用-多态参数","permalink":"https://jhfuture.github.io/tags/%E5%A4%9A%E6%80%81%E5%BA%94%E7%94%A8-%E5%A4%9A%E6%80%81%E5%8F%82%E6%95%B0/"}]},{"title":"java","slug":"java","date":"2022-10-22T11:13:01.000Z","updated":"2022-10-22T11:13:01.034Z","comments":true,"path":"2022/10/22/java/","link":"","permalink":"https://jhfuture.github.io/2022/10/22/java/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"==和equal","slug":"JAVA/4-面向对象(中级)/7-==和equal的区别/equal","date":"2022-10-22T10:50:08.000Z","updated":"2022-10-22T11:06:36.029Z","comments":true,"path":"2022/10/22/JAVA/4-面向对象(中级)/7-==和equal的区别/equal/","link":"","permalink":"https://jhfuture.github.io/2022/10/22/JAVA/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%AD%E7%BA%A7)/7-==%E5%92%8Cequal%E7%9A%84%E5%8C%BA%E5%88%AB/equal/","excerpt":"","text":"一、&#x3D;&#x3D; 可以判断基本类型和引用类型 判断基本类型 比较的是值是否相等 判断引用类型 判断内存地址是否相同&#x2F;引用是否指向同一个对象 object的equal方法的基本组成 &#96;&#96;&#96;javapublic boolean equals(Object obj) { return (this &#x3D;&#x3D; obj);}12345678910111213 2. ## 二、equal1. equal 方法只能比较引用类型2. object 类的 equal 方法 1. ```java public boolean equals(Object obj) &#123; return (this == obj); &#125; Object 的子类 String 和 integer 都重写了 object 中的 equal 方法 &#96;&#96;&#96;java&#x2F;&#x2F;String进行判断public boolean equals(Object anObject) {&#x2F;&#x2F;直接使用 &#x3D;&#x3D; 判断内存地址 if (this &#x3D;&#x3D; anObject) { return true; }&#x2F;&#x2F;判断是否为 string 类&#x2F; string 的子类 if (anObject instanceof String) {&#x2F;&#x2F;向下转型&#x2F;&#x2F; 为什么为向下转型，因为 anObject 传入时就 发生了 object的向上转型，这里从 object 转回 String。 String anotherString &#x3D; (String)anObject; int n &#x3D; value.length; if (n &#x3D;&#x3D; anotherString.value.length) { char v1[] &#x3D; value; char v2[] &#x3D; anotherString.value; int i &#x3D; 0; &#x2F;&#x2F;判断两个string类的值是否相同 while (n– !&#x3D; 0) { if (v1[i] !&#x3D; v2[i]) return false; i++; } return true; } } return false;}1234567892. ```java //integer 的源码 public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false; &#125; 三、综合比较1234567891011121314151617181920package com.jhfuture.checkJDKsrc;public class checkEqual &#123; public static void main(String[] args) &#123; String string = new String(&quot;hello&quot;); String string1= new String(&quot;hello&quot;); System.out.println(string==string1);//false---&gt;直接判断内存地址 System.out.println(string.equals(string1));//true ---&gt;判断值 Integer integer = new Integer(123); Integer integer1 = new Integer(123); System.out.println(integer==integer1); //false System.out.println(integer.equals(integer1)); //true 同理 &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://jhfuture.github.io/categories/java/"}],"tags":[{"name":"经典面试题","slug":"经典面试题","permalink":"https://jhfuture.github.io/tags/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"","slug":"JAVA/0-Java细节/如何在idea中查看源码","date":"2022-10-22T10:42:25.134Z","updated":"2022-10-22T10:47:42.104Z","comments":true,"path":"2022/10/22/JAVA/0-Java细节/如何在idea中查看源码/","link":"","permalink":"https://jhfuture.github.io/2022/10/22/JAVA/0-Java%E7%BB%86%E8%8A%82/%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%AD%E6%9F%A5%E7%9C%8B%E6%BA%90%E7%A0%81/","excerpt":"","text":"如何在idea中查看java的源码 默认idea配置好jdk后，就会默认配置好源码包 Ctrl+B即可直接查看 在方法上右键选择0—&gt;go to —&gt;declaration or usages 如果没有的话请手动点击菜单 File—&gt;project struct—&gt;SDKs—&gt;source Path","categories":[],"tags":[]},{"title":"super","slug":"JAVA/4-面向对象(中级)/3-this和super/2-super","date":"2022-10-20T16:01:24.000Z","updated":"2022-10-20T16:34:14.910Z","comments":true,"path":"2022/10/21/JAVA/4-面向对象(中级)/3-this和super/2-super/","link":"","permalink":"https://jhfuture.github.io/2022/10/21/JAVA/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%AD%E7%BA%A7)/3-this%E5%92%8Csuper/2-super/","excerpt":"","text":"一、基本介绍 super代表父类的引用，用于访问父类的属性、方法（均需要注意修饰符）、构造器（只能放在本类构造器的第一句）。 super会隐藏的出现在具有继承关系的子类的构造器中，即默认会调用父类的无参构造器 &#96;&#96;&#96;javapublic class father{father(){}}public class son extends father{son(){ super(); &#x3D;&#x3D;&#x3D;&#x3D;&gt;默认会有,}}1234567891011 2. ### 二、基本语法1. 访问父类的属性，但不能访问父类的private属性 1. super.属性名 2. ```java 访问父类的方法，但不能访问父类的private方法 super.方法名(参数列表) 访问父类的构造器 super(参数列表) 只能放在本类构造器的第一句，且在一个函数体内只能出现一句。 &#x3D;&#x3D;默认子类的构造器在本构造器的第一行就有一行super语句，调用父类的构造器&#x3D;&#x3D; 三、综合案例123456789101112131415161718192021222324252627282930313233343536package com.jhfuture.superAndthis;public class superDemo &#123; public static void main(String[] args) &#123; son son = new son(); //调用子类的有参 com.jhfuture.superAndthis.son son1 = new son(123); &#125;&#125;class father&#123; int age=10; father(int age)&#123; System.out.println(&quot;father的有参构造器被调用&quot;); &#125; father()&#123; System.out.println(&quot;父类的无参构造器&quot;); &#125; public void hello()&#123; System.out.println(&quot;hello&quot;); &#125;&#125;class son extends father&#123; son()&#123; //默认会调用父类的无参构造器 super(); //属性 System.out.println(super.age); //方法 super.hello(); &#125; //构造器 son(int input)&#123; super(123); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://jhfuture.github.io/categories/java/"}],"tags":[{"name":"super","slug":"super","permalink":"https://jhfuture.github.io/tags/super/"}]},{"title":"","slug":"MySQL/0-sql的一些特殊地方","date":"2022-10-18T12:39:09.099Z","updated":"2022-12-12T14:55:09.571Z","comments":true,"path":"2022/10/18/MySQL/0-sql的一些特殊地方/","link":"","permalink":"https://jhfuture.github.io/2022/10/18/MySQL/0-sql%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E5%9C%B0%E6%96%B9/","excerpt":"","text":"查询等于 select 字段 from 表明 where 字段&#x3D;”xxx” &#x3D;&#x3D;查询空值&#x3D;&#x3D; 注意:在数据库中 null 不能使用等号进行衡量,需要使用 is null 来进行判断.因为数据库中的 null 代表什么也没有，它并不是一个值，所以不能使用等号衡量。 即这种写法是错误的 select ename,empno,comm from emp where comm &#x3D; null; &#96;&#96;&#96;sqlmysql&gt; select ename,empno,comm from emp where comm is null;+——–+——-+——+| ename | empno | comm |+——–+——-+——+| SMITH | 7369 | NULL || JONES | 7566 | NULL || BLAKE | 7698 | NULL || CLARK | 7782 | NULL || SCOTT | 7788 | NULL || KING | 7839 | NULL || ADAMS | 7876 | NULL || JAMES | 7900 | NULL || FORD | 7902 | NULL || MILLER | 7934 | NULL |+——–+——-+——+10 rows in set (0.00 sec) 123456789101112131415161718 3. ==查询非空值== 1. **xxx is not null** 2. ```sql mysql&gt; select ename,empno,comm from emp where comm is not null; +--------+-------+---------+ | ename | empno | comm | +--------+-------+---------+ | ALLEN | 7499 | 300.00 | | WARD | 7521 | 500.00 | | MARTIN | 7654 | 1400.00 | | TURNER | 7844 | 0.00 | +--------+-------+---------+ 4 rows in set (0.00 sec) 一些运算的问题 在&#x3D;&#x3D;单行处理函数&#x3D;&#x3D; 中 ，如果 处理 时 &#x3D;&#x3D;有null 参与的运输结果都是null&#x3D;&#x3D; 案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243```sql # 结构 mysql&gt; select sal,comm from emp; +---------+---------+ | sal | comm | +---------+---------+ | 800.00 | NULL | | 1600.00 | 300.00 | | 1250.00 | 500.00 | | 2975.00 | NULL | | 1250.00 | 1400.00 | | 2850.00 | NULL | | 2450.00 | NULL | | 3000.00 | NULL | | 5000.00 | NULL | | 1500.00 | 0.00 | | 1100.00 | NULL | | 950.00 | NULL | | 3000.00 | NULL | | 1300.00 | NULL | +---------+---------+ 14 rows in set (0.00 sec) # 测试 mysql&gt; select sal+comm from emp; +----------+ | sal+comm | +----------+ | NULL | | 1900.00 | | 1750.00 | | NULL | | 2650.00 | | NULL | | NULL | | NULL | | NULL | | 1500.00 | | NULL | | NULL | | NULL | | NULL | +----------+ 14 rows in set (0.00 sec) 12345678910111213141516171819202122232425 3. 解决办法-----&gt; 使用 ifnull 进行处理,将null转换为一个具体的数值 ifnull(字段,转换的值) ```sql mysql&gt; select sal+ ifnull(comm,0) from emp; +---------------------+ | sal+ ifnull(comm,0) | +---------------------+ | 800.00 | | 1900.00 | | 1750.00 | | 2975.00 | | 2650.00 | | 2850.00 | | 2450.00 | | 3000.00 | | 5000.00 | | 1500.00 | | 1100.00 | | 950.00 | | 3000.00 | | 1300.00 | +---------------------+ 14 rows in set (0.00 sec) 二、MYSQL8 中修改密码 这里需要注意，mysql8 后取消了PASSWORD()函数。即不能用传统的含有password函数的方法进行修改。 MySQL8 可行的方案123456 ##设置认证密钥为空 ,该字段是加密的，无法直接修改1.UPDATE user SET authentication_string=&quot;&quot; WHERE user=&quot;root&quot;;##2.修改密码2.ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;newPassword&#x27;;##刷新权限3.flush privilege 传统方法（在mysql8及以上已经不适用） 通过mysqladmin修改密码 1mysqladmin -u root -p password &quot;newpassword&quot; 修改mysql数据库的user表 1UPDATE mysql.user set authentication_string = PASSWORD (&quot;newpassword) WHERE User = &quot;root&quot; and Host=&quot;localhost&quot;; 通过SET语句修改密码 12SET PASSWORD = PASSWORD (&quot;rootpwd&quot;);：","categories":[],"tags":[]},{"title":"SQL基本语句","slug":"MySQL/2-sql基本语句","date":"2022-10-18T05:33:07.263Z","updated":"2022-11-17T04:50:34.249Z","comments":true,"path":"2022/10/18/MySQL/2-sql基本语句/","link":"","permalink":"https://jhfuture.github.io/2022/10/18/MySQL/2-sql%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"[TOC] 一、数据库 什么是数据库？什么是数据库管理系统？什么是SQL？他们之间的关系是什么？ 123456789数据库： 英文单词DataBase，简称DB。按照一定格式存储数据的一些文件的组合。 顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据。数据库管理系统： DataBaseManagement，简称DBMS。 数据库管理系统是专门用来管理数据库中数据的，数据库管理系统可以对数据库当中的数据进行增删改查。常见的数据库管理系统： MySQL、Oracle、MS SqlServer、DB2、sybase等.... 简要来说就是程序猿通过sql语句–&gt;操控DBMS—-&gt;操作数据库 二、SQL 三者之间的简要关系 12345678910程序员需要学习SQL语句，程序员通过编写SQL语句，然后DBMS负责执行SQL语句，最终来完成数据库中数据的增删改查操作。SQL是一套标准，程序员主要学习的就是SQL语句，这个SQL在mysql中可以使用，同时在Oracle中也可以使用，在DB2中也可以使用。三者之间的关系？ DBMS--执行--&gt; SQL --操作--&gt; DB先安装数据库管理系统MySQL，然后学习SQL语句怎么写，编写SQL语句之后，DBMS对SQL语句进行执行，最终来完成数据库的数据管理。 SQL语句的分类 DQL： 数据查询语言（凡是带有select关键字的都是查询语句） select… DML：数据操作语言（凡是对表当中的数据进行增删改的都是DML）insert delete updateinsert 增delete 删update 改这个主要是操作表中的数据data。 DDL：数据定义语言凡是带有create、drop、alter的都是DDL。DDL主要操作的是表的结构。不是表中的数据。create：新建，等同于增drop：删除alter：修改这个增删改和DML不同，这个主要是对表结构进行操作。 TCL：是事务控制语言包括：事务提交：commit;事务回滚：rollback; DCL：是数据控制语言。例如：授权grant、撤销权限revoke…. MySQL常用命令 查看当前的mysql数据库版本 select version(); 登入账号 mysql -u root -p 查看mysql中有哪些数据库 : show databases; #注意：以分号结尾，分号是英文的分号。 1234567891011mysql&gt; show databases -&gt; ;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.01 sec) 选择使用某个数据库:。 mysql&gt; use mysql; Database changed 表示正在使用一个名字叫做test的数据库。 创建数据库 create databases xxxxx show databases 查看某个数据库下有哪些表 show tables *必须选择了某个数据库后才能使用 查看当前选择的数据库 select database(); 查看表的结构 &#96;&#96;&#96;mysqlmysql&gt; desc servers;+————-+———–+——+—–+———+——-+| Field | Type | Null | Key | Default | Extra |+————-+———–+——+—–+———+——-+| Server_name | char(64) | NO | PRI | | || Host | char(255) | NO | | | || Db | char(64) | NO | | | || Username | char(64) | NO | | | || Password | char(64) | NO | | | || Port | int | NO | | 0 | || Socket | char(64) | NO | | | || Wrapper | char(64) | NO | | | || Owner | char(64) | NO | | | |+————-+———–+——+—–+———+——-+9 rows in set (0.02 sec)123456789101112131415161718192021222324252627289. 导入.sql文件 1. 需要创建一个数据库 create database xxxx; 2. 选中该数据库 use xxxx; 3. source + 路径 ==不需要;== 10. 终止上一条语句 1. \\c 2. Ctrl +cz11. 退出mysql 1. exit12. 备份与恢复 ```sql 备份--&gt; dos下执行 mysqldump -u 用户名 -p -B 数据库1 数据库2 &gt; 路径/文件名 恢复数据库 Source 文件名.sql 13.删除数据库 1drop 三、数据库表12345678910111213141516171819202122数据库当中最基本的单元是表：table 什么是表table？为什么用表来存储数据呢？ 姓名 性别 年龄(列：字段) --------------------------- 张三 男 20 -------&gt;行（记录） 李四 女 21 -------&gt;行（记录） 王五 男 22 -------&gt;行（记录） 数据库当中是以表格的形式表示数据的。因为表比较直观。 任何一张表都有行和列： 行（row）：被称为数据/记录。 列（column）：被称为字段。 姓名字段、性别字段、年龄字段。 了解一下： 每一个字段都有：字段名、数据类型、约束等属性。字段名可以理解，是一个普通的名字，见名知意就行。 数据类型：字符串，数字，日期等，后期讲。 约束：约束也有很多，其中一个叫做唯一性约束，这种约束添加之后，该字段中的数据不能重复。 简单查询 select 字段名 from 表名; # 其中要注意：select和from都是关键字。 #字段名和表名都是标识符。 强调：对于SQL语句来说，是通用的，所有的SQL语句以“;”结尾。 SQL语句不区分大小写. select * from 表名 表示查询所有数据 &#96;&#96;&#96;mysql mysql&gt; select DNAME from dept; +————+ | DNAME | +————+ | ACCOUNTING | | RESEARCH | | SALES | | OPERATIONS | +————+ 4 rows in set (0.00 sec) 查询多个字段,使用逗号隔开所要查询的字段, &#96;&#96;&#96;&#96;mysqlmysql&gt; select DNAME,LOC from dept;+————+———-+| DNAME | LOC |+————+———-+| ACCOUNTING | NEW YORK || RESEARCH | DALLAS || SALES | CHICAGO || OPERATIONS | BOSTON |+————+———-+4 rows in set (0.00 sec)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 3. 查询所有 1. 把所有字段都写上 2. 使用* 1. select * from 表名 表示查询所有数据 2. 缺点: 1. 效率低 2. 可读性差 3. 在实际开发中不建议.------2. 给查询列起别名 &gt; 记住：select语句是永远都不会进行修改操作的。（因为只负责查询） 1. 给查询的列起别名：使用as关键字起别名。 1. ```mysql mysql&gt; select deptno,dname as deptname from dept; +--------+------------+ | deptno | deptname | +--------+------------+ | 10 | ACCOUNTING | | 20 | RESEARCH | | 30 | SALES | | 40 | OPERATIONS | +--------+------------+ 2. 只是将显示结果列明显示为deptname,原表列名还是叫dname. 3. as可以省略,使用空格代替 4. 假设起名的时候,别名有空格怎么办 1. 使用单\\双 引号括起来 2. 注意 1. 在所有的数据库中,字符串统一使用单引号括起来，==单引号==是标准,双引号在Oracle数据库中使用不了。但是在mysql中可以是使用 3. ```sql mysql&gt; select DNAME as &#x27;test name&#x27; from dept; +------------+ | test name | +------------+ | ACCOUNTING | | RESEARCH | | SALES | | OPERATIONS | +------------+ 4 rows in set (0.00 sec) 列表计算 1. +-*/ ---&gt; 字段\\*1212 2. ```mysql mysql&gt; select ename,sal*12 as yearsal from emp; +——–+———-+ | ename | yearsal | +——–+———-+ | SMITH | 9600.00 | | ALLEN | 19200.00 | | WARD | 15000.00 | | JONES | 35700.00 | | MARTIN | 15000.00 | | BLAKE | 34200.00 | | CLARK | 29400.00 | | SCOTT | 36000.00 | | KING | 60000.00 | | TURNER | 18000.00 | | ADAMS | 13200.00 | | JAMES | 11400.00 | | FORD | 36000.00 | | MILLER | 15600.00 | +——–+———-+ 14 rows in set (0.00 sec) 123456789101112131415--- 5. 条件查询 1. 不是将表中所有数据都查出来。是查询出来符合条件的。 2. 查询语法格式 1. ```mysql 查询语法格式： select 字段1,字段2,字段3.... from 表名 where 条件; 3. 条件符号 插叙相等 &#x3D; &#96;&#96;&#96;sql字符mysql&gt; select empno,ename,sal from emp where ename &#x3D; ‘smith’;+——-+——-+——–+| empno | ename | sal |+——-+——-+——–+| 7369 | SMITH | 800.00 |+——-+——-+——–+1 row in set (0.00 sec)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 2. 2. 不等于&lt;&gt;(sql中特殊的) / !=3. &lt; 小于 &lt;=小于等于 &gt;大于, &gt;=大于等于4. 取区间 1. between ...... and............两个值中间 1. 必须遵循``左小右大``,否则什么都查不到 2. between两端都是==闭区间== 2. 以上等同------==&gt; ==&gt;= .....&lt;=....== 3. ```sql mysql&gt; select empno,ename,sal from emp where sal between 800 and 2000; +-------+--------+---------+ | empno | ename | sal | +-------+--------+---------+ | 7369 | SMITH | 800.00 | | 7499 | ALLEN | 1600.00 | | 7521 | WARD | 1250.00 | | 7654 | MARTIN | 1250.00 | | 7844 | TURNER | 1500.00 | | 7876 | ADAMS | 1100.00 | | 7900 | JAMES | 950.00 | | 7934 | MILLER | 1300.00 | +-------+--------+---------+ 8 rows in set (0.00 sec) mysql&gt; select empno,ename,sal from emp where sal &gt;=800 and sal &lt;=2000; +-------+--------+---------+ | empno | ename | sal | +-------+--------+---------+ | 7369 | SMITH | 800.00 | | 7499 | ALLEN | 1600.00 | | 7521 | WARD | 1250.00 | | 7654 | MARTIN | 1250.00 | | 7844 | TURNER | 1500.00 | | 7876 | ADAMS | 1100.00 | | 7900 | JAMES | 950.00 | | 7934 | MILLER | 1300.00 | +-------+--------+---------+ 8 rows in set (0.00 sec) &#x3D;&#x3D;查询空值&#x3D;&#x3D; 注意:在数据库中 null 不能使用等号进行衡量,需要使用 is null 来进行判断.因为数据库中的 null 代表什么也没有，它并不是一个值，所以不能使用等号衡量。 即这种写法是错误的 select ename,empno,comm from emp where comm &#x3D; null; &#96;&#96;&#96;sqlmysql&gt; select ename,empno,comm from emp where comm is null;+——–+——-+——+| ename | empno | comm |+——–+——-+——+| SMITH | 7369 | NULL || JONES | 7566 | NULL || BLAKE | 7698 | NULL || CLARK | 7782 | NULL || SCOTT | 7788 | NULL || KING | 7839 | NULL || ADAMS | 7876 | NULL || JAMES | 7900 | NULL || FORD | 7902 | NULL || MILLER | 7934 | NULL |+——–+——-+——+10 rows in set (0.00 sec) 12345678910111213147. ==查询非空值== 1. ```sql mysql&gt; select ename,empno,comm from emp where comm is not null; +--------+-------+---------+ | ename | empno | comm | +--------+-------+---------+ | ALLEN | 7499 | 300.00 | | WARD | 7521 | 500.00 | | MARTIN | 7654 | 1400.00 | | TURNER | 7844 | 0.00 | +--------+-------+---------+ 4 rows in set (0.00 sec) 1. 并且 and 2. 或 or 一些问题 如果and 和or 同时出现,有优先级问题吗 查询工资大于2500,并且部门编号为10&#x2F;20的员工 &#96;&#96;&#96;sql 数据： 试验： mysql&gt; select ename,sal,deptno from emp where sal&gt;2500 and deptno&#x3D;20 or deptno&#x3D;10; +——–+———+——–+ | ename | sal | deptno | +——–+———+——–+ | JONES | 2975.00 | 20 | | CLARK | 2450.00 | 10 | | SCOTT | 3000.00 | 20 | | KING | 5000.00 | 10 | | FORD | 3000.00 | 20 | | MILLER | 1300.00 | 10 | +——–+———+——–+ 6 rows in set (0.00 sec) × sql 会先执行and，即sal&gt;2500，deptno=20，然后最后或deptn=10的，所以这里出现了sal小于2500的，但deptn=10的数据； 正确写法： 添加小括号 mysql&gt; select ename,sal,deptno from emp where sal&gt;2500 and (deptno=20 or deptno=10); +-------+---------+--------+ | ename | sal | deptno | +-------+---------+--------+ | JONES | 2975.00 | 20 | | SCOTT | 3000.00 | 20 | | KING | 5000.00 | 10 | | FORD | 3000.00 | 20 | +-------+---------+--------+ 4 rows in set (0.00 sec) 123452. 有！！！需要添加小括号 1. ```sql mysql&gt; select ename,sal,deptno from emp where sal&gt;2500 and (deptno=20 or deptno=10); and和or同时出现，and优先级较高。如果想让or先执行，需要加小括号。 in 包含 in不是一个区间，in后面跟的是一个具体的值的合集。 mysql&gt; select * from emp where deptno in(10,20); 不包含 not in &#x3D;&#x3D;模糊查询like&#x3D;&#x3D; 模糊查询，支持%或_进行查询 %代表任意多个字符(n个__) _代表任意一个字符 案例 找出名字中含有T的 mysql&gt; select * from emp where ename like &#39;%T%&#39;; +-------+--------+----------+------+------------+---------+---------+--------+ | EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO | +-------+--------+----------+------+------------+---------+---------+--------+ | 7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 | NULL | 20 | | 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 | | 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 | | 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 | +-------+--------+----------+------+------------+---------+---------+--------+ 4 rows in set (0.00 sec) 12345678910112. 以T结尾的 1. ```sql mysql&gt; select ename,job from emp where ename like &#x27;%T&#x27;; +-------+---------+ | ename | job | +-------+---------+ | SCOTT | ANALYST | +-------+---------+ 1 row in set (0.00 sec) 找出名字第三个为O的 &#96;&#96;&#96;sqlmysql&gt; select ename,job from emp where ename like ‘__O%’;+——-+———+| ename | job |+——-+———+| SCOTT | ANALYST |+——-+———+1 row in set (0.00 sec)12345678910111213141516171819 4. 找到名字中含有_的 1. 使用转义字符将_的本义去除 1. select name from student where like &#x27;%\\_%&#x27;15. 排序 order by 1. 语法格式 1. ```sql select ename,sal from emp order by sal desc; desc:降序 asc:升序（默认） 多字段排序 &#96;&#96;&#96;sql以两个字段排序吗？或者说按照多个字段排序？查询员工名字和薪资，要求按照薪资升序，如果薪资一样的话，再按照名字升序排列。selectename,salfromemporder bysal asc, ename asc; &#x2F;&#x2F; sal在前，起主导，只有sal相等的时候，才会考虑启用ename排序。1234563. ~~按字段位置排序（不推荐）~~ 1. ```sql select ename,sal from emp order by 2; 按照表中第二个位置的字段进行排序，默认为升序 综合案例 从emp中查询ename和sal字段，并筛选出sal大于1000的字段，并降序处理 select -- from -- where -- order by -- mysql&gt; select ename,sal from emp where sal&gt;1000 order by sal desc; +--------+---------+ | ename | sal | +--------+---------+ | KING | 5000.00 | | SCOTT | 3000.00 | | FORD | 3000.00 | | JONES | 2975.00 | | BLAKE | 2850.00 | | CLARK | 2450.00 | | ALLEN | 1600.00 | | TURNER | 1500.00 | | MILLER | 1300.00 | | WARD | 1250.00 | | MARTIN | 1250.00 | | ADAMS | 1100.00 | +--------+---------+ 12 rows in set (0.00 sec) $$","categories":[{"name":"mysql","slug":"mysql","permalink":"https://jhfuture.github.io/categories/mysql/"}],"tags":[{"name":"安装教程","slug":"安装教程","permalink":"https://jhfuture.github.io/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"}]},{"title":"安装mysql","slug":"MySQL/1.安装mysql","date":"2022-10-17T15:10:24.000Z","updated":"2022-10-18T05:33:00.824Z","comments":true,"path":"2022/10/17/MySQL/1.安装mysql/","link":"","permalink":"https://jhfuture.github.io/2022/10/17/MySQL/1.%E5%AE%89%E8%A3%85mysql/","excerpt":"","text":"[TOC] 一、下载 MySQL 打开mysql官网MySQL :: MySQL Downloads，选择 GPL版本下载 二、安装MySQL 选择安装类型 ***1. 选择设置类型*****“Developer Default”是开发者默认； “Server only”仅作为服务器安装； “Clientonly”仅作为客户端安装； “Full”是完整安装； “Custom”是自定义安装； 一路下一步即可 这里选择设置密码 设置密码 选择账户 配置权限 执行一些配置 配置mysql router（直接默认即可） 链接测试server，输入第三步中设置的密码 最后完成，出现cmd窗口和mysql workbench则成功 配置系统Path变量 找到mysql的安装路径，默认为 C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin 打开系统变量 此电脑右键属性—–&gt;关于–&gt;高级系统设置—–&gt;高级—–&gt;环境变量—&gt;选择Path,编辑—&gt;新建，把mysql的安装路径粘贴 按键 win+R ,输入cmd ，然后输入myssql，有反应即正常","categories":[{"name":"mysql","slug":"mysql","permalink":"https://jhfuture.github.io/categories/mysql/"}],"tags":[{"name":"安装教程","slug":"安装教程","permalink":"https://jhfuture.github.io/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"}]},{"title":"","slug":"JAVA/4-面向对象(中级)/5-继承/3-方法的重写","date":"2022-10-17T02:24:29.257Z","updated":"2022-11-08T11:19:37.007Z","comments":true,"path":"2022/10/17/JAVA/4-面向对象(中级)/5-继承/3-方法的重写/","link":"","permalink":"https://jhfuture.github.io/2022/10/17/JAVA/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%AD%E7%BA%A7)/5-%E7%BB%A7%E6%89%BF/3-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99/","excerpt":"","text":"一、方法重写方法重写也叫方法覆盖，需要满足下面的条件 重写是子类对&#x3D;&#x3D;父类的允许访问的方法&#x3D;&#x3D;的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 这里可以解释为什么 private 方法不能被重写，因为private 方法不能被子类访问。 子类的方法&#x3D;&#x3D;参数，方法名&#x3D;&#x3D;，要和父类的参数，方法名称完全一样。 参数（个数&#x2F;类别，顺序都要一样），&#x3D;&#x3D;否则就是方法的多态&#x3D;&#x3D;，而不构成重写！ 子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类。 eg: 父类返回的类型是Object,子类方法返回类型是 String 正确—-&gt;public Object getinfo() public String getinfo() 错误举例 &#96;&#96;&#96;javaclass hello{ public String say (String name){}}class t extends hello{ public Object say(String age){ }}error:say(String)’ in ‘com.jhfuture.object.Person.t’ clashes with ‘say(String)’ in ‘com.jhfuture.object.Person.hello’; attempting to use incompatible return type123456789101112131415161718 3. 3. 子类方法不能缩小父类方法的==访问权限== 1. 父类： void sayOk() 子类：public void sayOk() 1. ```java class hello&#123; public void say (String name)&#123;&#125; &#125; class t extends hello&#123; private void say(String age)&#123; &#125; &#125; &#125; ---&gt;报错 erro: &#x27;say(String)&#x27; in &#x27;com.jhfuture.object.Person.t&#x27; clashes with &#x27;say(String)&#x27; in &#x27;com.jhfuture.object.Person.hello&#x27;; attempting to assign weaker access privileges (&#x27;private&#x27;); was &#x27;public&#x27; 默认—-&gt; public public&gt;protected&gt; 默认&gt; private 总结 方法重写时，需要注意两个重要点，1是访问权限，2.返回类型，不同则报错。最后一个为参数，如果不同则只是方法的重载。 private 修饰的方法不能被重写，因为 在重写的概念中，需要 是 子类具有的父类的允许访问方法。private 修饰了那前提条件就不满足了。 static 修饰的方法也&#x3D;&#x3D;不会被覆盖&#x3D;&#x3D;。","categories":[],"tags":[]},{"title":"","slug":"JAVA/4-面向对象(中级)/5-继承/2-继承的本质","date":"2022-10-16T08:18:51.891Z","updated":"2022-11-03T03:10:51.641Z","comments":true,"path":"2022/10/16/JAVA/4-面向对象(中级)/5-继承/2-继承的本质/","link":"","permalink":"https://jhfuture.github.io/2022/10/16/JAVA/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%AD%E7%BA%A7)/5-%E7%BB%A7%E6%89%BF/2-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9C%AC%E8%B4%A8/","excerpt":"","text":"1234567891011121314public class ExtendTheory&#123;public static void main(String[] args) &#123; Son son=new Son(); &#125;&#125;class GrandPa&#123; String name=&quot;大头爷爷&quot;;&#125;class Father extends GrandPa &#123; String name=&quot;大头爸爸&quot;;&#125;class Son extends Father&#123; String name=&quot;大头儿子&quot;;&#125; 首先加载类信息&#x3D;&#x3D;从父类开始逐级向下&#x3D;&#x3D;&gt;GrandPa信息–&gt; Father—-&gt;son 在堆中开辟 内存空间 —-&gt; 储存GrandPa—&gt;储存 Father—&gt;储存son","categories":[],"tags":[]},{"title":"","slug":"Windows/3-内存优化","date":"2022-10-14T10:00:36.863Z","updated":"2022-07-20T10:55:16.843Z","comments":true,"path":"2022/10/14/Windows/3-内存优化/","link":"","permalink":"https://jhfuture.github.io/2022/10/14/Windows/3-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/","excerpt":"","text":"Windows内存优化一、fetcha) ​ 简介： 超级预读是系统会根据用户的使用习惯，将经常使用的程序和文件预加载到空闲的物理内存中，从而总体提高系统的速度。 b)操作 打开注册表编辑器 Win+R—&gt; regedit 打开路径 1HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management\\PrefetchParameters 修改 - 0 – 禁用 - 1 – 启用应用程序预读 - 2 – 启用系统引导预读 - 3 – 启用应用程序和系统引导预读 打开任务管理器，关闭sysmain服务 ctrl+shift+Esc启动任务管理器 服务 设置为禁止","categories":[],"tags":[]},{"title":"","slug":"JAVA/4-面向对象(中级)/5-继承/1-继承入门","date":"2022-10-14T09:54:56.521Z","updated":"2022-11-03T02:59:44.256Z","comments":true,"path":"2022/10/14/JAVA/4-面向对象(中级)/5-继承/1-继承入门/","link":"","permalink":"https://jhfuture.github.io/2022/10/14/JAVA/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%AD%E7%BA%A7)/5-%E7%BB%A7%E6%89%BF/1-%E7%BB%A7%E6%89%BF%E5%85%A5%E9%97%A8/","excerpt":"","text":"继承一、定义 二、基本使用1234class className extend furtherClassName)&#123; &#125; 三、继承的使用细节 子类继承了所有的属性和方法，非私有的属性和方法可以直接在子类中进行访问，但是私有属性和方法不能在子类直接访问，要通过&#x3D;&#x3D;父类提供&#x3D;&#x3D;的公共方法去访问。 子类必须调用父类的构造器，完成父类的初始化 在子类的构造器中会有 super 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器。如果父类没有提供无参构造器，则必须在子类的构造器中使用super去指定使用父类的哪个构造器完成对父类 如果父类中没有构造器，那编译器会自动添加一个空的同名构造器，如果父类中有其他构造器，则编译器不会创建空形参的同名构造器。 则下面这段代码就会报错 12345678910111213141516171819202122232425262728public class base &#123; public String n1=&quot;hello&quot;; protected String n2; String n3=&quot;n3&quot;; private String n4=&quot;n4&quot;; base(String name)&#123; &#125; //缺少无参构造器的显式创建&#125;//子类public class sub extends base&#123; public sub()&#123; System.out.println(n1+n2+n3+getn4()); &#125;&#125;//另一个类进行调用public class demo &#123; public static void main(String[] args) &#123; new sub(); &#125;&#125;//结果 java: 无法将类 com.jhfuture.extend.base中的构造器 base应用到给定类型; 需要: java.lang.String 找到: 没有参数 原因: 实际参数列表和形式参数列表长度不同 如果需要指定使用父类的构造器，在子类构造器中使用super() 调用无参构造器 —–&gt; super() &#x2F;什么都不写 调用有参构造器 ——&gt; super( parameter) super在使用时，需要放在&#x3D;&#x3D;构造器的第一行&#x3D;&#x3D;（且super只能在构造器中使用) super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器 Java所有类都是object类的子类，object是所有类的基类。 父类构造器的调用不限于直接父类！将一直往上追溯到object类（顶级父类） 子类最多只能继承一个父类（指直接继承），即java中是&#x3D;&#x3D;单继承机制&#x3D;&#x3D; 思考，如何让A类继承B类和C类。 A继承B–》继承C 不能滥用继承，子类和父类之间必须满足is-a的逻辑关系 animal Cat extents Animal 合理 Person is Music person extend &#x2F;&#x2F;不合理","categories":[],"tags":[]},{"title":"","slug":"JAVA/4-面向对象(中级)/1-包","date":"2022-10-14T09:25:16.067Z","updated":"2022-10-16T07:05:46.779Z","comments":true,"path":"2022/10/14/JAVA/4-面向对象(中级)/1-包/","link":"","permalink":"https://jhfuture.github.io/2022/10/14/JAVA/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%AD%E7%BA%A7)/1-%E5%8C%85/","excerpt":"","text":"包一、包的本质文件夹 二、导入包 按需导入 1import com.xxx.xxx.className; 完整导入 1import com.xxx.xxx 三、包的注意事项 命名规范： 不能含关键字 不能以数字开头 以数字、字母、下划线组成 java lang中的包是默认导入的。","categories":[],"tags":[]},{"title":"","slug":"Windows/安装office2016","date":"2022-10-14T09:23:55.335Z","updated":"2022-10-14T09:23:55.335Z","comments":true,"path":"2022/10/14/Windows/安装office2016/","link":"","permalink":"https://jhfuture.github.io/2022/10/14/Windows/%E5%AE%89%E8%A3%85office2016/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"硬件知识/文件系统FAT","date":"2022-10-13T15:37:00.401Z","updated":"2022-07-20T05:37:19.427Z","comments":true,"path":"2022/10/13/硬件知识/文件系统FAT/","link":"","permalink":"https://jhfuture.github.io/2022/10/13/%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FFAT/","excerpt":"","text":"● FAT16 优点：兼容性最好，某些数码设备可能对FAT32和NTFS格式的存储卡支持不太好，因此只能使用FAT16。 缺点：最大仅支持2GB分区，空间浪费大。 备注：赶紧看看U盘是不是FAT格式，如果是就改用FAT32吧！ ● FAT32 优点：兼容性好。 缺点：单个文件不能超过4GB，不支持512MB以下容量的U盘。 备注：如果U盘容量达8GB以上，发现4GB文件拷不进去的话，可以考虑换用NTFS或ExFAT格式了。 ● ExFAT 优点：专为闪存和U盘设计，空间浪费小。 ● NTFS 优点：兼容性好，支持任意大小的U盘。 缺点：会缩短闪存寿命。 备注：反正U盘超便宜，不怕坏的朋友们使用NTFS其实挺好。 FatFs和FAT32是什么关系？ 搞嵌入式的应该对FatFs并不陌生，那么肯定有人会问：FatFs和FAT32是什么关系？ 我们说的FatFs是指FAT Filesystem，是一个通用的文件系统(FAT&#x2F;exFAT)模块，用于在小型嵌入式系统中实现FAT文件系统。一种供MS-DOS及其它Windows操作系统对文件进行组织与管理的文件系统。 FAT 文件系统起源于 1980 年左右，是 MS-DOS 首先支持的文件系统。 而FAT32可以说是经过FatFs发展而来： ###一些操作 NTS格式无损数据转fat—分区助手","categories":[],"tags":[]},{"title":"安装Windows系统(使用微PE)","slug":"Windows/installWindows","date":"2022-10-13T12:00:24.000Z","updated":"2022-10-13T13:24:44.856Z","comments":true,"path":"2022/10/13/Windows/installWindows/","link":"","permalink":"https://jhfuture.github.io/2022/10/13/Windows/installWindows/","excerpt":"","text":"安装&#x2F;重装Windows系统[TOC] 一、制作ＰＥ系统盘 准备好一个U盘，并备份好其中的文件(制作启动盘时会清空u盘所有文件！！！！) 下载微PE工具箱 使用PE工具箱制作u盘 选择后点击确定 二、下载Windows镜像 打开msdn下载站 选择操作系统镜像 这里以Windows10镜像为演示 复制下载链接，并用迅雷打开 下载完成后复制到u盘中即可。 business为企业版，consumer为零售版，x64代表64位系统，x86为32位系统 ​ 三、重启电脑／开启需要安装的电脑，选择从Ｕ盘启动 上百度查询 &#x3D;&#x3D;xxxx电脑如何从U盘启动&#x3D;&#x3D;&#x3D;。这里以联想笔记本为例&#x3D;&#x3D;&gt; 开机时连续摁F12 进入PE后选择Windows安装器 选择第二步下载的iso镜像。&#x3D;&#x3D;》点击选择进行选择 第二栏和第三栏选择你要安装的磁盘分区即可。 显示安装完成&#x3D;&#x3D;&#x3D;&#x3D;》手动或自动重启即可。","categories":[{"name":"Windows使用技巧","slug":"Windows使用技巧","permalink":"https://jhfuture.github.io/categories/Windows%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://jhfuture.github.io/tags/Windows/"}]},{"title":"","slug":"JAVA/3-面向对象/3-方法的重载/1-方法的重载","date":"2022-10-12T16:57:53.262Z","updated":"2022-10-12T17:00:33.740Z","comments":true,"path":"2022/10/13/JAVA/3-面向对象/3-方法的重载/1-方法的重载/","link":"","permalink":"https://jhfuture.github.io/2022/10/13/JAVA/3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD/1-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD/","excerpt":"","text":"方法重载：即方法同名的方法： 特点： 方法名相同 形参列表：必须不同（形参类型或个数或顺序，至少其中的一类不同，参数名无要求（不影响）) 返回类型：无要求&#x3D;&#x3D;&#x3D;&gt;无法形成方法重载。","categories":[],"tags":[]},{"title":"","slug":"JAVA/3-面向对象/1-成员方法传参机制/1-基本数据类型","date":"2022-10-07T13:37:15.775Z","updated":"2022-07-20T13:41:42.358Z","comments":true,"path":"2022/10/07/JAVA/3-面向对象/1-成员方法传参机制/1-基本数据类型/","link":"","permalink":"https://jhfuture.github.io/2022/10/07/JAVA/3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6/1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"基本数据类型 基本数据类型： ​ 只有值拷贝。 内存空间： 本质是jvm中不同方法体的栈","categories":[],"tags":[]},{"title":"","slug":"IDEA/快捷键","date":"2022-10-07T12:11:27.397Z","updated":"2022-12-10T17:15:22.996Z","comments":true,"path":"2022/10/07/IDEA/快捷键/","link":"","permalink":"https://jhfuture.github.io/2022/10/07/IDEA/%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"IDEA的相关快捷键一、自带通用 1. ctrl +&#x2F; 注释 2. alt+/ 补全 3. import package自动导入包 1. ![image-20221007201550828](快捷键/image-20221007201550828.png)2022直接设置完即可，其他版本设置完后 ，在需要导入package的地方点击 ``alt +enter``即可 4. ctrl+alt+L 格式化代码 5. alt +insert 生成构造器 6. Ctrl +H 查看一个类的层级关系 1. 将鼠标放在想要查看的类上 2. 摁下 Ctrl + H 3. 生成可视图 鼠标右键--&gt;diagrams---&gt; show diagram 7. Ctrl+ B 查看方法所在的class 8. ==```.var 自动分配变量名```== 1. ``` java new Person().var ---&gt;回车 | |自动生成 ↓ Person Person= new Person(); ``` 9. Ctrl+j，显示 所有快捷键 的快捷键 10.创建 try catch ---&gt; c 11.全局搜索 快速点两下 shift 12.所搜当前文件夹 ---&gt; Ctrl +F12 ​ ​ ​ 二、自定义 1. ctrl+d删除当前行 ---&gt; delete 1. ctrl+alt + ↓ 复制当前行 -----&gt;duplicate 1. alt +R 快速运行 ---------&gt; run","categories":[],"tags":[]},{"title":"","slug":"vue/25-操作DOM/ref","date":"2022-10-06T14:21:05.998Z","updated":"2022-10-06T14:29:49.472Z","comments":true,"path":"2022/10/06/vue/25-操作DOM/ref/","link":"","permalink":"https://jhfuture.github.io/2022/10/06/vue/25-%E6%93%8D%E4%BD%9CDOM/ref/","excerpt":"","text":"ref属性 被用来给元素(纯粹的html元素)或子组件注册引用信息（id的替代者） 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc） html标签 使用docum.getElementByID()，与使用ref并无区别 组件 ☸ 如果使用docum.getElementByID()，则获取的只是该DOM元素&lt;div id=&quot;school&quot;&gt;&lt;h1&gt;学校名称:尚硅谷&lt;/h1&gt;&lt;/div&gt; 使用ref,则获取的是vc实例对象 vueCompont{xxxxxxxxxx} 使用方式： 打标识：&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt; 或 &lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt; 获取：this.$refs.xxx","categories":[],"tags":[]},{"title":"","slug":"vue/18-非文件组件/一个重要的内置关系","date":"2022-10-06T13:12:07.874Z","updated":"2022-10-06T13:42:42.114Z","comments":true,"path":"2022/10/06/vue/18-非文件组件/一个重要的内置关系/","link":"","permalink":"https://jhfuture.github.io/2022/10/06/vue/18-%E9%9D%9E%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E7%BD%AE%E5%85%B3%E7%B3%BB/","excerpt":"","text":"1.一个重要的内置关系：VueComponent.prototype.proto &#x3D;&#x3D;&#x3D; Vue.prototype 2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。 图示： ​ vue在vueComponet的原型对象与vue的原型对象中加了一条线 ​ 让vc能用到vue原型对象上的诸多优秀方法 一、验证该关系 123456789101112131415161718192021&lt;script&gt;var school=Vue.extend(&#123; name:&quot;school&quot;, template:` &lt;div&gt; &lt;h1&gt;school&lt;/h1&gt; &lt;/div&gt;`, data()&#123; return&#123; hello:&quot;hello&quot; &#125; &#125; &#125;)var vm=new Vue(&#123; el:&#x27;#root&#x27;, components:&#123;school,student&#125; &#125;) console.log(&quot;内置关系成立吗&quot;,school.prototype.__proto__===Vue.prototype); //true&lt;/script&gt; 二、原型链中的解释。 构造函数上的原型属性和 构造器所创建的对象上的隐式属性所指向的为同一个原型对象 123456789101112131415161718192021//定义一个构造函数 function Demo()&#123; this.a = 1 this.b = 2 &#125; //创建一个Demo的实例对象 const d = new Demo() console.log(Demo.prototype) //显示原型属性 console.log(d.__proto__) //隐式原型属性 console.log(Demo.prototype === d.__proto__) //t ----&gt;true; //程序员通过显示原型属性操作原型对象，追加一个x属性，值为99 Demo.prototype.x = 99 console.log(&#x27;@&#x27;,d) 二、内置关系的使用 全局事件总线","categories":[],"tags":[]},{"title":"","slug":"JavaScript/Promise/promiseAll和promiseRace","date":"2022-10-05T13:14:32.292Z","updated":"2022-10-05T14:19:40.437Z","comments":true,"path":"2022/10/05/JavaScript/Promise/promiseAll和promiseRace/","link":"","permalink":"https://jhfuture.github.io/2022/10/05/JavaScript/Promise/promiseAll%E5%92%8CpromiseRace/","excerpt":"","text":"PromiseApi的使用 API为处理异步操作而生 一、promiseAll(promiseArr) 12345promiseArr: 包含 n 个 promise 的数组 说明: 返回一个新的 promise, 只有所有的 promise`都成功才成功`且成功的value是所有promise成功的value的数组, 只要有一 个失败了就直接失败。 --》并且只要检测到失败的，就##立即返回##失败的promise 二、Promise.Race(promiseArr) promiseArr: 包含 n 个 promise 的数组 说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态, 和all方法一样，获取到当第一个完成的 promise 的结果状态，就立即返回 *&#x2F; 12345678910111213141516171819202122232425262728293031323334353637381. Promise 构造函数：new Promise(executor) executor 函数：是同步执行的，(resolve, reject) =&gt; &#123; &#125; resolve 函数：调用 resolve 将 Promise 实例内部状态改为成功(fulfiled)。 reject 函数：调用 reject 将 Promise 实例内部状态改为失败(rejected)。 说明：executor 函数会在 Promise 内部立即同步调用，异步代码放在 executor 函数中。2. Promise.prototype.then 方法：Promise 实例.then(onFulfilled, onRejected) onFulfilled：成功的回调函数 —— (value) =&gt; &#123; &#125; onRejected：失败的回调函数 —— (reason) =&gt; &#123; &#125; 注意：then 方法会返回一个新的 Promise 实例对象。 3.Promise.prototype.catch(onRejected) 方法 (1) onRejected 函数: 失败的回调函数(reason) =&gt; &#123; &#125; 说明: then()的语法糖, 相当于: then(undefined, onRejected) (2) 异常穿透使用: 当运行到最后, 没被处理的所有异常错误都会进入这个方法的回调函数中 const promise = new Promise((resolve, reject) =&gt; &#123; reject(new Error(&#x27;失败原因&#x27;)); &#125;); // promise.then( // undefined, //成功的回调可以是undefined // (reason) =&gt; &#123; console.log(`失败原因：$&#123;reason&#125;`); &#125; //失败的回调必须有，否则会报错 // ); // then()的语法糖 promise.catch((reason) =&gt; &#123; console.log(`失败原因：$&#123;reason&#125;`); &#125;) // 关于then()的成功回调为undefined问题new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;成功的value&#x27;); &#125;).then( undefined, //成功的回调undefined，但是Promise底层做了处理，加上了成功回调 value =&gt; value (reason) =&gt; &#123; console.log(&#x27;失败原因：&#x27;, reason); &#125; ).then( (value) =&gt; &#123; console.log(&#x27;成功的value：&#x27;, value); &#125;, (reason) =&gt; &#123; console.log(&#x27;失败原因：&#x27;, reason); &#125; )","categories":[],"tags":[]},{"title":"","slug":"JAVA/2-原、反、补码/三码","date":"2022-09-21T13:55:06.337Z","updated":"2022-09-21T14:01:54.402Z","comments":true,"path":"2022/09/21/JAVA/2-原、反、补码/三码/","link":"","permalink":"https://jhfuture.github.io/2022/09/21/JAVA/2-%E5%8E%9F%E3%80%81%E5%8F%8D%E3%80%81%E8%A1%A5%E7%A0%81/%E4%B8%89%E7%A0%81/","excerpt":"","text":"二进制的最高位是符号位 正数的三码合一 负数的反码&#x3D;符号位不变，其他位取反 or 补码-1 负数的补码&#x3D;反码+1， 0的反码、补码都是0 java没有无符号数，换言之，java中的数都是有符号的。 计算机在运算时，都是以补码的形式来运算的 在看运算结果时，要看他的原码(!!，最终呈现的是原码)","categories":[],"tags":[]},{"title":"","slug":"JAVA/0-Java细节/标识符命名规范","date":"2022-09-21T13:46:16.527Z","updated":"2022-09-21T13:46:50.011Z","comments":true,"path":"2022/09/21/JAVA/0-Java细节/标识符命名规范/","link":"","permalink":"https://jhfuture.github.io/2022/09/21/JAVA/0-Java%E7%BB%86%E8%8A%82/%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"JAVA/java的三元运算符","date":"2022-09-21T13:11:34.209Z","updated":"2022-09-21T13:15:58.350Z","comments":true,"path":"2022/09/21/JAVA/java的三元运算符/","link":"","permalink":"https://jhfuture.github.io/2022/09/21/JAVA/java%E7%9A%84%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"java与JavaScript中的三元运算符相似，这里只说注意的地方 TernaryoperatorDetail.Java 1xxx条件 ? 表达式1：表达式2 表达式1和表达式2要为可以赋给变量的类型（或可以自动转换&#x2F;或者强制换) 自动转换 int —&gt; double","categories":[],"tags":[]},{"title":"","slug":"JAVA/转义字符","date":"2022-09-21T12:49:10.287Z","updated":"2022-09-21T13:07:08.103Z","comments":true,"path":"2022/09/21/JAVA/转义字符/","link":"","permalink":"https://jhfuture.github.io/2022/09/21/JAVA/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/","excerpt":"","text":"java转义字符 常用 123456789\\t 制表位 \\n 换行\\\\ ： 一个\\\\&quot; ： 一个“\\&#x27; : 一个&#x27;\\r :一个回车//回车没有换行，以前的打字机在打完第一行字后，会把光标放回头部 12345System.out.println(&quot;韩顺平教育\\r北京&quot;) 运行顺序 --&gt;韩顺平教育↓(光标) ---&gt;↓韩顺平教育 ----------&gt; 北京平教育 计算机看到一个&#x2F;时，就会判断下一个字符为转义的。 注意： ​ 只有一个 1234567Eg:​//如果想输出两个//System.out.println(&quot;////hello&quot;) 编译器看到第一个\\时，看成是做转义的，第二个字符(有且只有一个)才是真正输出的字符。","categories":[],"tags":[]},{"title":"","slug":"vue/23-插件/2-路由/路由","date":"2022-09-15T11:50:42.443Z","updated":"2022-09-15T11:52:30.199Z","comments":true,"path":"2022/09/15/vue/23-插件/2-路由/路由/","link":"","permalink":"https://jhfuture.github.io/2022/09/15/vue/23-%E6%8F%92%E4%BB%B6/2-%E8%B7%AF%E7%94%B1/%E8%B7%AF%E7%94%B1/","excerpt":"","text":"##入门 安装 npm i vue-router (从2022&#x2F;2&#x2F;27起，vue-router 版本默认为4，只适合vue3使用，如果vue2直接安装将报依赖错误) npm i vue-router@3(vue2)","categories":[],"tags":[]},{"title":"vue组件","slug":"vue组件","date":"2022-09-15T10:41:53.000Z","updated":"2022-09-15T10:41:53.271Z","comments":true,"path":"2022/09/15/vue组件/","link":"","permalink":"https://jhfuture.github.io/2022/09/15/vue%E7%BB%84%E4%BB%B6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"vue/23-插件/vue中的插件","date":"2022-09-15T10:40:28.971Z","updated":"2022-09-15T11:48:37.223Z","comments":true,"path":"2022/09/15/vue/23-插件/vue中的插件/","link":"","permalink":"https://jhfuture.github.io/2022/09/15/vue/23-%E6%8F%92%E4%BB%B6/vue%E4%B8%AD%E7%9A%84%E6%8F%92%E4%BB%B6/","excerpt":"","text":"plugin引入vue中的插件，本质是一个包含了一个install方法的==对象==,install方法接受的第一个参数为==vue的构造函数==,其他参数为vue,use()传入的参数 1234567891011121314151617181920export default&#123;install(vue,options)&#123; // 1. 添加全局过滤器 Vue.filter(....) // 2. 添加全局指令 Vue.directive(....) // 3. 配置全局混入(合) Vue.mixin(....) // 4. 给vue原型上添加实例方法、添加 Vue.prototype.$myMethod = function () &#123;...&#125; Vue.prototype.$myProperty = xxxx &#125; &#125;//当使用 Vue.use时，将自动调用插件中的install方法 使用 导入插件(安装外挂) import abc from xxx 使用插件(开启外挂) Vue.use(abc)","categories":[],"tags":[]},{"title":"","slug":"vue/21-vuecli脚手架/vuecli","date":"2022-09-15T07:41:44.753Z","updated":"2022-10-06T13:59:22.078Z","comments":true,"path":"2022/09/15/vue/21-vuecli脚手架/vuecli/","link":"","permalink":"https://jhfuture.github.io/2022/09/15/vue/21-vuecli%E8%84%9A%E6%89%8B%E6%9E%B6/vuecli/","excerpt":"","text":"脚手架架构 ├── node_modules ├── public │ ├── favicon.ico: 页签图标 │ └── index.html: 主页面 ├── src │ ├── assets: 存放静态资源 │ │ └── logo.png │ │── component: 存放组件 │ │ └── HelloWorld.vue │ │── App.vue: 汇总所有组件 │ │── main.js: 入口文件 ├── .gitignore: git版本管制忽略的配置 ├── babel.config.js: babel的配置文件 ├── package.json: 应用包配置文件 ├── README.md: 应用描述文件 ├── package-lock.json：包版本控制文件 初始化 1234561.vue create projectName(不能使用大写字母)2.选择vue2/vue33.创建完成4.编写xxxx5.运行 cd projectName 6. npm run","categories":[],"tags":[]},{"title":"","slug":"vue/22-发送请求/1通过anxious发送请求","date":"2022-09-13T13:14:05.505Z","updated":"2022-09-13T13:14:05.505Z","comments":true,"path":"2022/09/13/vue/22-发送请求/1通过anxious发送请求/","link":"","permalink":"https://jhfuture.github.io/2022/09/13/vue/22-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/1%E9%80%9A%E8%BF%87anxious%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Vue组件中的通讯方式","slug":"vue/19-组件/2-组件之间的通信","date":"2022-09-06T13:52:51.000Z","updated":"2022-10-07T12:11:13.731Z","comments":true,"path":"2022/09/06/vue/19-组件/2-组件之间的通信/","link":"","permalink":"https://jhfuture.github.io/2022/09/06/vue/19-%E7%BB%84%E4%BB%B6/2-%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/","excerpt":"","text":"[TOC] 一、引入相互的组件之间一定会进行数据交互，那一定就会用到组件之间的通讯。 父子之间的通讯———————-&gt;a、a.1父给子，property直接传递 。a.2子给父，父先给子偷偷传递一个函数，然后子再调用该函数进行参数传递。&#x3D;&#x3D;或&#x3D;&#x3D; a.3父给子绑定自定义函数 b、使用全局总线 c、订阅消息 同级兄弟之间的通讯—————–&gt;a、全局总线 b、订阅消息 亲戚关系比较复制——————–&gt; a、全局总线 b、订阅消息 二、１．最简单的方法的方法————–property12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//使用//父--to--&gt;子&lt;student :propertyName=&quot;parameterName/functionName&quot;&gt;&lt;/student&gt;//子--accept--父props:[&quot;parameterName/functionName&quot;]//案例//父组件，使用property传递参数、函数，实现父子之间通讯&lt;MyFooter :todos=&quot;todos&quot; :checkAllTodo=&quot;checkAllTodo&quot; :clearAllTodo=&quot;clearAllTodo&quot;/&gt;//子组件,通过接收property，然后收到来自父的参数，并调用函数来传递方法。&lt;script&gt; export default &#123; name:&#x27;MyFooter&#x27;, props:[&#x27;todos&#x27;,&#x27;checkAllTodo&#x27;,&#x27;clearAllTodo&#x27;], computed: &#123; //总数 total()&#123; return this.todos.length &#125;, //已完成数 doneTotal()&#123; //此处使用reduce方法做条件统计 /* const x = this.todos.reduce((pre,current)=&gt;&#123; console.log(&#x27;@&#x27;,pre,current) return pre + (current.done ? 1 : 0) &#125;,0) */ //简写 return this.todos.reduce((pre,todo)=&gt; pre + (todo.done ? 1 : 0) ,0) &#125;, //控制全选框 isAll:&#123; //全选框是否勾选 get()&#123; return this.doneTotal === this.total &amp;&amp; this.total &gt; 0 &#125;, //isAll被修改时set被调用 set(value)&#123; this.checkAllTodo(value) &#125; &#125; &#125;, methods: &#123; /* checkAll(e)&#123; this.checkAllTodo(e.target.checked) &#125; */ //清空所有已完成 clearAll()&#123; this.clearAllTodo() &#125; &#125;, &#125;&lt;/script&gt; ２. 使用自定义事件给子组件的实例对象的绑定事件。 然后在子组件中用 this.$emit(&quot;functionName&quot;,parameter)进行调用 1234567891011121314151617//使用//父--to--&gt;子//方法一 直接写 //父&lt;student @functionName=&#x27;funName&#x27;&gt;&lt;/student&gt;//子this.$emit(&quot;fucNa&quot;)//方法二 通过ref//父&lt;student ref=&#x27;student&#x27;&gt;&lt;/student&gt;this.$ref.student.$on(&quot;functionName&quot;,parameterName)//子--accept--&gt;父this.$emit(&quot;functionName&quot;)//使用emit调用即可 3.使用全局总线123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//1. 在main.js中进行全局总线的挂载安装//引入Vueimport Vue from &#x27;vue&#x27;//引入Appimport App from &#x27;./App.vue&#x27;//关闭Vue的生产提示Vue.config.productionTip = false//创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render: h =&gt; h(App), beforeCreate() &#123; Vue.prototype.$bus = this //安装全局事件总线,尽量早的进行安装 &#125;,&#125;)//2. 在A组件中调用this.$bus.$on()绑定事件&lt;script&gt; export default &#123; name:&#x27;School&#x27;, data() &#123; return &#123; name:&#x27;尚硅谷&#x27;, address:&#x27;北京&#x27;, &#125; &#125;, mounted() &#123; // console.log(&#x27;School&#x27;,this) //在vc加载完成后就进行绑定 // tip: // 这里也需要注意this指向的问题，如果想this指向为当前vc，就使用箭头函数/写在methods中的函数（详细看前一篇） this.$bus.$on(&#x27;hello&#x27;,(data)=&gt;&#123; console.log(&#x27;我是School组件，收到了数据&#x27;,data) &#125;) &#125;, beforeDestroy() &#123; this.$bus.$off(&#x27;hello&#x27;) // //在beforedestroy是最好进行解绑 ,适当的给它减少压力 &#125;, &#125;&lt;/script&gt;//3. 在B组件中调用this.$bus.$emit()调用事件&lt;script&gt; export default &#123; name:&#x27;Student&#x27;, data() &#123; return &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27;, &#125; &#125;, mounted() &#123; // console.log(&#x27;Student&#x27;,this.x) &#125;, methods: &#123; sendStudentName()&#123; this.$bus.$emit(&#x27;hello&#x27;,this.name) &#125; &#125;, &#125;&lt;/script&gt; 这里简要说明一下全局总线的工作原理(及其要求)： 1. 全局总线的要求: - 全部组件都能访问到 - 可以调用 this.\\$on(FunctionName,function) 方法进行事件的绑定、this.\\$emit(fuctionName,parameter)方法进行方法的触发 ​ 2. 一个重要的内置关系： VueComponent.prototype.proto &#x3D;&#x3D;&#x3D; Vue.prototype ​ 2.1 为什么要有这个关系：—-&gt;让&#x3D;&#x3D;组件实例对象（vc）&#x3D;&#x3D;可以访问到 &#x3D;&#x3D;Vue原型&#x3D;&#x3D;上的属性、方法。 这里涉及到了一部分原型链的知识： 简要说明一下： 由构造函数创建的对像（这里为vueComponet创建的vc对象），可以通过 &#x3D;&#x3D;_proto_（隐形原型）&#x3D;&#x3D;访问到构造函数上的&#x3D;&#x3D;原型&#x3D;&#x3D; ​ 而构造函数自身可以通过 &#x3D;&#x3D;prototype（显示原型）&#x3D;&#x3D;直接访问自身的&#x3D;&#x3D;原型对象&#x3D;&#x3D; tip: Q:为什么不把$bus加在vc的原型上? ​ A:每一个vc是由vue构造函数中的extend函数每一次调用生成的,且 ​ ——&gt;每次调用vue.extend时,返回的都是一个全新的vuecomponent(即vc的构造函数) ​ —-&gt; 每次的构造函数都不同（详细看18章中的介绍) ​ ↓以下为原型链的知识 ​ —原型（prototype）本质上是存在于构造函数上的一个属性，如果每一个vc的构造函数（vueComponent）都不同，那每一个vc都有一个自己的原型(prototype)。 ​ final： ​ 如果加在某一个vc的原型上，则无法让每一个vc都能访问到。 ​ —-&gt;加在vm的原型上，由于vm的构造器只有一个，所以原型也只有一个。 ​ 再通过 VueComponent.prototype.proto &#x3D;&#x3D;&#x3D; Vue.prototype 这个关系，则可以让每一个vc都能成功访问到。 123456789101112131415、//以下为说明原型链中原型属性&lt;script&gt; function demo()&#123; this.a=1; &#125; //创建一个demo的实例对象 const d=new Demo() console.log(demo.prototype) //显示原型属性 console.log(p.__proto__) //隐私原型属性 //两个属性指向的是同一个原型对象，显示和隐式是对属性的修饰， //------&gt; 不能说“显示原型对象”/“隐式原型对象”，这样子会误以为有两个原型对象 console.log(demo.prototype==p.__proto__) //----&gt; tr&lt;/script&gt; 4. 使用订阅信息推送。 订阅消息与全局总线的原理相近，这里不展开叙说，只说明简要的使用方法 安装pubsub：npm i pubsub-js 引入: import pubsub from &#39;pubsub-js&#39; 接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身。 1234567methods()&#123; demo(data)&#123;......&#125;&#125;......mounted() &#123; this.pid = pubsub.subscribe(&#x27;xxx&#x27;,this.demo) //订阅消息&#125; 提供数据：pubsub.publish(&#39;xxx&#39;,数据) 最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid)去取消订阅。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue组件","slug":"Vue组件","permalink":"https://jhfuture.github.io/tags/Vue%E7%BB%84%E4%BB%B6/"}]},{"title":"Vue绑定样式","slug":"vue/08-绑定样式/绑定样式","date":"2022-09-04T10:58:14.000Z","updated":"2022-09-15T12:13:42.899Z","comments":true,"path":"2022/09/04/vue/08-绑定样式/绑定样式/","link":"","permalink":"https://jhfuture.github.io/2022/09/04/vue/08-%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F/%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"一、引入 网页的组件元素的样式通常由 1. 绑定class，然后通过css文件书写，或者 2. 直接在标签中书写style。 如果我们想要修改样式，无非也是改动他们。在jquery&#x2F;JavaScript中我们可以通过直接操作DOM元素实现，而在vue中，vue帮我们实现了虚拟DOM的操作，使得我们可以不用去直接操作DOM来实现这个功能。 在vue中我们使用：a)class绑定与、b)style绑定进行实现 tips : 如果原本就有class属性，那使用:class&#x3D;xxx时，只会在原来的基础上进行添加，而不会覆盖 二、实现1. 通过:class=&#39;xxx&#39;实现、xxx可以是字符串、数组、对象。 通过字符串实现适用于：只有一个，但是类名不确定，需要动态获取 123456789101112&lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt;new Vue(&#123;methods: &#123; changeMood()&#123; const arr = [&#x27;happy&#x27;,&#x27;sad&#x27;,&#x27;normal&#x27;] const index = Math.floor(Math.random()*3) this.mood = arr[index] &#125; &#125;,&#125;) 通过数组实现，适用于：需要绑定多个属性，且数量未知，类名未知。 12345678 &lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt;new Vue(&#123;data:&#123;return&#123;classArr:[&#x27;normal&#x27;,&#x27;bad&#x27;,&quot;good&quot;]&#125;&#125;&#125;) 通过对象实现，使用于：要绑定的个数确定(通常情况，但也可以添加)，类名确定，但要动态决定用不用 12345678910111213141516&lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt;new Vue(&#123;data:&#123;return&#123;classObj:&#123; atguigu1:false, atguigu2:false, &#125;,&#125;&#125;&#125;) 2. 通过style实现 :style=&#123;xxx&#125;,xxx可以是对象、对象数组 通过配置对象 1234 &lt;div class=&quot;basic&quot; :style=&quot;styleObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt;styleObj2:&#123; backgroundColor:&#x27;orange&#x27; &#125;, 通过数组对线 12345678910 &lt;div class=&quot;basic&quot; :style=&quot;styleArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;styleArr:[ &#123; fontSize: &#x27;40px&#x27;, color:&#x27;blue&#x27;, &#125;, &#123; backgroundColor:&#x27;gray&#x27; &#125; ] scope属性 组件之间难免会存在相同的类名，或者id名，那怎么解决呢？，vue中为我们提供了一个scope属性，在每个组件的 中添加 scope属性，即可使 当前界面的样式只会在当前页面生效 1&lt;script scope&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"},{"name":"vue绑定样式","slug":"vue绑定样式","permalink":"https://jhfuture.github.io/tags/vue%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F/"}]},{"title":"Vue中使用本地存储","slug":"vue/20-本地储存/localstorage","date":"2022-09-03T13:16:37.559Z","updated":"2022-09-13T12:06:50.491Z","comments":true,"path":"2022/09/03/vue/20-本地储存/localstorage/","link":"","permalink":"https://jhfuture.github.io/2022/09/03/vue/20-%E6%9C%AC%E5%9C%B0%E5%82%A8%E5%AD%98/localstorage/","excerpt":"","text":"webStorage 存储内容大小一般支持5MB左右（不同浏览器可能还不一样） 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。 相关API： localxlocalStorage.setItem(&#39;key&#39;, &#39;value&#39;); 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。 localStorage.getItem(&#39;person&#39;); 该方法接受一个键名作为参数，返回键名对应的值。 localStorage.removeItem(&#39;key&#39;); 该方法接受一个键名作为参数，并把该键名从存储中删除。 localStorage.clear() 该方法会清空存储中的所有数据。 备注： SessionStorage存储的内容会随着浏览器窗口关闭而消失。 LocalStorage存储的内容，需要手动清除才会消失。 localStorage.getItem(xxx)如果xxx对应的value获取不到，那么getItem的返回值是null。 JSON.parse(null)的结果依然是null。 总结 session————&gt; 对话，网页结束后就消失了，而localstorage————&gt; 不删除就不会消失 如果是一个对象，那需要使用JSON.stringfy()转换为字符串，然后再储存， 同时，在读取时，需要使用JSON.parse()进行解析，然后再使用，否则会发生类型问题 这里 ‘test’本来应该是object类型，但储存的时候进行了转换，而读取时没有进行转换，则最终读取的数据，类型为 ‘String’","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"本地储存","slug":"本地储存","permalink":"https://jhfuture.github.io/tags/%E6%9C%AC%E5%9C%B0%E5%82%A8%E5%AD%98/"}]},{"title":"","slug":"部门招新","date":"2022-08-21T07:12:50.568Z","updated":"2022-08-21T13:51:41.090Z","comments":true,"path":"2022/08/21/部门招新/","link":"","permalink":"https://jhfuture.github.io/2022/08/21/%E9%83%A8%E9%97%A8%E6%8B%9B%E6%96%B0/","excerpt":"","text":"[TOC] 一、部门职能 科教招新项目的开发 广师大网页管理 贴上我们的作品 二、部门的招新要求 &#x3D;&#x3D;自身具有明确的职业规划&#x3D;&#x3D;,将来从事软件开发相关的职业。 &#x3D;&#x3D;对编程具有较高的兴趣&#x3D;&#x3D;，小白也没关系，部门内有学长学姐专业指导。 &#x3D;&#x3D;不好高骛远，脚踏实地&#x3D;&#x3D;，做到认真并按时的完成部门任务。 &#x3D;&#x3D;具有一定的自主学习能力&#x3D;&#x3D;遇到问题及时沟通。 &#x3D;&#x3D;乐观积极，百折不挠&#x3D;&#x3D;，希望你能在变强的路上越走越远 三、成员介绍1.正部 副部，以下排名不分先后 2.xxxx 3.xxxx 4.xxxx 四、部门活动介绍谁说程序猿都是冷冰冰的一群人，我们也有许多有趣的时刻。 部门合照 部门团建 团建的大pizza！ 2.团建的奶茶+烧烤！ 团建一起玩游戏！！！ 3.他们都说程序猿各个都是直男直女，莫得感情，但我们！会在元宵节给每一位小骨干送上一碗**&#x3D;&#x3D;温馨的小汤圆&#x3D;&#x3D;**！！！！ 五、结尾1.鼓舞 加入网络研发部，一起在验前端编程学习的海洋里遨游， 如果你已经确定在IT行业方向发展 我们能让你 在前端学习上领先于同专业同学 我们还能帮你 解答C&#x2F;C++、Java编程语言学习上的疑惑 还在犹豫什么！ 报名方式 点击下方的小程序链接，选择投递**&#x3D;&#x3D;网络研发部&#x3D;&#x3D;**吧！","categories":[],"tags":[]},{"title":"rem适配方案","slug":"前端三剑客/rem适配方案","date":"2022-08-20T13:11:26.970Z","updated":"2022-09-13T12:16:21.624Z","comments":true,"path":"2022/08/20/前端三剑客/rem适配方案/","link":"","permalink":"https://jhfuture.github.io/2022/08/20/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/rem%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/","excerpt":"","text":"自适应 实现方法技术方案一：- less - 媒体查询 - 人 技术方案2（推荐） - flexible.js - rem 总结： 1. 两种方案都存在 1. 方案二更加简单 动态设置html标签font-size大小 ​ rem实际开发的适配方案 rem&#x3D; 页面元素值(px)&#x2F;(屏幕宽度&#x2F;划分的分数) 案例","categories":[{"name":"前端三剑客","slug":"前端三剑客","permalink":"https://jhfuture.github.io/categories/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/"}],"tags":[{"name":"rem适配","slug":"rem适配","permalink":"https://jhfuture.github.io/tags/rem%E9%80%82%E9%85%8D/"}]},{"title":"Less的使用","slug":"前端三剑客/less","date":"2022-08-20T12:31:32.369Z","updated":"2022-09-13T12:18:10.913Z","comments":true,"path":"2022/08/20/前端三剑客/less/","link":"","permalink":"https://jhfuture.github.io/2022/08/20/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/less/","excerpt":"","text":"一、 Less是什么 ​ css的扩展语言 二、less的使用 1. 变量 1. 变量时没有固定的值，可以改变的。 &gt; 1.书写less文件： &gt; &gt; ​ @变量名 ：值 &gt; &gt; 2. 2. 命名规范 1. ==**必须有@前嘴==** 2. 不能包含特殊字符 3. 不能以数字开头 4. 大小写敏感 3. 案例 12345@color:pink.p&#123;color:@color&#125; 2. Less嵌套 ​ 123456789101112131415&lt;!-- 1.子元素的样式直接写在父元素里面就好--&gt;.header&#123; color:red; a&#123; background-color:pink;&#125;&#125;添加伪类选择器&lt;!-- 如果有伪类选择器、交集选择器、伪类选择器 使用**==&amp;==**---&gt; 内层选择器的前面需要加 ==&amp;==.header&#123; a&#123; &amp;:hover&#123; &#125; &#125;&#125; ![image-20220820210222137](less/image-20220820210222137.png) 3. ==**Less运算**==☆ 1. \\+ \\- \\* / 2. 运算顺序与四则运算相同，都是先乘数，后加减 ![image-20220820210628143](less/image-20220820210628143.png) **注意：** 1. ==**运算符中间有空格隔开 1 px + 5**== 2. 对于不同的单位直接的运算，运算结果取==第一个值==的单位 ​ ![image-20220820210724170](less/image-20220820210724170.png) @import 导入另一个样式文件（less）文件 最后一定要加&#x3D;&#x3D;;&#x3D;&#x3D; 12@import &quot;css文件&quot; ; //把一个样式文件导入到本样式文件中//link 将一个样式文件引入到html页面 编译less Vscode 的easy less插件 安装 ​ 2. 插件会自动将less编译成一个css文件","categories":[{"name":"前端三剑客","slug":"前端三剑客","permalink":"https://jhfuture.github.io/categories/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/"}],"tags":[{"name":"Less","slug":"Less","permalink":"https://jhfuture.github.io/tags/Less/"},{"name":"css扩展","slug":"css扩展","permalink":"https://jhfuture.github.io/tags/css%E6%89%A9%E5%B1%95/"}]},{"title":"电脑像素比的知识","slug":"前端三剑客/物理像素&物理像素比","date":"2022-08-20T12:08:34.932Z","updated":"2022-09-13T12:17:23.705Z","comments":true,"path":"2022/08/20/前端三剑客/物理像素&物理像素比/","link":"","permalink":"https://jhfuture.github.io/2022/08/20/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/%E7%89%A9%E7%90%86%E5%83%8F%E7%B4%A0&%E7%89%A9%E7%90%86%E5%83%8F%E7%B4%A0%E6%AF%94/","excerpt":"","text":"物理像素比 电脑上当缩放比例为100%时，1px（css像素）则为电脑屏幕上的1个像素大小 Windows10会自动将缩放比例调整为100%以上，例如125% 而手机上使用了视网膜技术。 1px(css像素)，在手机上显示的结果&#x3D;1px*像素缩放比 iphone8 : 1px(css像素)*2&#x3D;2 Tip:相当于直接把图片、文字这些放大两倍 二倍图 如果直接将图片放大两倍，那可能就会变模糊，那怎么解决这个问题？ 我们放一个100*100的，然后手动将这个图片缩小为50*50(css像素)，最终显示在屏幕上的是50(css像素)*2，显示的结果就是实际图片的效果 背景的缩放 background-size: 图片的宽度 图片的高度 background-size: 图片宽度 (auto，默认)","categories":[{"name":"软/硬件知识","slug":"软-硬件知识","permalink":"https://jhfuture.github.io/categories/%E8%BD%AF-%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"像素比大小","slug":"像素比大小","permalink":"https://jhfuture.github.io/tags/%E5%83%8F%E7%B4%A0%E6%AF%94%E5%A4%A7%E5%B0%8F/"}]},{"title":"Javascript中的原型链","slug":"JavaScript/原型链/原型链","date":"2022-07-30T14:13:23.353Z","updated":"2022-09-13T12:19:07.575Z","comments":true,"path":"2022/07/30/JavaScript/原型链/原型链/","link":"","permalink":"https://jhfuture.github.io/2022/07/30/JavaScript/%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"一、何为原型链？JavaScript中的原型关系 二、原型链的解释 对象可以由a构造函数、b对象方法创建 来看下图。 f1和f2是function foo创建的对象。 1.","categories":[{"name":"前端三剑客","slug":"前端三剑客","permalink":"https://jhfuture.github.io/categories/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/"},{"name":"javascript进阶知识","slug":"前端三剑客/javascript进阶知识","permalink":"https://jhfuture.github.io/categories/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/javascript%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"原型链","slug":"原型链","permalink":"https://jhfuture.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"Vue中组件入门","slug":"vue/19-组件/1.组件的生成","date":"2022-07-29T11:30:12.409Z","updated":"2022-09-13T13:13:44.054Z","comments":true,"path":"2022/07/29/vue/19-组件/1.组件的生成/","link":"","permalink":"https://jhfuture.github.io/2022/07/29/vue/19-%E7%BB%84%E4%BB%B6/1.%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E6%88%90/","excerpt":"","text":"模块 单文件组件与非单文件组件1.单文件组件：​ 一个文件只包含一个组件 ——&gt;a.html 2. 非单文件组件​ 一个文件中包含n个组件 ——&gt;a.vue Vuecomponent构造器的生成过程​ 创建vue组件时，cost componentName &#x3D;Vue.extend() ——————————&gt;调用了Vue.extend这个方法,而这个方法的源码每次调用都生成了一个新的VueComponent","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"vue组件","slug":"vue组件","permalink":"https://jhfuture.github.io/tags/vue%E7%BB%84%E4%BB%B6/"}]},{"title":"带你领略Vue的风骚之路","slug":"vue/17-Vue生命周期/Vue生命周期详解","date":"2022-07-29T06:58:51.000Z","updated":"2022-07-29T08:29:15.699Z","comments":true,"path":"2022/07/29/vue/17-Vue生命周期/Vue生命周期详解/","link":"","permalink":"https://jhfuture.github.io/2022/07/29/vue/17-Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"先看完整的图。 逐步解析​ 1.Vue的初始化，两个生命周期函数 beforecreate：在数据代理、数据监测之前 created：在完成数据代理、数据监测后 Vue开始解析模块 ​ Vue开始处理 插值语法、插值指令、计算属性…… ——&gt;不显示解析好的内容 —— ​ ————————&gt;这个过程进行虚拟DOM的生存 将虚拟DOM转换为真实DOM插入界面 ​ 上一步生成的虚拟DOM，Vue存了一份在vm.$el中，然后再用它来替换掉真实的那个el(绑定的模块) ​ ————————&gt;存在vm.$el中的虚拟DOM为后续的 虚拟DOM比较——&gt;即diff 提供准备 Vue的初始化完成，开始执行mounted生命周期函数。 ​ ——————开启定时器，发送网络请求…… 检测变化 ——————&gt;这是一个闭环的过程 销毁Vue destroy介绍 细节一：注意： 这里的事件监听器——&gt;指的是自定义事件 我们在 new Vue( method:{} 配置的方法都是原生的DOM事件，例如 123456789101112&lt;button @click=&quot;add&quot;&gt;点我n+1&lt;/button&gt;&lt;script&gt; new Vue( method:&#123; add()&#123; console.log(&#x27;add&#x27;) this.n++ &#125;,&#125;&lt;/script&gt; 注意： ​ 当vue执行时，最终会给button绑定 DOM原生的点击事件，这个事件是原生DOM上的，vue被杀死多少回都不会对其造成影响。 ​ 一个形象的比喻 几个要注意的细节细节一：注意：这里的事件监听器——&gt;指的是自定义事件 我们在 new Vue( method:{} 配置的方法都是原生的DOM事件，例如 123456789101112&lt;button @click=&quot;add&quot;&gt;点我n+1&lt;/button&gt;&lt;script&gt; new Vue( method:&#123; add()&#123; console.log(&#x27;add&#x27;) this.n++ &#125;,&#125;&lt;/script&gt; 注意： ​ 当vue执行时，最终会给button绑定 DOM原生的点击事件，这个事件是原生DOM上的，vue被杀死多少回都不会对其造成影响 细节二12345678910beforeDestroy() &#123; /* 这里还能得到vm上的数据和方法，但是 修改后数据，页面不会刷新了。 ——&gt;因为vue已经进入销毁了，不会再加载 beforeupdata和update函数 */ console.log(&#x27;beforeDestory&#x27;); console.log(this.n); this.add(); &#125;,","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"},{"name":"硬核知识","slug":"硬核知识","permalink":"https://jhfuture.github.io/tags/%E7%A1%AC%E6%A0%B8%E7%9F%A5%E8%AF%86/"}]},{"title":"","slug":"vue/15-内部指令/2.v-html","date":"2022-07-28T14:22:11.862Z","updated":"2022-07-20T03:44:04.848Z","comments":true,"path":"2022/07/28/vue/15-内部指令/2.v-html/","link":"","permalink":"https://jhfuture.github.io/2022/07/28/vue/15-%E5%86%85%E9%83%A8%E6%8C%87%E4%BB%A4/2.v-html/","excerpt":"","text":"cookie简略图示","categories":[],"tags":[]},{"title":"","slug":"vue/12-列表渲染/Vue.set","date":"2022-07-28T07:44:35.966Z","updated":"2022-07-28T07:45:31.831Z","comments":true,"path":"2022/07/28/vue/12-列表渲染/Vue.set/","link":"","permalink":"https://jhfuture.github.io/2022/07/28/vue/12-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/Vue.set/","excerpt":"","text":"1.局限性 对象不能是vm &#x2F; vm的根数据对象(vm._data)","categories":[],"tags":[]},{"title":"姓名实例_methods","slug":"vue/07-计算属性/03.姓名案例_计算属性","date":"2022-07-28T07:01:14.000Z","updated":"2022-07-28T07:01:54.262Z","comments":true,"path":"2022/07/28/vue/07-计算属性/03.姓名案例_计算属性/","link":"","permalink":"https://jhfuture.github.io/2022/07/28/vue/07-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/03.%E5%A7%93%E5%90%8D%E6%A1%88%E4%BE%8B_%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/","excerpt":"通过一个实例，简要介绍计算属性","text":"通过一个实例，简要介绍计算属性 ​ 1.定义：要用的属性不存在，要通过已有属性计算得来 ​ 2.原理；底层借助了object.defineproperty方法提供的getter和setter ​ 3.get函数什么时候执行 ​ (1).初次读取时会执行一次 ​ (2).当依赖的数据发生改变时会被再次调用 ​ 4.优势：与methods相比，内部有缓存机制（复用），效率更高，调式方便 ​ 5.备注： ​ (1).计算属性最终会出现在vm上，直接读取&#x2F;操作使用即可 ​ (2).如果计算属性要被修改，那必须写在set函数去响应修改， ​ 且set中药引起&#x3D;&#x3D;计算时依赖的数据&#x3D;&#x3D;发生改变 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div id=&quot;root&quot;&gt; 姓 &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br&gt; 名 &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br&gt; 测试 &lt;input type=&quot;text&quot; v-model=&quot;x&quot;&gt; &lt;br&gt; 全名 &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt; 全名 &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt; 全名 &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt; &lt;!-- //计算属性的get什么时候被调用？ 1.除此读取fullname时，后面使用时会进行缓存。 2.所以来的数据发生改变时 --&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTip = false //阻止vue在启动时生成生产提示 const vm =new Vue(&#123; el: &#x27;#root&#x27;, data: &#123; firstName: &#x27;张&#x27;, lastName: &#x27;三&#x27;, x:1 &#125;, computed:&#123; fullName:&#123; //get有什么用？当有人读取fullname时就会被调用，返回值就作为fullname的值 //get什么时候被调用？ // 1.除此读取fullname时。 // 2.所以来的数据发生改变时 get()&#123; console.log(&quot;get被调用了&quot;); console.log(this);//此处this是mv实例 return this.firstName+&#x27;-&#x27;+this.lastName // 这里用到的值为 firstNmae、lastName &#125;, //set有什么用？当fullName被修改 //set什么时候被调用？ set(value)&#123; const arr=value.split(&#x27;-&#x27;) this.firstName=arr[0] this.lastName=arr[1] &#125; &#125; &#125; // 计算属性，和data/methods不一样，它不是直接放在vm上， // 而是调用了get方法，得到返回值后再将返回值放在vm上 &#125;) &lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"}]},{"title":"Vue的开始","slug":"vue/11-条件渲染/条件渲染","date":"2022-07-28T06:25:14.000Z","updated":"2022-07-28T06:28:05.157Z","comments":true,"path":"2022/07/28/vue/11-条件渲染/条件渲染/","link":"","permalink":"https://jhfuture.github.io/2022/07/28/vue/11-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/","excerpt":"Vue条件渲染 v-if与 v-show","text":"Vue条件渲染 v-if与 v-show ​ 条件渲染： ​ 1.v-if ​ 写法： ​ (1).v-if&#x3D;”表达式” ​ (2).v-else-if&#x3D;”表达式” ​ (3).v-else&#x3D;”表达式” ​ 适用于：切换频率较低的场景。 ​ 特点：不展示的DOM元素直接被移除。（不会出现在HTML文件中） ​ 注意：v-if可以和:v-else-if、v-else一起使用，但要求&#x3D;&#x3D;结构不能被“打断”&#x3D;&#x3D;。 ​ 2.v-show ​ 写法：v-show&#x3D;”表达式” ​ 适用于：切换频率较高的场景。 ​ 特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉（display：none） ​ ​ 3.v-if可以和template配合使用，使多个元素一起显示&#x2F;隐藏，而不影响布局 ​ 4.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。 ​ 因为 v-show，还存在于页面中，而v-if没有 v-if1234567891011121314151617&lt;!-- 使用v-if坐条件渲染 --&gt; &lt;div v-if=&quot;表达式&quot;&gt; &lt;/div&gt; &lt;div v-if=&quot;false&quot;&gt; &lt;/div&gt; &lt;div v-if=&quot;1===1&quot;&gt; &lt;/div&gt; &lt;!-- v-else和v-else-if --&gt; &lt;div v-if=&quot;false&quot;&gt; &lt;/div&gt; &lt;div v-elseif=&quot;1===1&quot;&gt; &lt;/div&gt; &lt;!-- v-if,template配套使用，不破坏布局 --&gt; &lt;template v-if=&quot;show&quot;&gt; &lt;h2&gt;nihao$&lt;/h2&gt; &lt;h2&gt;nihao$&lt;/h2&gt; &lt;h2&gt;nihao$&lt;/h2&gt; &lt;/template&gt; v-show123456&lt;!-- 使用v-show做条件渲染 --&gt; &lt;div v-show=&quot;表达式&quot;&gt; &lt;/div&gt; &lt;div v-show=&quot;false&quot;&gt; &lt;/div&gt; &lt;div v-show=&quot;1===1&quot;&gt; &lt;/div&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://jhfuture.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"class和style样式绑定","slug":"vue/10.绑定样式/class和style样式绑定","date":"2022-07-28T06:18:14.000Z","updated":"2022-07-28T06:20:25.476Z","comments":true,"path":"2022/07/28/vue/10.绑定样式/class和style样式绑定/","link":"","permalink":"https://jhfuture.github.io/2022/07/28/vue/10.%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F/class%E5%92%8Cstyle%E6%A0%B7%E5%BC%8F%E7%BB%91%E5%AE%9A/","excerpt":"class和style样式绑定","text":"class和style样式绑定 绑定样式： ​ 1.class样式 ​ 写法：:class&#x3D;’xxx’，xxx可以是对象、数组、字符串 ​ 字符串写法适用于：类名不确定，需要动态获取 ​ 数组写法使用与：要绑定多个样式，个数不确定，名字也不确定 ​ 对象写法：要绑定的样式名字、个数都确定，不确定应不应用 ​ 2.style样式 ​ :style&#x3D;”xxx”，xxx可以是样式对象、样式对象数组 ​ 备注： ​ 1.样式对象： key 不能瞎写，一定是&#x3D;&#x3D;存在的属性&#x3D;&#x3D; ​ 2.属性中如果是两个单词，直接拼在一起 font-size -&gt; fontSize 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 绑定class样式--字符串写法 适用于：样式的类名不确定，需要动态制定 --&gt; &lt;div class=&quot;basic &quot; :class=&quot;a&quot; @click=&quot;change()&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;!-- 绑定class样式—--数组写法，适用于：要绑定的样式个数不确定，名字也不确定 --&gt; &lt;div class=&quot;basic &quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;!-- 绑定class样式——— 对象写法：适用于：要绑定的样式个数确定，名字确定，是否应用不确定--&gt; &lt;div class=&quot;basic &quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;!-- 绑定style样式----对象写法 --&gt; &lt;div class=&quot;basic &quot; :style=&quot;styleObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;!-- 绑定style样式----数组写法 --&gt; &lt;div class=&quot;basic &quot; :style=&quot;styleArray&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTip=false //阻止vue在启动时生成生产提示 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; a:&#x27;&#x27;, name:&#x27;helloworld&#x27;, classArr:[&#x27;atguigu1&#x27;,&#x27;atguigu2&#x27;,&#x27;atguigu3&#x27;], classObj:&#123; atguigu1:false, atguigu2:false &#125;, styleObj:&#123; color:&#x27;red&#x27;, fontSize: &#x27;20px&#x27; &#125;, styleOb2:&#123; backgroundcolor:&#x27;orange&#x27; &#125;, styleArray:[&#123; color:&#x27;red&#x27;, fontSize: &#x27;20px&#x27; &#125;, ,&#123; backgroundcolor:&#x27;orange&#x27; &#125;], &#125;, methods:&#123; change()&#123; //0-1,1娶不到 0,0.11，1.xxx,.2.xxx向下取证 var index= Math.floor(Math.random()*3) var arr=[&#x27;happy&#x27;,&#x27;sad&#x27;,&#x27;normal&#x27;] this.a=arr[index] &#125; &#125; &#125;) &lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"}]},{"title":"","slug":"vue/12-列表渲染/列表过滤","date":"2022-07-27T15:51:52.318Z","updated":"2022-07-27T16:21:56.215Z","comments":true,"path":"2022/07/27/vue/12-列表渲染/列表过滤/","link":"","permalink":"https://jhfuture.github.io/2022/07/27/vue/12-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/%E5%88%97%E8%A1%A8%E8%BF%87%E6%BB%A4/","excerpt":"","text":"一个vscode的使用技巧 自定义折叠 12345//在开始的地方//#region//在结束的地方//#endregion","categories":[],"tags":[]},{"title":"","slug":"vue/12-列表渲染/key作用与原理","date":"2022-07-27T14:33:18.327Z","updated":"2022-07-27T15:14:40.482Z","comments":true,"path":"2022/07/27/vue/12-列表渲染/key作用与原理/","link":"","permalink":"https://jhfuture.github.io/2022/07/27/vue/12-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/key%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/","excerpt":"","text":"key的发挥作用： 如果不写 key，那Vue会&#x3D;&#x3D;默认&#x3D;&#x3D;将index作为key 当使用index做索引时，Vue内部虚拟DOM的操作过程 面试题： react、vue中key的有什么作用？（key的内部原理） 1.虚拟dom中key 的作用 key是虚拟DOM对象的标识符，当数据发生改变时，vue会根据【新数据】生成【新的虚拟DOM】 随后vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较——&#x3D;&#x3D;虚拟DOM比较算法&#x3D;&#x3D;，比较规则如下： 对比规则： (1).若虚拟DOM中找到了与新虚拟DOM相同的key 1.若虚拟DOM中内容没变，直接使用之前的真实DOM 2.若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM ​ (2).旧虚拟DOM中没找到与新虚拟DOM中相同的key ​ ——&gt;创建新的真实DOM，随后渲染到页面 用index作为key可能会引发的问题： 若对数据进行：逆序添加（不是从尾部插入，而是从头部插入）、逆序删除等&#x3D;&#x3D;破坏顺序操作&#x3D;&#x3D;会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 页面效果没问题，但效率低 &#x3D;&#x3D;如果结构中还包含输入类的DOM：&#x3D;&#x3D; ​ 会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题 开发中如何选择key？ 最好使用每条数据的&#x3D;&#x3D;唯一标识符&#x3D;&#x3D;作为key，比如id、手机号、身份证号、学号等唯一值 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅使用与渲染列表用于展示，使用index作为key是没有问题的 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 这里的案例为在persons数列 ==**前**== 添加一个新元素==---&gt;&lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 遍历数组 --&gt; &lt;h2&gt;人员列表（遍历数组）&lt;/h2&gt; &lt;button @click.once=&quot;add&quot;&gt;添加一个老刘&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;index&quot;&gt; &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125; &lt;input type=&quot;text&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; persons:[ &#123;id:&#x27;001&#x27;,name:&#x27;张三&#x27;,age:18&#125;, &#123;id:&#x27;002&#x27;,name:&#x27;李四&#x27;,age:19&#125;, &#123;id:&#x27;003&#x27;,name:&#x27;王五&#x27;,age:20&#125; ] &#125;, methods: &#123; add()&#123; const p = &#123;id:&#x27;004&#x27;,name:&#x27;老刘&#x27;,age:40&#125; this.persons.unshift(p) &#125; &#125;, &#125;) &lt;/script&gt; id（自定义为key）","categories":[],"tags":[]},{"title":"监视属性","slug":"vue/09-监视属性/监视属性","date":"2022-07-27T05:54:14.000Z","updated":"2022-08-19T06:36:56.773Z","comments":true,"path":"2022/07/27/vue/09-监视属性/监视属性/","link":"","permalink":"https://jhfuture.github.io/2022/07/27/vue/09-%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7/%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7/","excerpt":"VUe的引入","text":"VUe的引入 一、 配置项 immediate 配置初始化时让handler被调用 handler(newValue,oldValue) 配置当对应的变量发生变化时调用的方法,可以接受两个参数 deep 配置是否进行多级目录 二、书写的方式 直接在new Vue中配置 可以使用所有配置项 123456789//监视多级结构中某个属性的变化 &#x27;number.a&#x27;: &#123; immediate:true,//初始化时让handler被调用, deep:true,//检测多级 // handler 在监听属性发生改变时会被调用 handler(newValue,oldValue)&#123; console.log(&quot;a改变了&quot;,newValue,oldValue); &#125; &#125;, 简写，直接写hadler函数 不能添加配置项 12345//简写 ishot(newValue,oldValue)&#123; console.log(&quot;a改变了&quot;,newValue,oldValue); console.log(); &#125; 使用vm.$watch()配置 可以使用所有配置项 12345678910//一、使用配置项 vm.$watch(&#x27;ishot&#x27;,&#123; immediate:true, console.log(&quot;ishot被改变了&quot;,newValue,oldValue); &#125; &#125;)//二、不使用配置项 vm.$watch(&#x27;ishot&#x27;,function()&#123; console.log(&quot;ishot被改变了&quot;,newValue,oldValue); &#125;) 三、watch与computed的区别 computed能完成的，watch都能完成。 watch能完成的功能，computed不一定能完成。例如：watch可以进行异步操作 两个重要的小原则： 1.所被vue管理的函数，最好都写成普通函数，这样this的执行才是vm或 组件实例对象 2.所有不被vue所管理的函数(定时器setTimeout、Ajax的回调函数等、promise问题等) 最好写成箭头汗水，这样this的指向才是vm或 组件实例对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;body&gt;&lt;!-- --&gt; &lt;div id=&quot;root&quot;&gt; 姓 &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br&gt; 名 &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br&gt; &lt;span&gt;全名 &#123;&#123;fullname&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTip = false //阻止vue在启动时生成生产提示 const vm= new Vue(&#123; el: &#x27;#root&#x27;, data: &#123; firstName:&#x27;张&#x27;, lastName:&#x27;三&#x27;, fullname:&#x27;张三&#x27;//监视属性需要先创建一个变量便于后期修改 &#125;, computed: &#123; // fullname()&#123; // return this.firstName+&#x27;-&#x27; +this.lastName // &#125; &#125; , methods: &#123; changeishot()&#123; this.ishot=!this.ishot &#125; &#125;, //监视属性 watch: &#123; firstName()&#123; //setTimeout直接由浏览器执行，其this指向为Windows，固需要使用箭头函数，this指向往上找 setTimeout(() =&gt; &#123; this.fullname=this.firstName+&#x27;-&#x27; +this.lastName &#125;, 1000); &#125;, lastName()&#123; //setTimeout直接由浏览器执行，其this指向为Windows，固需要使用箭头函数，this指向往上找 setTimeout(() =&gt; &#123; console.log(this) this.fullname=this.firstName+&#x27;-&#x27; +this.lastName &#125;, 1000); &#125; &#125;, &#125;) // // 第二种配置方法 // vm.$watch(&#x27;ishot&#x27;,&#123; // immediate:true, // handler(newValue,oldValue)&#123; // console.log(&quot;ishot被改变了&quot;,newValue,oldValue); // &#125; // &#125;) &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://jhfuture.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Vue的技巧","slug":"vue/08-绑定样式/vue技巧","date":"2022-07-26T04:54:14.000Z","updated":"2022-09-04T10:42:21.074Z","comments":true,"path":"2022/07/26/vue/08-绑定样式/vue技巧/","link":"","permalink":"https://jhfuture.github.io/2022/07/26/vue/08-%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F/vue%E6%8A%80%E5%B7%A7/","excerpt":"","text":"Vue中的坑 如果Vue模块中没有使用data中的数据，那data中的数据发生改变时，vue的浏览器插件 Vue tool不会刷新 使用了定时器settimeout()的话，定时器是由浏览器直接调用的，所以它的this指向的是 **&#x3D;&#x3D;Windows&#x3D;&#x3D;**，而不是&#x3D;&#x3D;vue&#x3D;&#x3D; Vue的绑定样式，使用style绑定要注意的点 如果是两个单词，类似background-color这种，要去掉中间的“-”,写成一个组合词backgroundColor 技巧 Vue上简单的操作可以直接写在Vue模块里，因为Vue模块可以直接访问Vue实例上的所有属性 eg: 1234567891011121314151617&lt;div id=&quot;root&quot;&gt; &lt;div&gt; &#123;&#123;file&#125;&#125;&lt;/div&gt; &lt;!- @xxx=&quot;yyyy&quot; xxx是事件名,yyy可以写一些简单的语句--&gt; &lt;button @click=&quot;file=&#x27;炎热&#x27;&quot;&gt;&lt;/button&gt;&lt;/div&gt;&lt;script&gt; Vue.config.productionTip = false //阻止vue在启动时生成生产提示 new Vue(&#123; el: &#x27;#root&#x27;, data: &#123; file:&#x27;helloworld&#x27; &#125;, methods: &#123; &#125; &#125;)&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"},{"name":"Vue中的技巧","slug":"Vue中的技巧","permalink":"https://jhfuture.github.io/tags/Vue%E4%B8%AD%E7%9A%84%E6%8A%80%E5%B7%A7/"},{"name":"Vue中的坑","slug":"Vue中的坑","permalink":"https://jhfuture.github.io/tags/Vue%E4%B8%AD%E7%9A%84%E5%9D%91/"}]},{"title":"Vue的技巧","slug":"vue/Top0-Vue中的坑/vue技巧","date":"2022-07-26T04:54:14.000Z","updated":"2022-10-06T14:19:59.836Z","comments":true,"path":"2022/07/26/vue/Top0-Vue中的坑/vue技巧/","link":"","permalink":"https://jhfuture.github.io/2022/07/26/vue/Top0-Vue%E4%B8%AD%E7%9A%84%E5%9D%91/vue%E6%8A%80%E5%B7%A7/","excerpt":"","text":"Vue中的坑 如果Vue模块中没有使用data中的数据，那data中的数据发生改变时，vue的浏览器插件 Vue tool不会刷新 使用了定时器settimeout()的话，定时器是由浏览器直接调用的，所以它的this指向的是 **&#x3D;&#x3D;Windows&#x3D;&#x3D;**，而不是&#x3D;&#x3D;vue&#x3D;&#x3D; Vue的绑定样式，使用style绑定要注意的点 如果是两个单词，类似background-color这种，要去掉中间的“-”,写成一个组合词backgroundColor 如果不是在脚手架中，组件名不能写自闭和（，否则会导致后续的组件不能渲染) 脚手架 如果更新了脚手架的内容，脚手架会自动完成编译，但不会主动刷新浏览器控制台的内容，需要手动进行刷新。 技巧 Vue上简单的操作可以直接写在Vue模块里，因为Vue模块可以直接访问Vue实例上的所有属性 eg: 1234567891011121314151617&lt;div id=&quot;root&quot;&gt; &lt;div&gt; &#123;&#123;file&#125;&#125;&lt;/div&gt; &lt;!- @xxx=&quot;yyyy&quot; xxx是事件名,yyy可以写一些简单的语句--&gt; &lt;button @click=&quot;file=&#x27;炎热&#x27;&quot;&gt;&lt;/button&gt;&lt;/div&gt;&lt;script&gt; Vue.config.productionTip = false //阻止vue在启动时生成生产提示 new Vue(&#123; el: &#x27;#root&#x27;, data: &#123; file:&#x27;helloworld&#x27; &#125;, methods: &#123; &#125; &#125;)&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"},{"name":"Vue中的技巧","slug":"Vue中的技巧","permalink":"https://jhfuture.github.io/tags/Vue%E4%B8%AD%E7%9A%84%E6%8A%80%E5%B7%A7/"},{"name":"Vue中的坑","slug":"Vue中的坑","permalink":"https://jhfuture.github.io/tags/Vue%E4%B8%AD%E7%9A%84%E5%9D%91/"}]},{"title":"姓名实例_methods","slug":"vue/07-计算属性/1.姓名实例_method实现","date":"2022-07-25T07:11:14.000Z","updated":"2022-07-25T07:41:17.893Z","comments":true,"path":"2022/07/25/vue/07-计算属性/1.姓名实例_method实现/","link":"","permalink":"https://jhfuture.github.io/2022/07/25/vue/07-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/1.%E5%A7%93%E5%90%8D%E5%AE%9E%E4%BE%8B_method%E5%AE%9E%E7%8E%B0/","excerpt":"通过一个实例，简单说明Vue中数据绑定+模块刷新","text":"通过一个实例，简单说明Vue中数据绑定+模块刷新 本文要点： 模块刷新的原理 vue的数据绑定 正文先看基本代码 让我们开始逐步拆解 123456789101112131415161718192021222324&lt;body&gt; &lt;div id=&quot;root&quot;&gt; 姓 &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br&gt; 名 &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br&gt; 全名 &lt;span&gt; &#123;&#123;fullname()&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTip=false //阻止vue在启动时生成生产提示 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; firstName:&#x27;张&#x27;, lastName:&#x27;三&#x27; &#125;, methods:&#123; fullname()&#123; console.log(&quot;这个方法被调用了&quot;); return this.firstName + &#x27;-&#x27; +this.lastName &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; ^Vue模块 123456&lt;div id=&quot;root&quot;&gt; 姓 &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br&gt; 名 &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br&gt; 全名 &lt;span&gt; &#123;&#123;fullname()&#125;&#125;&lt;/span&gt; &lt;/div&gt; Vue实例 12345678910111213141516&lt;script&gt; Vue.config.productionTip=false //阻止vue在启动时生成生产提示 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; firstName:&#x27;张&#x27;, lastName:&#x27;三&#x27; &#125;, methods:&#123; fullname()&#123; console.log(&quot;这个方法被调用了&quot;); return this.firstName + &#x27;-&#x27; +this.lastName &#125; &#125; &#125;) &lt;/script&gt; 分析过程，当input中输入数据，data中的数据发生改变，vue会自动重新解析 [^vue实例] ，如果包含vdata的则直接刷新，有调用方法则重新调用","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"}]},{"title":"事件处理基础","slug":"vue/06-事件处理/3.键盘事件","date":"2022-07-24T16:14:52.000Z","updated":"2022-07-24T16:17:13.571Z","comments":true,"path":"2022/07/25/vue/06-事件处理/3.键盘事件/","link":"","permalink":"https://jhfuture.github.io/2022/07/25/vue/06-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/3.%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"键盘事件语法糖： @keydown ——按下了就触发，不用抬起 @keyup ——抬起后触发 1.Vue中常用的按键别名： 使用 ——&gt; @keyup.enter=&quot; &quot; 回车 =&gt; enter 删除 =&gt; delete 退出 =&gt; esc 空格 =&gt; space 切换 =&gt; tab ==**注意tab要使用keydown,因为按下后焦点就切换掉了，无法使用keyup** == 上 =&gt; up 下 =&gt; down 左 =&gt; left 右 =&gt; right 换行 =&gt; tab (特殊，必须配合keydown去使用) 2.vue未提供别名的按键，可以使用按键原始的key值去绑定它，但注意要变化为 kebasb-case(短横线命名) eg:——caps-lock 3.系统修饰键 ctrl shift alt meta(win键) (1)配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才能被触发 (2)配合keydown使用正常触发 (3)可配合特定按键一起 @keyup.ctrl.xxx=&quot; &quot; @keyup.ctrl.z 4.也可以使用keycode去指定具体的按键（不推荐）5.Vue.config.keyCodes.自定义键名 &#x3D; 键码（keycode) 可以去定制按键别名（同样不推荐）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;body&gt; &lt;!-- 键盘事件语法糖： @keydown ——按下了就触发，不用抬起 @keyup ——抬起后触发 1.Vue中常用的按键别名： 使用 ——&gt; @keyup.enter=&quot; &quot; 回车 =&gt; enter 删除 =&gt; delete 退出 =&gt; esc 空格 =&gt; space 切换 =&gt; tab ==**注意tab要使用keydown,因为按下后焦点就切换掉了，无法使用keyup** == 上 =&gt; up 下 =&gt; down 左 =&gt; left 右 =&gt; right 换行 =&gt; tab (特殊，必须配合keydown去使用) 2.vue未提供别名的按键，可以使用按键原始的key值去绑定它， 但注意要变化为 kebasb-case(短横线命名) eg:——caps-lock 3.系统修饰键 ctrl shift alt meta(win键) (1)配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才能被触发 (2)配合keydown使用正常触发 (3)可配合特定按键一起 @keyup.ctrl.xxx=&quot; &quot; @keyup.ctrl.z 4.也可以使用keycode去指定具体的按键（不推荐） 5.Vue.config.keyCodes.自定义键名 = 键码（keycode) 可以去定制按键别名（同样不推荐） --&gt; &lt;div id=&quot;root&quot;&gt;&lt;input type=&quot;text&quot; placeholder=&quot;请输入内容&quot; @keyup.ctrl.y=&quot;showInfo&quot;&gt; &lt;/div&gt; &lt;script&gt; Vue.config.keyCodes.huiche=13;//定义了一格别名按键 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;helloworld&#x27; &#125;, methods:&#123; showInfo(e)&#123; console.log(&quot;执行了&quot;); console.log(e.key); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"}]},{"title":"事件处理基础","slug":"vue/06-事件处理/2.事件修饰符","date":"2022-07-24T15:50:51.000Z","updated":"2022-07-24T16:15:11.722Z","comments":true,"path":"2022/07/24/vue/06-事件处理/2.事件修饰符/","link":"","permalink":"https://jhfuture.github.io/2022/07/24/vue/06-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/2.%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"","text":"vue的事件修饰符： prevent：阻止默认事件（常用） ——@click.prevent stop:阻止事件冒泡 once：事件只触发一次。（常用） capture：使用事件的捕获模式 tip:捕获模式： 先从外层开始捕获到点击 sefl:只有event.target是当前操作的元素时才触发事件——也可用作防止事件冒泡 passive：事件的默认行为立即执行，无须等待时间回调执行完毕。 修饰符饰符特点： 可以连续写： EG:@click.prevent.stop(阻止默认行为+阻止冒泡) 额外的知识： scroll为滚动条滚动事件，滚动条抵达边缘后不再出发 wheel为鼠标滚轮滚动事件，滚动条抵达边缘后依旧触发 以下为各个修饰符用法的介绍 这是一个全局的例子，接下来让我们来细细诉说 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;head&gt;&lt;style&gt; *&#123; margin-top: 20px; &#125; .box1&#123; background-color: aqua; &#125; .box2&#123; background-color: azure; &#125; .scroll&#123; height: 100px; background-color: blueviolet; overflow: auto; &#125; .scroll li&#123; height: 50px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 修饰符特点： 可以连续写 EG:@click.prevent.stop(阻止默认行为+阻止冒泡) vue的大事件修饰符： 1.prevent：阻止默认事件（常用） ——@click.prevent 2.stop:阻止事件冒泡 3.once：事件只触发一次。（常用） 4.capture：使用事件的捕获模式 tip:捕获模式： 先从外层开始捕获到点击 然后从里层开始冒泡 5.sefl:只有event.target是当前操作的元素时才触发事件——也可用作防止事件冒泡 6.passive：事件的默认行为立即执行，无须等待时间回调执行完毕。 额外的知识： 1.scroll为滚动条滚动事件，滚动条抵达边缘后不再出发 2.wheel为鼠标滚轮滚动事件，滚动条抵达边缘后依旧触发 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 阻止默认事件 --&gt; &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt; &lt;!-- 阻止事件冒泡 --&gt; &lt;div style=&quot;background-color: blanchedalmond;&quot;@click=&quot;showInfo&quot;&gt; &lt;button @click.stop=&quot;showInfo2&quot;&gt;点我提示信息&lt;/button&gt; &lt;!-- 修饰符可以连续写 --&gt; &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt; &lt;/div&gt; &lt;!-- 事件只触发一次 --&gt; &lt;button @click.once=&quot;showInfo2&quot;&gt;点我提示信息&lt;/button&gt; &lt;!-- 事件的捕获模式 --&gt; &lt;!-- 捕获模式： 先从外层开始捕获到点击 然后从里层开始冒泡 这里体现为 box1先捕获到事件，然后到button，但 冒泡是由button ——→ div 冒泡的结果时，div中触发的点击时间event.target也是button --&gt; &lt;div @click.capture=&quot;click(1)&quot; class=&quot;box1&quot;&gt; &lt;button @click=&quot;click(2)&quot;&gt;事件的捕获模式&lt;/button&gt; &lt;/div&gt; &lt;div @click.self=&quot;self($event)&quot; class=&quot;box2&quot;&gt; &lt;button @click=&quot;self($event)&quot;&gt;事件修饰符self&lt;/button&gt; &lt;/div&gt; &lt;!-- 6.passive：事件的默认行为立即执行，无须等待时间回调执行完毕。 --&gt; &lt;!-- 事件执行的流程为：一执行回调函数，并且等待执行完成后 →二、渲染效果， 在这个案例中，scroll函数内事件执行时间过长，会影响滚动条的渲染 ， 这里使用passive不等待回调函数执行完成，直接渲染--&gt; &lt;ul class=&quot;scroll&quot; @wheel=&quot;scroll&quot;&gt; &lt;!-- wheel 为滚轮滚动事件 scroll 为滑动条滚动事件 --&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;helloworld&#x27; &#125;, methods:&#123; showInfo(e)&#123; alert(&quot;欢迎你&quot;); //这里弹出窗口后会默认执行href &#125;, showInfo2(e)&#123; alert(&quot;同学你好&quot;); &#125;, self(event)&#123; console.log(event.target); &#125;, click(number)&#123; console.log(number); &#125;, scroll()&#123; for(let i=0;i&lt;100;i++)&#123; console.log(&quot;f&quot;); &#125; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"}]},{"title":"事件处理基础","slug":"vue/06-事件处理/1.事件处理基础","date":"2022-07-24T09:54:51.000Z","updated":"2022-07-24T09:56:19.012Z","comments":true,"path":"2022/07/24/vue/06-事件处理/1.事件处理基础/","link":"","permalink":"https://jhfuture.github.io/2022/07/24/vue/06-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/1.%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/","excerpt":"","text":"事件的基本使用 1. 使用v-on:xxx或 @xxx 绑定事件，其中xx为事件名 1. 事件的回调需要配置在methods对象中，最终会出添加到vm对象上 methods配置的函数，不要使用&#x3D;&#x3D;箭头函数&#x3D;&#x3D;！否则this的就不是vm了 methods配置的函数，都是被vue所管理的函数，this的指向是vm或 组件实例对象 @click&#x3D;”demo” 和@click&#x3D;”demo($event)”效果一样，但后者可以传 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- 事件的基本使用 1.使用v-on:xxx或 @xxx 绑定事件，其中xx为事件名 2. 事件的回调需要配置在methods对象中，最终会出添加到vm对象上 3. methods配置的函数，不要使用==箭头函数==！否则this的就不是vm了 4. methods配置的函数，都是被vue所管理的函数，this的指向是vm或 组件实例对象 5。 @click=&quot;demo&quot; 和@click=&quot;demo($event)&quot;效果一样，但后者可以传参 --&gt; &lt;!-- 添加一个容器 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;学习&lt;/h2&gt; &lt;!-- &lt;button v-on:click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt; --&gt;&lt;!-- 简写 --&gt; &lt;button @click=&quot;showInfo1&quot;&gt;点我提示信息1(不传参)&lt;/button&gt; &lt;!-- 传递参数 ,如果想保留event，使用关键词 $event --&gt; &lt;button @click=&quot;showInfo2($event,66)&quot;&gt;点我提示信息2(传递参数)&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const vm= new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;尚硅谷&#x27; &#125;, // 事件要配置在methods 对象中 methods:&#123; showInfo(event)&#123; // alert(&quot;同学你好&quot;) console.log(this);//此处的this就是指vue实例 console.log(event.target.innerText); &#125;, showInfo1(event)&#123; alert(&quot;同学你好&quot;) &#125;, showInfo2(evnet,number)&#123; console.log(number); console.log(event); &#125; &#125; &#125;) console.log(vm); &lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"}]},{"title":"02何为数据代理","slug":"vue/05-数据代理/02数据代理","date":"2022-07-24T07:45:05.000Z","updated":"2022-07-24T09:51:56.160Z","comments":true,"path":"2022/07/24/vue/05-数据代理/02数据代理/","link":"","permalink":"https://jhfuture.github.io/2022/07/24/vue/05-%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86/02%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435 &lt;!-- 数据代理：通过一个对象代理对领一个对象中的属性的操作（读/写） --&gt;​ &lt;!-- 这里是ojb2通过数据代理操作和使用object1的x --&gt; &lt;script&gt; let obj1=&#123;x:100&#125;; let obj2=&#123;y:200&#125;; Object.defineProperty(obj2,&quot;x&quot;,&#123; get()&#123; return obj1.x &#125;, set(value)&#123; obj1.x=value &#125;​ &#125;)​ &lt;/script&gt;​ &lt;!-- ​ 1.Vue中的数据代理：​ 通过vm对象来代理data对象中属性的操作 （读/写）​ 2.Vue中数据代理的好处​ 更加方便的操作data中的数据​ 3.基本原理​ 通过object.defineProperty()把data对象中所有属性都添加到vm上。​ 并为每一个添加到vm上的属性，都指定一个getter/setter​ 在getter/setter内部去操作（读/写）data中相应的属性​ --&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;helloworld&#x27; &#125; &#125;)​ &lt;/script&gt; 数据代理图示： Vue中的数据代理： 通过vm对象来代理data对象中属性的操作 （读&#x2F;写） Vue中数据代理的好处 更加方便的操作data中的数据 基本原理 通过object.defineProperty()把data对象中所有属性都添加到vm上。并为每一个添加到vm上的属性，都指定一个getter&#x2F;setter在getter&#x2F;setter内部去操作（读&#x2F;写）data中相应的属性 额外补充： 在vm对象中的_data,vue为了能做响应式，在_data做了&#x3D;&#x3D;数据劫持&#x3D;&#x3D;。所以打开_data后看到的不是跟原始data对象一样，而是经过了数据劫持的处理","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"},{"name":"Vue方法","slug":"Vue方法","permalink":"https://jhfuture.github.io/tags/Vue%E6%96%B9%E6%B3%95/"}]},{"title":"06.Object.defineProperty方法","slug":"vue/05-数据代理/06-Object-defineProperty方法","date":"2022-07-24T07:23:05.000Z","updated":"2022-07-24T07:40:56.532Z","comments":true,"path":"2022/07/24/vue/05-数据代理/06-Object-defineProperty方法/","link":"","permalink":"https://jhfuture.github.io/2022/07/24/vue/05-%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86/06-Object-defineProperty%E6%96%B9%E6%B3%95/","excerpt":"Vue中重要的数据代理函数 ——Object.defineProperty函数介绍","text":"Vue中重要的数据代理函数 ——Object.defineProperty函数介绍 1. 组成 1Object.defineProperty(object,keyName,&#123;&#125;) 12345678910111213141516171819202122232425262728&lt;script&gt;let number =21; let person=&#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27; &#125; Object.defineProperty(person,&#x27;ages&#x27;,&#123; // value:18, // enumerable:true 默认添加的value是不可以 枚举 的，即不可以用来循环等 // for(val in person)&#123; // console.log(val); // &#125; // writable:true 控制属性是否可以被修改，默认为FALSE // configurable:true 控制属性是否可以被删除，默认为FALSE //当有人读取person的ages属性时，get函数(getter)就会被调用，且返回值就是age的值 get()&#123; console.log(&quot;有人读取属性了&quot;); return number &#125;, //当有人修改person的ages属性时，set函数(setter)就会被调用,且会接收到修改的具体指 set(value)&#123; console.log(value); number=value;//由于get方法中，将number返回当做ages的值，所以这里修改 &#125; &#125;) &lt;/script&gt; 2. get方法说明 1.当使用此方法时不能再在配置对象中使用value 2.输出查看以….形式呈现 3.set方法12345//当有人修改person的ages属性时，set函数(setter)就会被调用,且会接收到修改的具体指 set(value)&#123; console.log(value); number=value;//由于get方法中，将number返回当做ages的值，所以这里修改 &#125; 小结vue通过两个方法实现数据的沟通","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"},{"name":"Vue方法","slug":"Vue方法","permalink":"https://jhfuture.github.io/tags/Vue%E6%96%B9%E6%B3%95/"}]},{"title":"hexo+github搭建个人博客","slug":"hexo-github搭建个人博客","date":"2022-07-23T12:15:51.000Z","updated":"2022-09-13T12:00:57.999Z","comments":true,"path":"2022/07/23/hexo-github搭建个人博客/","link":"","permalink":"https://jhfuture.github.io/2022/07/23/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"🎢利用hexo+github的pages功能，搭建简易版的个人博客！🐼 来动手试试吧！","text":"🎢利用hexo+github的pages功能，搭建简易版的个人博客！🐼 来动手试试吧！ [TOC] 一、搭建准备工作 配置安装好Node.js和Npm(NPM默认跟随Node.js安装) 官方推荐(Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本) 配置好Git环境 二、搭建和hexo常用命令1. 安装hexo1npm install -g hexo-cli 2. 初始化hexo。首先进入你想创建blog的文件夹，启动powershell1hexo init [folder] folder 为你想 创建的名字，这里可以自定义，我使用bloghexo init blog 3. 进入初始化好的hexo。再使用npm安装配套组件。然后再进入步骤2创建的文件夹，我这里是blog文件夹，你将会看到如下的文件结构。123456789101112npm install# blog/文件下.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes#这些我们后面再讲 4. 开始创建你的第一个hexo博客12hexo g #编译生成静态文件 即 ——————&gt;将md文件配合其他文件生成 html+css+js文件hexo s # 启动本地调试 5. 使用浏览器打开 localhost:4000**Surprise !**你的第一个hexo已经完成。 6. 如果你不太喜欢官方给的主题，那让我们一起来完成主题的更换吧a. 去官方或者github&#x2F;gitee 下载你喜欢的主题，并将其保存在themes文件下。123# 我这里用 next-pure主题做演示cd themes/git clone git@gitee.com:mirrors_cofess/hexo-theme-pure.git b. 修改_config.yml文件（blog文件夹下的，这里称为客户端配置文件），主题文件中也有一个，我将它称为主题配置文件1234567# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape#这里的thems 修改为你clone后的文件名#eg:theme: hexo-theme-pure 注意thems 与值之间有 ”空格“ c. 重新执行构建文件1234hexo clean #清理一下缓存，为了更好的使用主题hexo generate #直接使用hexo g也可以hexo server #直接使用hexo s也可以#重新打开，surprise！ 具体的美化修改可以看官方的文档。点击这里进入官方文档 另外不要安装官方文档上的hexo-generator-baidu-sitemap插件，这个插件会导致程序报错。 7. 配置文件介绍_config.yml网站的 配置 (查看详细请点击)信息，你可以在此配置大部分的参数 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 12345678910111213141516171819package.json&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.8.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;, &quot;hexo-server&quot;: &quot;^0.3.3&quot; &#125;&#125; scaffolds模版 文件夹。当你新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果你修改scaffold&#x2F;post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 hexo n “blogName” 这里默认使用的模板就是post source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 我们使用 hexo n “blogName”命令生成新文档后。 md文件就储存在source&#x2F;_post&#x2F;下 8. 如何配置github&#x2F;gitee的部署 创建github&#x2F;gitee仓库，仓库名称为 [用户名称].github.io。并且要开启github pages服务 ps:国内的gitee需要实名验证才能开启，但不晓得为什么我就是一直显示在审核中。 安装deploy插件 1npm install hexo-deployer-git --save 3. 配置 _config.yml文件 1234deploy: type: git repo: 对应仓库地址 branch: #github为main，gitee为master 部署到github&#x2F;gitee上 1hexo d &#x3D;&#x3D;Congratulation ！完成啦&#x3D;&#x3D; 三、解决一些小问题1. 如何配置实现本地Typora和网页端都能正常显示图片？ 安装hexo-asset-image,可以上传本地图片的插件 1npm install https://github.com/EricGerry/hexo-asset-image-0.0.5.git --save 注意，这里必须使用&#x3D;&#x3D;0.0.5版本&#x3D;&#x3D; 配置_config.yml启用文件管理插件 1234#在文件中使用查找功能post_asset_folder: false#修改为post_asset_folder: true 重新生成文件 1hexo n &quot;test&quot; 然后你会发现在souce&#x2F;_post&#x2F;目录下同时出现了 test.md和test文件夹，将你需要的图片资源丢到里面即可 最后一步，配置Typora。 这里一定要勾选 &#x3D;&#x3D;优先使用相对路径&#x3D;&#x3D; 测试一下，恭喜完成！","categories":[{"name":"hexo","slug":"hexo","permalink":"https://jhfuture.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://jhfuture.github.io/tags/hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://jhfuture.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"前段界面响应式布局","slug":"前端三剑客/响应式布局","date":"2022-07-23T12:15:51.000Z","updated":"2022-07-20T06:58:59.241Z","comments":true,"path":"2022/07/23/前端三剑客/响应式布局/","link":"","permalink":"https://jhfuture.github.io/2022/07/23/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/","excerpt":"","text":"🎢响应式布局！🐼","categories":[{"name":"响应式","slug":"响应式","permalink":"https://jhfuture.github.io/categories/%E5%93%8D%E5%BA%94%E5%BC%8F/"}],"tags":[{"name":"前段三剑客","slug":"前段三剑客","permalink":"https://jhfuture.github.io/tags/%E5%89%8D%E6%AE%B5%E4%B8%89%E5%89%91%E5%AE%A2/"},{"name":"响应式开发","slug":"响应式开发","permalink":"https://jhfuture.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/"}]},{"title":"hexo+github搭建个人博客","slug":"JavaScript/Promise/1.Promise的基本介绍使用","date":"2022-07-23T12:15:51.000Z","updated":"2022-10-06T14:30:56.674Z","comments":true,"path":"2022/07/23/JavaScript/Promise/1.Promise的基本介绍使用/","link":"","permalink":"https://jhfuture.github.io/2022/07/23/JavaScript/Promise/1.Promise%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E4%BD%BF%E7%94%A8/","excerpt":"🎢Promise的使用！🐼 来动手试试吧！","text":"🎢Promise的使用！🐼 来动手试试吧！ promise的当","categories":[{"name":"hexo","slug":"hexo","permalink":"https://jhfuture.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://jhfuture.github.io/tags/hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://jhfuture.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"hexo+github搭建个人博客","slug":"vue/16-自定义指令/自定义指令","date":"2022-07-23T12:15:51.000Z","updated":"2022-07-29T06:08:43.973Z","comments":true,"path":"2022/07/23/vue/16-自定义指令/自定义指令/","link":"","permalink":"https://jhfuture.github.io/2022/07/23/vue/16-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","excerpt":"","text":"[TOC] 自定义指令总结：​ 一、定义语法 ​ （1）局部指令： ​ new Vue({ ​ directives:{ ​ 指令名:配置对象 或 ​ } ​ }) ​ 或 ​ new Vue({ ​ directives:{ ​ 指令名:回调函数 ​ } ​ }) ​ (2)全局指令： ​ Vue.directive(指令名,配置对象) 或 Vue.directive(指令名,回调函数) ​ ​ 二、配置对象中常用的3个回调： ​ (1).bind:指令与元素绑定陈功时调用 ​ (2).inserted:指令所在元素被插入页面时调用 ​ (3).update：指令所在模板结构被重新解析时调用 ​ 三、备注 ​ 1.指令定义时不加v-，但使用时要加v- ​ 2.指令名如果是多个单词，则要使用kebab-case命名方式， ​ 不要使用camelCase命名（驼峰） 自定义指令的坑: 多个单词命名时，不推荐使用 &#x3D;&#x3D;驼峰命名法&#x3D;&#x3D; why ? ​ 当你写成 v-bigNumber ，vue会将其转化为 v-bignumber 当你在directive中使用时就要写 ​ bignumber(){} Vue推荐的是what? ​ 使用 ‘-‘ 进行分隔 v-big-number 在directive配置时， ​ ‘big-number’:function(){} tip : 在书写对象 时，原本的写法就是 ​ ——–&gt;”key”:value 只是我们经常使用简写 ​ ———————-&gt;big(){} 但简写不支持-这种符号 ​ so，需要写回本来的形式 ​ —————–’big-number’:function(){} **&#x3D;&#x3D;局部指令&#x3D;&#x3D;**只能在同一个Vue实例中使用 ​ how？配置全局 ​ Vue.directive(‘name’,function&#x2F;Object)","categories":[{"name":"hexo","slug":"hexo","permalink":"https://jhfuture.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://jhfuture.github.io/tags/hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://jhfuture.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"Vue的开始","slug":"vue/01-初始vue/01.初识Vue","date":"2022-07-22T15:09:14.000Z","updated":"2022-07-20T06:35:51.059Z","comments":true,"path":"2022/07/22/vue/01-初始vue/01.初识Vue/","link":"","permalink":"https://jhfuture.github.io/2022/07/22/vue/01-%E5%88%9D%E5%A7%8Bvue/01.%E5%88%9D%E8%AF%86Vue/","excerpt":"VUe的引入","text":"VUe的引入 Vue的开始1.引入 vue.js是开发板的js文件，带有错误提示；vuemi.js是线上版，不会有提示 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 引入vuescript,引入完成后HTML中会多了一个vue的构造器--&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 准备一个容器 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;hello&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip=false;//阻止vue在启动时生成提示 //创建Vue实例,参数为配置对象 const x=new Vue(&#123; // 链接vue实例与HTML元素 el:&#x27;#root&#x27;,//element,el用于指定当前vue实例为哪个容器服务，值通常为css选择器字符串。 // el:documenet.getElementById(&#x27;root&#x27;),这样子写也可以 data:&#123; name:&#x27;尚硅谷&#x27;, &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 总结 想要Vue工作，就必须创建一个Vue实例，且要传入一个配置对象 在HTML中创建容器，并在配置对象中用el，传入 容器内的代码依旧符合HTML规范，只不过混入了一些&#x3D;&#x3D;特殊的Vue语法&#x3D;&#x3D;。 容器里的代码被称为vue模块 Vue实例与容器只能是&#x3D;&#x3D;一一对应&#x3D;&#x3D;的关系 中的xxx要写==js表达式==,且xxx可以直接读取到data中的==所有属性==。 当Vue实例中的data发生变化是，页面中用到该数据的地方也会自动刷新。 区分什么是&#x3D;&#x3D;js表达式&#x3D;&#x3D;，什么是&#x3D;&#x3D;js代码（或者说语句）&#x3D;&#x3D; 表达式：一个表达式会产生一个&#x3D;&#x3D;值&#x3D;&#x3D;，可以放在任何需要值的地方。 eg: - a(在已经定义好a变量后，再使用a，就会得到它对应的值) - a+b，这明显是一个 ‘加法运算的表达式’ - function(1) ——这是一个调用函数并得到其返回值的形式 - x==y?a:b ——三元表达式 js代码: 12- 控制顺序，例如 if()&#123;&#125;- for()&#123;&#125;、、","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://jhfuture.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Vue的模块语法及数据的双向绑定","slug":"vue/02.Vue的模块语法及数据的双向绑定/02.Vue的模块语法及数据的双向绑定","date":"2022-07-22T15:09:14.000Z","updated":"2022-07-25T06:40:50.027Z","comments":true,"path":"2022/07/22/vue/02.Vue的模块语法及数据的双向绑定/02.Vue的模块语法及数据的双向绑定/","link":"","permalink":"https://jhfuture.github.io/2022/07/22/vue/02.Vue%E7%9A%84%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/02.Vue%E7%9A%84%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/","excerpt":"VUe的的基本语法","text":"VUe的的基本语法 1.2模块语法、数据单(双)向绑定一、模块语法 可分为：1.插值语法、2.指令语法 123456789101112131415161718192021222324252627 &lt;div id=&quot;root&quot;&gt; &lt;!-- 插值语法--&gt; &lt;h1&gt;插值语法&lt;/h1&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;!-- 指令语法--&gt; &lt;h1&gt;指令语法&lt;/h1&gt; &lt;a v-bind:href=&quot;url&quot;&gt;点我进入百度&lt;/a&gt; &lt;!--简写--&gt; &lt;a :href=&quot;school.url&quot;&gt;点我进入bing&lt;/a&gt; &lt;br&gt; &lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;helloworld&#x27;, url:&#x27;www.baidu.com&#x27;, school:&#123; url:&#x27;www.bing.com&#x27; &#125;, input:&#x27;value&#x27; &#125; &#125;)&lt;/script&gt; 总结Vue模块语法有2大类： 插值语法 功能：用于解析&#x3D;&#x3D;标签体内容&#x3D;&#x3D; 写法：，xxx是&#x3D;&#x3D;js表达式&#x3D;&#x3D;,且可以&#x3D;&#x3D;直接读取&#x3D;&#x3D;(如果是date里面对象的值则需要使用object.propertyName访问)到data中的所有属性 备注： 如果同一个变量在同一级中进行了多次赋值，则以&#x3D;&#x3D;最后一次赋值&#x3D;&#x3D;为准 指令语法 功能：用于解析标签（包括标签属性、标签体内容、绑定时间……） 写法举例： 绑定标签属性：v-bind:href&#x3D;’xxx’, xxx直接为名字 或简写为 :href&#x3D;’xxx’,xxx同样要写&#x3D;&#x3D;js表达式&#x3D;&#x3D; 备注： Vue中有许多的指令，且形式都是 v-??，这里只是一个举例 v-bind是&#x3D;&#x3D;单向数据绑定&#x3D;&#x3D; 这里需要注意一下，微信小程序中的指令语法写法与插值语法相同 eg: 二、双向数据绑定1234567891011121314151617181920&lt;input type=&#x27;text&#x27; v-mode=&#x27;name&#x27;&gt;&lt;div id=&quot;root&quot;&gt; &lt;!-- 普通写法 单向数据绑定 --&gt; 单向数据绑定：&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt;&lt;br/&gt; 双向数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;&lt;br/&gt; &lt;!-- 简写 v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值--&gt; 单向数据绑定：&lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt;&lt;br/&gt; 双向数据绑定：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;br/&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;jack&#x27;, &#125; &#125;)&lt;/script&gt; 总结：Vue中有2种数据绑定的方式： 单向绑定(v-bind)：数据只能从data流向页面 双向绑定(v-model)：数据不仅能从data流向页面，还可以从&#x3D;&#x3D;页面流向data&#x3D;&#x3D; 1.双向绑定一般都应用在表单类元素上（如：input、select等） 2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"}]},{"title":"el与data的两种写法+vue实例","slug":"vue/03.el与data的两种写法/03.el与data的两种写法","date":"2022-07-22T15:09:14.000Z","updated":"2022-08-15T16:44:36.316Z","comments":true,"path":"2022/07/22/vue/03.el与data的两种写法/03.el与data的两种写法/","link":"","permalink":"https://jhfuture.github.io/2022/07/22/vue/03.el%E4%B8%8Edata%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95/03.el%E4%B8%8Edata%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95/","excerpt":"el与data的两种写法+vue实例","text":"el与data的两种写法+vue实例 el与data的两种写法+vue实例一、.认识vue实例 1.1，以$开头的字符都是vue准备好给小程序用的 1.2 以_是vue底层在使用的 1.3 使用vue原型缔造对象的方法 二、el的第二种写法 简介 ​ vue实例构造器里的方法 ​ v.#mount(‘xx’) ——xxx为css的选择器 123456789&lt;script&gt; new Vue(&#123; // el:&#x27;#root&#x27;, //第一种写法 data:&#123; name:&#x27;helloworld&#x27; &#125; &#125;) v.$mount(&#x27;#root&#x27;) //第二种写法 &lt;/script&gt; 三、 data的两种写法 new Vue({ // el:'#root', //el第一种写法 data:{//data的第一种写法 name:'helloworld' } v.$mount('#root') //el第二种写法 //data第二种写法,函数式 data:function(){ return{ name:'尚硅谷' } } or: data: }) ​ 小结el有2种写法 new Vue时候配置el属性 先创建Vue实例，随后再通过使用vue原型中的mount方法，vm.$mount(‘#root’)指定el的值 data有2种写法 对象式 函数式 如何选择：在组件中，data必须使用函数式 一个重要的原则：由vue管理的函数，一定不要写&#x3D;&#x3D;箭头函数&#x3D;&#x3D;，一旦写了箭头函数，this就不再是vue实例了","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://jhfuture.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Vue中的MVVM设计模式","slug":"vue/04.Vue中的MVVM/04.Vue中的MVVM","date":"2022-07-22T15:09:14.000Z","updated":"2022-07-23T14:51:58.969Z","comments":true,"path":"2022/07/22/vue/04.Vue中的MVVM/04.Vue中的MVVM/","link":"","permalink":"https://jhfuture.github.io/2022/07/22/vue/04.Vue%E4%B8%AD%E7%9A%84MVVM/04.Vue%E4%B8%AD%E7%9A%84MVVM/","excerpt":"Vue中的MVVM设计模式","text":"Vue中的MVVM设计模式 Mvvw 总结 M：模型(Model) ：data中的数据 V：视图(View) ：模板代码 VM：视图模型(ViewModel)：Vue实例 观察发现​ MVM模型： data上的所有属性，最终都会出现在vm身上。 vm身上所有的属性，及vue原型上所有属性，在vue模块上都可以直接使用","categories":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"}]},{"title":"","slug":"JAVA/3-面向对象/4-类、对象、构造器/1-构造器","date":"2022-07-20T15:33:42.418Z","updated":"2022-10-16T07:57:43.750Z","comments":true,"path":"2022/07/20/JAVA/3-面向对象/4-类、对象、构造器/1-构造器/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/JAVA/3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8/1-%E6%9E%84%E9%80%A0%E5%99%A8/","excerpt":"","text":"构造器一、构造器的简介：​ 是类的一种特殊的方法，它的主要作用是完成对==新对象的初始化==。 ​ &#x3D;&#x3D;&#x3D;&gt;在创建完对象后，才进行的初始化，而不是用它来创建对象。 二、构造器的特点 方法名和类名相同。 没有返回值。（&#x3D;&#x3D;同时不能写void关键字，留空即可！！！！&#x3D;&#x3D;） 在创建对象时，系统会自动的调用该类的构造器完成对对象的初始化。 三、构造器的注意事项和细节 一个类中可以定义多个不同的构造器，即&#x3D;&#x3D;构造器重载&#x3D;&#x3D; 1234567891011class sequenceArray&#123; int age; String name; sequenceArray()&#123; &#125; sequenceArray(int age,String name)&#123; this.age=age; this.name=name; &#125;&#125; 构造器名与类名相同 构造器没有返回值（不能写void!!!!!!!!） 构造器是完成对对象的初始化，并不是创建对象！ 在创建对象时，系统自动的调用该类的构造方法 如果程序猿没有定义构造器，系统会自动给类生成一个默认午参构造器(也叫默认构造器)，比如Dog()，使用javap指令进行反编译。 一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下，即Dog(){}（这点很重要） 在构造器中可以使用this()方法调用本类中的另一个构造器，且this方法只能在第一行。","categories":[],"tags":[]},{"title":"7-GoF代理模式","slug":"SSM/Spring/7-GoF代理模式","date":"2022-07-20T14:34:33.000Z","updated":"2023-01-10T11:19:43.661Z","comments":true,"path":"2022/07/20/SSM/Spring/7-GoF代理模式/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/SSM/Spring/7-GoF%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、扩展——类与类之间的关系1.泛化关系 继承 is aCat is Anima public class Animal(){} public calss Cat extends Animal（）{} 2.关联关系 has a张三 is a aapple 二、动态代理机制1.JDK自带的动态代理 核心：proxy 类 的 newProxyInstance 方法 原理 12345678 //创建代理对象/*做了两件事 1。在内存中动态生成了一个代理类的字节码class 2.new对象了，通过内存中生成的代理类 这个代码，实例化了代理对象。 * * *///Proxy.newProxyInstance(类加载器，代理类要实现的接口，调用处理器)调用 处理器是一个实现了 InvocationHandler 接口的类。","categories":[],"tags":[]},{"title":"","slug":"JavaScript/ES6","date":"2022-07-20T14:14:32.537Z","updated":"2022-09-07T14:21:45.357Z","comments":true,"path":"2022/07/20/JavaScript/ES6/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/JavaScript/ES6/","excerpt":"","text":"ES6 双引号&#x2F;单引号， ’‘，普通的单&#x2F;双引号 ==不能实现换行==,如果想要内容中换行，需要使用 &#x3D;&#x3D;反单引号&#96;&#x3D;&#x3D; eg: 123var test=`213213`","categories":[],"tags":[]},{"title":"","slug":"JavaScript/Untitled","date":"2022-07-20T14:03:25.038Z","updated":"2022-07-20T14:03:25.038Z","comments":true,"path":"2022/07/20/JavaScript/Untitled/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/JavaScript/Untitled/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"JavaScript/构造函数/构造函数与对象","date":"2022-07-20T12:54:34.695Z","updated":"2022-07-20T13:03:10.251Z","comments":true,"path":"2022/07/20/JavaScript/构造函数/构造函数与对象/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/JavaScript/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"构造函数就相当于 java 中的class ，具有泛指的类，是具有一些方法和属性的集合 ——————&gt; &#x3D;&#x3D;抽象的&#x3D;&#x3D; 而对象是一个**&#x3D;&#x3D;具体的实物&#x3D;&#x3D;** ​ new 构造函数()，使用构造函数创建对象的过程 ——————&gt; 对象的实例化 new关键字执行过程 当构造函数遇到new时，就会在内存中创建一个新的空对象 函数的 &#x3D;&#x3D;this&#x3D;&#x3D; 指向刚刚创建的空对象 执行构造函数里面的代码，给这个空对象添加属性和方法 返回这个对象","categories":[],"tags":[]},{"title":"","slug":"JAVA/0-Java细节/Java开发细节","date":"2022-07-20T12:10:04.894Z","updated":"2022-11-19T08:04:28.496Z","comments":true,"path":"2022/07/20/JAVA/0-Java细节/Java开发细节/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/JAVA/0-Java%E7%BB%86%E8%8A%82/Java%E5%BC%80%E5%8F%91%E7%BB%86%E8%8A%82/","excerpt":"","text":"引入 Java中有一些细节的问题需要我们注意,这里进行详细的解释,避免后期踩坑. 如果Java文件中有且只能有##一个##public类, 如果public存在时， 文件名必须按该类名来命名。 其他类的个数不限制。 同时，每一个类，在编译后都对应一个.class文件 main方法是java的程序入口，它具有固定的写法。 只能有一个，但是位置不限（可存在public类，或其他类中） 可以将main方法写在其他非public类中，然后指定运行非public类，这样入口方法就是非public的main方法。 指定运行，即运行时，使用 java xxx(类名) 1234public static void main(String[] args)&#123;&#125; 老韩推荐的学习方法： 可变参数一定要写在形参的第一个位置。 在构造器中使用this调用另一个构造器时，一定要把把把this调用语句放在第一位。0 使用 System.out.println(对象名) ,的时候，默认会调用 对象的 &#x3D;&#x3D;toString方法&#x3D;&#x3D;，使用其返回值进行输出 三元操作符必须要返回一个数据。而且类型要确定，不可能条件为真时返回int类型，条件为假时返回float类型，编译器是不允许如此的，所以它就会进行类型转换了. 会根据运算符的精确度类型进行自动类型转换。 1234Object object1=true? new Integer(1):new Double(2.0); System.out.println(object1); ----&gt;1.0? A：为什么是1.0 而不是1？ Q；三元运算符需要==看成一个整体==，它会返回一个数据，而且类型要确定，不可能条件为真时返回int ，条件为假时为 double，和其他运算符相同，会自动进行 ==类型转换==,根据运算符的精确度进行==自动类型转换==，--&gt;最高级 7.&#x3D;&#x3D; 和 equal &#x3D;&#x3D; 基本数据类型 —&gt;比较值 对象 —-&gt;比较地址 equal 部分类中进行了重写。","categories":[],"tags":[]},{"title":"","slug":"vue/18-非文件组件/VueComponent","date":"2022-07-20T12:07:14.255Z","updated":"2022-10-06T12:58:20.401Z","comments":true,"path":"2022/07/20/vue/18-非文件组件/VueComponent/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/vue/18-%E9%9D%9E%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/VueComponent/","excerpt":"","text":"vueComponet的分析关于VueComponent： 1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。 ​ 2.我们只需要写或，Vue解析时会帮我们创建school组件的实例对象，​ 即Vue帮我们执行的：new VueComponent(options)。​ 当我们书写或 时，vue会自动解析并帮我们调用new VueComponet(options)创建出一个新的实例​ 3.特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！ ​ —-&gt; 验证过程如下 ​ 4.关于this指向：​ (1).组件配置中：​ data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。​ (2).new Vue(options)配置中：​ data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。​ 5.VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。​ Vue的实例对象，以后简称vm。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;school&gt;&lt;/school&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.config.productionTip = false; var school=Vue.extend(&#123; name:&quot;school&quot;, template:` &lt;div&gt; &lt;h1&gt;school&lt;/h1&gt; &lt;/div&gt;`, data()&#123; return&#123; hello:&quot;hello&quot; &#125; &#125; &#125;) var student=Vue.extend(&#123; name:&quot;student&quot;, data()&#123; return&#123; hello:&quot;hello&quot; &#125; &#125; &#125;) 这里为验证过程 // 验证两个vuecomponent // 方式一 直接判断 // console.log(student==school); --&gt;false // //方式二往school上添加东西,如果school和student是同一个东西,那student上也会有 // 结果为undefined // school.a=99 // console.log(school.a,student.a); // --&gt; 99 undefined // 方式三查看源码 /* `` Vue.extend=function(extendOptions)&#123; …… var Sub =function vueComponet (options)&#123; this._init(options); //这里每次调用vuecomponent时，就会创建一个sub函数变量，并且返回该函数变量 //每一次调用时，sub都是现定义的 //固 // //每次调用vue.extend时，都会生成一个新的vuecompont的构造器函数 &#125; …… return Sub;&#125;*/console.log(student); var vm=new Vue(&#123; el:&#x27;#root&#x27;, components:&#123;school,student&#125; &#125;)","categories":[],"tags":[]},{"title":"1-数列入门.md","slug":"JAVA/1-变量/3-数列/1-数列入门","date":"2022-07-20T11:40:25.000Z","updated":"2022-10-24T12:06:39.095Z","comments":true,"path":"2022/07/20/JAVA/1-变量/3-数列/1-数列入门/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/JAVA/1-%E5%8F%98%E9%87%8F/3-%E6%95%B0%E5%88%97/1-%E6%95%B0%E5%88%97%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、简要介绍 默认初始化 无论作为成员变量还是class全局变量，数组变量都会有初始化 数组变量无论作为什么变量，都有默认初始化 创建 静态初始化 type[] parameterName = new Type[]&#123;data&#125; int[] arr =new int[]&#123;1，2，4，4&#125;; //or int[] arr=&#123;1,2,4,4&#125; 1234567891011121314151617### 二、一些细节1. 索引越界 1. 访问了数组不存在的索引对应的元素，造成索引越界。2. 空指针异常 1. 当数组变量不再指向堆内存中的数组数据时，造成空指针异常 1. ```java int [] arr=&#123;1,10,-1&#125;; arr=null; System.out.println(arr[1]); Exception in thread &quot;main&quot; java.lang.NullPointerException at com.jhfuture.Array.main.main(main.java:8)","categories":[],"tags":[]},{"title":"","slug":"vue/24-vueX/vuex","date":"2022-07-20T11:38:11.551Z","updated":"2022-10-06T14:40:17.379Z","comments":true,"path":"2022/07/20/vue/24-vueX/vuex/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/vue/24-vueX/vuex/","excerpt":"","text":"vueXVuex1.概念 在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。 2.何时使用？​ &#x3D;&#x3D;多个组件&#x3D;&#x3D;需要共享数据时 3.搭建vuex环境 创建文件：src/store/index.js 1234567891011121314151617181920//引入Vue核心库import Vue from &#x27;vue&#x27;//引入Vueximport Vuex from &#x27;vuex&#x27;//应用Vuex插件Vue.use(Vuex)//准备actions对象——响应组件中用户的动作const actions = &#123;&#125;//准备mutations对象——修改state中的数据const mutations = &#123;&#125;//准备state对象——保存具体的数据const state = &#123;&#125;//创建并暴露storeexport default new Vuex.Store(&#123; actions, mutations, state&#125;) 在main.js中创建vm时传入store配置项 1234567891011......//引入storeimport store from &#x27;./store&#x27;......//创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render: h =&gt; h(App), store&#125;) 4.基本使用 初始化数据、配置actions、配置mutations，操作文件store.js 12345678910111213141516171819202122232425262728293031323334//引入Vue核心库import Vue from &#x27;vue&#x27;//引入Vueximport Vuex from &#x27;vuex&#x27;//引用VuexVue.use(Vuex)const actions = &#123; //响应组件中加的动作 jia(context,value)&#123; // console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value) context.commit(&#x27;JIA&#x27;,value) &#125;,&#125;const mutations = &#123; //执行加 JIA(state,value)&#123; // console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value) state.sum += value &#125;&#125;//初始化数据const state = &#123; sum:0&#125;//创建并暴露storeexport default new Vuex.Store(&#123; actions, mutations, state,&#125;) 组件中读取vuex中的数据：$store.state.sum 组件中修改vuex中的数据：$store.dispatch(&#39;action中的方法名&#39;,数据) 或 $store.commit(&#39;mutations中的方法名&#39;,数据) 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit 5.getters的使用 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。 在store.js中追加getters配置 12345678910111213......const getters = &#123; bigSum(state)&#123; return state.sum * 10 &#125;&#125;//创建并暴露storeexport default new Vuex.Store(&#123; ...... getters&#125;) 组件中读取数据：$store.getters.bigSum 6.四个map方法的使用 mapState方法：用于帮助我们映射state中的数据为计算属性 1234567computed: &#123; //借助mapState生成计算属性：sum、school、subject（对象写法） ...mapState(&#123;sum:&#x27;sum&#x27;,school:&#x27;school&#x27;,subject:&#x27;subject&#x27;&#125;), //借助mapState生成计算属性：sum、school、subject（数组写法） ...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),&#125;, mapGetters方法：用于帮助我们映射getters中的数据为计算属性 1234567computed: &#123; //借助mapGetters生成计算属性：bigSum（对象写法） ...mapGetters(&#123;bigSum:&#x27;bigSum&#x27;&#125;), //借助mapGetters生成计算属性：bigSum（数组写法） ...mapGetters([&#x27;bigSum&#x27;])&#125;, mapActions方法：用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数 1234567methods:&#123; //靠mapActions生成：incrementOdd、incrementWait（对象形式） ...mapActions(&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;) //靠mapActions生成：incrementOdd、incrementWait（数组形式） ...mapActions([&#x27;jiaOdd&#x27;,&#x27;jiaWait&#x27;])&#125; mapMutations方法：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数 1234567methods:&#123; //靠mapActions生成：increment、decrement（对象形式） ...mapMutations(&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;), //靠mapMutations生成：JIA、JIAN（对象形式） ...mapMutations([&#x27;JIA&#x27;,&#x27;JIAN&#x27;]),&#125; 备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。 7.模块化+命名空间 目的：让代码更好维护，让多种数据分类更加明确。 修改store.js 12345678910111213141516171819202122232425const countAbout = &#123; namespaced:true,//开启命名空间 state:&#123;x:1&#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; bigSum(state)&#123; return state.sum * 10 &#125; &#125;&#125;const personAbout = &#123; namespaced:true,//开启命名空间 state:&#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; countAbout, personAbout &#125;&#125;) 开启命名空间后，组件中读取state数据： 1234//方式一：自己直接读取this.$store.state.personAbout.list//方式二：借助mapState读取：...mapState(&#x27;countAbout&#x27;,[&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]), 开启命名空间后，组件中读取getters数据： 1234//方式一：自己直接读取this.$store.getters[&#x27;personAbout/firstPersonName&#x27;]//方式二：借助mapGetters读取：...mapGetters(&#x27;countAbout&#x27;,[&#x27;bigSum&#x27;]) 开启命名空间后，组件中调用dispatch 1234//方式一：自己直接dispatchthis.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;,person)//方式二：借助mapActions：...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;) 开启命名空间后，组件中调用commit 1234//方式一：自己直接committhis.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,person)//方式二：借助mapMutations：...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),","categories":[],"tags":[]},{"title":"3-单行命令.md","slug":"MySQL/3-单行命令","date":"2022-07-20T11:11:21.000Z","updated":"2022-10-29T12:49:19.493Z","comments":true,"path":"2022/07/20/MySQL/3-单行命令/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/MySQL/3-%E5%8D%95%E8%A1%8C%E5%91%BD%E4%BB%A4/","excerpt":"","text":"一、简要介绍​ 单行处理，多行输出 特点：一行一行处理，每一行输出一个结果。 注意注意注意 单行函数中有 null 参与的数字运算最终值 总是null 1.+ - * &#x2F; 四则运算 2.多行命令中没有————- ​ 二、常用 lower (字段) 转小写 1234567891011121314151617181920mysql&gt; select lower(job) from emp;+------------+| lower(job) |+------------+| clerk || salesman || salesman || manager || salesman || manager || manager || analyst || president || salesman || clerk || clerk || analyst || clerk |+------------+14 rows in set (0.01 sec) upper (字段) 转大小 substr(字段,起始下表,截取长度) 取字符 &#x3D;&#x3D;在sql的字符串中，字符串的下表是从1开始的&#x3D;&#x3D; 123456789101112131415161718192021mysql&gt; select substr(job,1,3) from emp;## CLE+-----------------+| substr(job,1,3) |+-----------------+| CLE --&gt;clerk || SAL || SAL || MAN || SAL || MAN || MAN || ANA || PRE || SAL || CLE || CLE || ANA || CLE |+-----------------+14 rows in set (0.00 sec) concat(a,b) 将 b 字符串拼接到 a 的尾部。 1234567891011121314151617181920mysql&gt; select concat(job,mgr) from emp;+-----------------+| concat(job,mgr) |+-----------------+| CLERK7902 || SALESMAN7698 || SALESMAN7698 || MANAGER7839 || SALESMAN7698 || MANAGER7839 || MANAGER7839 || ANALYST7566 || NULL || SALESMAN7698 || CLERK7788 || CLERK7698 || ANALYST7566 || CLERK7782 |+-----------------+14 rows in set (0.00 sec) 额外的小知识 length(字段) 获取字段的长度 round(数字,保留的小数位),保留位为0则只保留整数位，且保留的值会进行四舍五入 1234567891011121314151617181920mysql&gt; select round(0.55,0) from emp;+---------------+| round(0.55,0) |+---------------+| 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 |+---------------+14 rows in set (0.00 sec) rand() 生成0到1的随机数 1234567891011121314151617181920mysql&gt; select rand() from emp;+----------------------+| rand() |+----------------------+| 0.6586841099510753 || 0.4807403501875143 || 0.4276494518179907 || 0.6960262392610556 || 0.19718287158495082 || 0.8978356708752323 || 0.8976297703549543 || 0.7946418698827195 || 0.2803200690823794 || 0.017674766497383608 || 0.24741365597342482 || 0.18404401110861823 || 0.17797911835646174 || 0.337763589190099 |+----------------------+14 rows in set (0.00 sec) 四则运算 1234567891011121314151617181920mysql&gt; select sal+comm from emp;+----------+| sal+comm |+----------+| NULL || 1900.00 || 1750.00 || NULL || 2650.00 || NULL || NULL || NULL || NULL || 1500.00 || NULL || NULL || NULL || NULL |+----------+14 rows in set (0.00 sec) Lower 转换小写 upper 转换大写 substr 取子串（substr(被截取的字符串,起始下标, 截取的长度)） length() 取长度 trim 去空格 str_to_date 将字符串转换成日期 date_format 格式化日期 format 设置千分位 round 四舍五入 rand() 生成随机数 Ifnull 可以将 null 转换成一个具体值","categories":[{"name":"mysql","slug":"mysql","permalink":"https://jhfuture.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jhfuture.github.io/tags/mysql/"}]},{"title":"多态数组","slug":"JAVA/4-面向对象(中级)/6-多态/2-多态的应用/1-多态数组","date":"2022-07-20T09:54:56.000Z","updated":"2022-10-22T06:48:35.376Z","comments":true,"path":"2022/07/20/JAVA/4-面向对象(中级)/6-多态/2-多态的应用/1-多态数组/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/JAVA/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%AD%E7%BA%A7)/6-%E5%A4%9A%E6%80%81/2-%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8/1-%E5%A4%9A%E6%80%81%E6%95%B0%E7%BB%84/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package com.jhfuture.poly._polyarr__;public class PloyArray &#123; public static void main(String[] args) &#123; Person person[]=new Person[3]; person[0]=new Person(&quot;这是个人&quot;); person[1]=new Student(&quot;小明&quot;,15); person[2]=new Teacher(&quot;李老师&quot;,1000); for (int i = 0; i &lt;person.length ; i++) &#123; //调用每一个say //输出结果由每一个运行类型决定 person[i].say(); if (person[i] instanceof Student)&#123; ((Student)person[i]).Study(); &#125;else if (person[i] instanceof Teacher)&#123; ((Teacher)person[i]).teacher(); &#125; &#125; &#125;&#125;//应用实例：现有一个class Person&#123; String name; public Person(String name) &#123; this.name = name; &#125; public void say()&#123; System.out.println(&quot;here is Person&quot;+getName()); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; Person()&#123; &#125;&#125;class Student extends Person&#123; String name; int age; public void say()&#123; System.out.println(&quot;here is Student&quot;+getName()); &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public void Study()&#123; System.out.println(&quot;可以学习&quot;); &#125; @Override public String getName() &#123; return name; &#125; @Override public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;class Teacher extends Person&#123; String name; double salery; public void say()&#123; System.out.println(&quot;here is Teacher&quot;+getName()); &#125; public Teacher( String name1, double salery) &#123; this.name = name1; this.salery = salery; &#125; public void teacher()&#123; System.out.println(&quot;可以教书&quot;); &#125; @Override public String getName() &#123; return name; &#125; @Override public void setName(String name) &#123; this.name = name; &#125; public double getSalery() &#123; return salery; &#125; public void setSalery(double salery) &#123; this.salery = salery; &#125;&#125; 123456//输出here is Person这是个人here is Student小明可以学习here is Teacher李老师可以教书","categories":[{"name":"java","slug":"java","permalink":"https://jhfuture.github.io/categories/java/"}],"tags":[{"name":"多态数组","slug":"多态数组","permalink":"https://jhfuture.github.io/tags/%E5%A4%9A%E6%80%81%E6%95%B0%E7%BB%84/"}]},{"title":"","slug":"树莓派/修改usb启动","date":"2022-07-20T08:55:06.533Z","updated":"2022-07-20T08:58:05.364Z","comments":true,"path":"2022/07/20/树莓派/修改usb启动/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/%E6%A0%91%E8%8E%93%E6%B4%BE/%E4%BF%AE%E6%94%B9usb%E5%90%AF%E5%8A%A8/","excerpt":"","text":"引脚图 前言正式开始之前先说一下为什么4B的USB启动这么姗姗来迟。 要了解这个问题，我们先要了解一下4B之前的版本的启动流程，主要分为四个阶段： GPU读取芯片上一个ROM的内容并执行 ROM中的程序挂载SD卡并加载第一个FAT分区上的bootcode.bin bootcode.bin从FAT分区加载start.elf start.elf从FAT分区加载kernel.img，然后唤醒CPU,CPU开始执行kernel.img 从这个流程中可以看到，第一阶段的BootLoader是从芯片上的ROM中读取的，ROM里的代码是出厂定制好的后期不能再改变。然而随着4B的硬件升级，USB被移到了PCIe总线，网卡也用了新的型号，再加上4B启动过程和SDRAM的设置远比之前的型号要复杂的多，继续使用集成在SoC ROM中的代码是有很大风险的，所以4B增加了一块EEPROM来解决这个问题，启动程序写入到EEPROM中来取代bootcode.bin的工作，启动程序的bug修复和新功能添加都方便了很多。 启动机制改动还是挺大的，所以USB启动姗姗来迟还是可以理解的。 关于EEPROM和4B启动流程的内容可以参考下面两篇文章： pi4 eeprom pi4 bootflow 更新eeprom1、使用rpi-eeprom更新最新的官方系统里已经集成了rpi-eeprom包来升级eeprom，官方github上有这个项目的源码，如果不是官方系统可以clone此项目来升级eeprom，项目地址是：https://github.com/raspberrypi/rpi-eeprom，里面包含升级脚本和固件。 三方系统(例如树莓派爱好者基地2.0系统)升级方法请看这里，这篇文章介绍官方系统的升级方法： 整个升级过程都需要root权限，如果你是用pi用户登录的，先执行sudo -i切换到root用户。 123#升级系统软件包apt updateapt upgrade 然后编辑/etc/default/rpi-eeprom-update文件，把内容改为FIRMWARE_RELEASE_STATUS=&quot;beta&quot; 如果想用固件的默认配置直接执行rpi-eeprom-update -d -a，然后重启完成升级。 如果想修改eeprom的参数配置，请参考这里。 重启后进入系统验证一下eeprom固件版本，执行rpi-eeprom-update，如果BOOTLOADER的版本在2020-05-15及以上就可以USB启动了。","categories":[],"tags":[]},{"title":"","slug":"JAVA/4-面向对象(中级)/2-访问修饰符","date":"2022-07-20T05:47:19.392Z","updated":"2022-10-16T07:10:14.789Z","comments":true,"path":"2022/07/20/JAVA/4-面向对象(中级)/2-访问修饰符/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/JAVA/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%AD%E7%BA%A7)/2-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"","text":"修饰符为了保护java类中的属性&#x2F;方法&#x2F;类本身—&gt;封装 一、类型 public 特点： 本类—–&gt; yes 子类—–&gt; yes 访问级别 访问控制修饰符 同类 同包 子类 不同包 公开 public √ √ √ √ 受保护的 protected √ √ √ × 默认 没有修饰符 √ √ × × 私有 private √ × × × 二、使用的注意事项 修饰符可以用来修饰类的属性、成员方法及类本身 只有默认修饰符和public可以修饰class 成员方法的访问规则和属性完全一样。","categories":[],"tags":[]},{"title":"","slug":"随身WiFi的折腾/Debian","date":"2022-07-20T05:37:40.346Z","updated":"2022-07-20T05:42:10.940Z","comments":true,"path":"2022/07/20/随身WiFi的折腾/Debian/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/%E9%9A%8F%E8%BA%ABWiFi%E7%9A%84%E6%8A%98%E8%85%BE/Debian/","excerpt":"","text":"安装base.zip 刷写Debian系统 配置驱动程序 修改ADB 安装NDIS驱动 这里会有一个未知设备（由于我已经安装完成驱动则不会出现) 选择驱动 选择网络适配器，然后选择 Microsoft —-&gt;NDIS","categories":[],"tags":[]},{"title":"","slug":"vue/22-插槽slot/插槽","date":"2022-07-20T05:27:17.605Z","updated":"2022-07-20T05:27:17.605Z","comments":true,"path":"2022/07/20/vue/22-插槽slot/插槽/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/vue/22-%E6%8F%92%E6%A7%BDslot/%E6%8F%92%E6%A7%BD/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"vue/推荐使用的插件","date":"2022-07-20T03:16:38.899Z","updated":"2022-07-20T05:26:05.584Z","comments":true,"path":"2022/07/20/vue/推荐使用的插件/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/vue/%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/","excerpt":"","text":"Vetur author—–pine WU","categories":[],"tags":[]},{"title":"","slug":"硬件知识/固态硬盘/硬盘知识","date":"2022-07-20T02:41:03.865Z","updated":"2022-09-19T02:58:39.742Z","comments":true,"path":"2022/07/20/硬件知识/固态硬盘/硬盘知识/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/%E7%A1%AC%E7%9B%98%E7%9F%A5%E8%AF%86/","excerpt":"","text":"引入硬盘的组成 : 主控、DRAM、NAND 各类介绍 一、 NAND的分类: SLC(Single Level Cell 单层单元) MLT(Mutil Level Ceil) TLC(Triple Level Ceil) 二、DRAM： ​ 1. 存储FTL（flash translation ): ​ 当操作系统向硬盘写入数据时，主控会根据情况挑选NAND中的一块区域，在写入数据的同时，也会将数据的位置 nand2 dieChip03 114 区块 51页——&gt; 即为 flash translation layer 记录到DRAM中。 缓解写放大: 在硬盘向","categories":[],"tags":[]},{"title":"","slug":"vue/12-列表渲染/更新的问题","date":"2022-07-20T02:31:16.814Z","updated":"2022-07-20T02:34:22.706Z","comments":true,"path":"2022/07/20/vue/12-列表渲染/更新的问题/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/vue/12-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/%E6%9B%B4%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"引出 以下的updatemei方法中直接更新了数组下表为1的整个元素，但在vue开发者工具中没有体现 1234567891011121314151617181920212223242526&lt;script&gt; Vue.config.productionTip = false //阻止vue在启动时生成生产提示 new Vue(&#123; el: &#x27;#root&#x27;, data: &#123; name: &#x27;helloworld&#x27;, sortType:0,//1为升序，2位降序，0默认不变, persons: [ &#123; id: &#x27;001&#x27;, name: &#x27;马冬梅&#x27;, age: 30, sex: &#x27;女&#x27; &#125;, &#123; id: &#x27;002&#x27;, name: &#x27;周冬雨&#x27;, age: 19, sex: &#x27;女&#x27; &#125;, &#123; id: &#x27;003&#x27;, name: &#x27;周杰伦&#x27;, age: 18, sex: &#x27;男&#x27; &#125;, &#123; id: &#x27;004&#x27;, name: &#x27;温兆伦&#x27;, age: 20, sex: &#x27;男&#x27; &#125; ], keyWord:&#x27;&#x27; &#125;, methods: &#123; //这样修改vue并没有认可你的修改 updatemei()&#123; this.persons[0] = &#123;id: &#x27;001&#x27;, name: &#x27;马老师&#x27;, age: 30, sex: &#x27;女&#x27;&#125; &#125; &#125; &#125;) &lt;/script&gt; 点击事件后 Vue更新的原理","categories":[],"tags":[]},{"title":"","slug":"邮件后端接口文档","date":"2022-07-19T16:33:01.618Z","updated":"2022-08-25T16:51:29.121Z","comments":true,"path":"2022/07/20/邮件后端接口文档/","link":"","permalink":"https://jhfuture.github.io/2022/07/20/%E9%82%AE%E4%BB%B6%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/","excerpt":"","text":"12345678910111213141516171819202122232425262728&lt;!---1. 先引入jquery库 --&gt;&lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot; integrity=&quot;sha256-Qw82+bXyGq6MydymqBxNPYTaUXXq7c8v3CwiYwLLNXU=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;!--这里使用cdn引入，亦可以使用本地文件引入 --&gt;&lt;!---2. 调用jquery中的Ajax发送请求 --&gt; $.ajax(&#123; url: &#x27;https://mousehao.fun/api/sendEmail/public/index.php/index/SendEmail/send&#x27;, type: &#x27;POST&#x27;, // 设置的是请求参数 data: &#123; passCode:&quot;xxx&quot;, //接口使用授权码，请联系吴部获取 SMTPHost:&quot;smtp.qq.com&quot;, //你的邮箱对应的SMTP服务器 ， 这里以QQ邮箱举例 AuthorizationCode:&quot;xxxx&quot;, //你的smtp授权码 From:&quot;yinghao_wu@qq.com&quot;, //发件的邮箱(即你的邮箱) To:&quot;1412xxxx91@qq.com&quot;, //收件人邮箱 FromName:&quot;广师大科教@网络研发部&quot;, //发件人 Title:&quot;接口测试&quot;, // 邮件主题 Body:&#x27;&lt;div style=&quot;color:pink&quot;&gt;粉色字体&lt;/div&gt;&#x27; //这里为邮件内容 &#125; success: function (res) &#123; console.log(res); &#125; &#125;);","categories":[],"tags":[]}],"categories":[{"name":"Spring6","slug":"Spring6","permalink":"https://jhfuture.github.io/categories/Spring6/"},{"name":"JAVA","slug":"JAVA","permalink":"https://jhfuture.github.io/categories/JAVA/"},{"name":"Windows使用技巧","slug":"Windows使用技巧","permalink":"https://jhfuture.github.io/categories/Windows%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"JUnit","slug":"JUnit","permalink":"https://jhfuture.github.io/categories/JUnit/"},{"name":"java","slug":"java","permalink":"https://jhfuture.github.io/categories/java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://jhfuture.github.io/categories/JDBC/"},{"name":"mysql","slug":"mysql","permalink":"https://jhfuture.github.io/categories/mysql/"},{"name":"MySQL","slug":"MySQL","permalink":"https://jhfuture.github.io/categories/MySQL/"},{"name":"Java","slug":"Java","permalink":"https://jhfuture.github.io/categories/Java/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://jhfuture.github.io/categories/JavaWeb/"},{"name":"Servlet","slug":"JavaWeb/Servlet","permalink":"https://jhfuture.github.io/categories/JavaWeb/Servlet/"},{"name":"Javaweb","slug":"Javaweb","permalink":"https://jhfuture.github.io/categories/Javaweb/"},{"name":"Servlet","slug":"Javaweb/Servlet","permalink":"https://jhfuture.github.io/categories/Javaweb/Servlet/"},{"name":"Android","slug":"Android","permalink":"https://jhfuture.github.io/categories/Android/"},{"name":"TWRP","slug":"Android/TWRP","permalink":"https://jhfuture.github.io/categories/Android/TWRP/"},{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/categories/Vue/"},{"name":"前端三剑客","slug":"前端三剑客","permalink":"https://jhfuture.github.io/categories/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/"},{"name":"软/硬件知识","slug":"软-硬件知识","permalink":"https://jhfuture.github.io/categories/%E8%BD%AF-%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86/"},{"name":"javascript进阶知识","slug":"前端三剑客/javascript进阶知识","permalink":"https://jhfuture.github.io/categories/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/javascript%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"},{"name":"hexo","slug":"hexo","permalink":"https://jhfuture.github.io/categories/hexo/"},{"name":"响应式","slug":"响应式","permalink":"https://jhfuture.github.io/categories/%E5%93%8D%E5%BA%94%E5%BC%8F/"}],"tags":[{"name":"事务","slug":"事务","permalink":"https://jhfuture.github.io/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"Spring6","slug":"Spring6","permalink":"https://jhfuture.github.io/tags/Spring6/"},{"name":"反射","slug":"反射","permalink":"https://jhfuture.github.io/tags/%E5%8F%8D%E5%B0%84/"},{"name":"Windows","slug":"Windows","permalink":"https://jhfuture.github.io/tags/Windows/"},{"name":"JAVA","slug":"JAVA","permalink":"https://jhfuture.github.io/tags/JAVA/"},{"name":"集合","slug":"集合","permalink":"https://jhfuture.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"枚举","slug":"枚举","permalink":"https://jhfuture.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"注解","slug":"注解","permalink":"https://jhfuture.github.io/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"DBA","slug":"DBA","permalink":"https://jhfuture.github.io/tags/DBA/"},{"name":"mysql索引失效","slug":"mysql索引失效","permalink":"https://jhfuture.github.io/tags/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/"},{"name":"sql约束","slug":"sql约束","permalink":"https://jhfuture.github.io/tags/sql%E7%BA%A6%E6%9D%9F/"},{"name":"mysql索引","slug":"mysql索引","permalink":"https://jhfuture.github.io/tags/mysql%E7%B4%A2%E5%BC%95/"},{"name":"mysql索引的引出","slug":"mysql索引的引出","permalink":"https://jhfuture.github.io/tags/mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BC%95%E5%87%BA/"},{"name":"check","slug":"check","permalink":"https://jhfuture.github.io/tags/check/"},{"name":"sql视图","slug":"sql视图","permalink":"https://jhfuture.github.io/tags/sql%E8%A7%86%E5%9B%BE/"},{"name":"抽象类","slug":"抽象类","permalink":"https://jhfuture.github.io/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"name":"Java","slug":"Java","permalink":"https://jhfuture.github.io/tags/Java/"},{"name":"Servlet","slug":"Servlet","permalink":"https://jhfuture.github.io/tags/Servlet/"},{"name":"servlet","slug":"servlet","permalink":"https://jhfuture.github.io/tags/servlet/"},{"name":"JDBC","slug":"JDBC","permalink":"https://jhfuture.github.io/tags/JDBC/"},{"name":"twrp","slug":"twrp","permalink":"https://jhfuture.github.io/tags/twrp/"},{"name":"MySQL","slug":"MySQL","permalink":"https://jhfuture.github.io/tags/MySQL/"},{"name":"mysql","slug":"mysql","permalink":"https://jhfuture.github.io/tags/mysql/"},{"name":"compile","slug":"compile","permalink":"https://jhfuture.github.io/tags/compile/"},{"name":"finalize","slug":"finalize","permalink":"https://jhfuture.github.io/tags/finalize/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://jhfuture.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"toString","slug":"toString","permalink":"https://jhfuture.github.io/tags/toString/"},{"name":"数据类型转换","slug":"数据类型转换","permalink":"https://jhfuture.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"String字符串","slug":"String字符串","permalink":"https://jhfuture.github.io/tags/String%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"this关键字","slug":"this关键字","permalink":"https://jhfuture.github.io/tags/this%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"成员方法","slug":"成员方法","permalink":"https://jhfuture.github.io/tags/%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95/"},{"name":"多态应用/多态参数","slug":"多态应用-多态参数","permalink":"https://jhfuture.github.io/tags/%E5%A4%9A%E6%80%81%E5%BA%94%E7%94%A8-%E5%A4%9A%E6%80%81%E5%8F%82%E6%95%B0/"},{"name":"经典面试题","slug":"经典面试题","permalink":"https://jhfuture.github.io/tags/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"super","slug":"super","permalink":"https://jhfuture.github.io/tags/super/"},{"name":"安装教程","slug":"安装教程","permalink":"https://jhfuture.github.io/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"name":"Vue组件","slug":"Vue组件","permalink":"https://jhfuture.github.io/tags/Vue%E7%BB%84%E4%BB%B6/"},{"name":"Vue","slug":"Vue","permalink":"https://jhfuture.github.io/tags/Vue/"},{"name":"vue绑定样式","slug":"vue绑定样式","permalink":"https://jhfuture.github.io/tags/vue%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F/"},{"name":"本地储存","slug":"本地储存","permalink":"https://jhfuture.github.io/tags/%E6%9C%AC%E5%9C%B0%E5%82%A8%E5%AD%98/"},{"name":"rem适配","slug":"rem适配","permalink":"https://jhfuture.github.io/tags/rem%E9%80%82%E9%85%8D/"},{"name":"Less","slug":"Less","permalink":"https://jhfuture.github.io/tags/Less/"},{"name":"css扩展","slug":"css扩展","permalink":"https://jhfuture.github.io/tags/css%E6%89%A9%E5%B1%95/"},{"name":"像素比大小","slug":"像素比大小","permalink":"https://jhfuture.github.io/tags/%E5%83%8F%E7%B4%A0%E6%AF%94%E5%A4%A7%E5%B0%8F/"},{"name":"原型链","slug":"原型链","permalink":"https://jhfuture.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"vue组件","slug":"vue组件","permalink":"https://jhfuture.github.io/tags/vue%E7%BB%84%E4%BB%B6/"},{"name":"硬核知识","slug":"硬核知识","permalink":"https://jhfuture.github.io/tags/%E7%A1%AC%E6%A0%B8%E7%9F%A5%E8%AF%86/"},{"name":"前端","slug":"前端","permalink":"https://jhfuture.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue中的技巧","slug":"Vue中的技巧","permalink":"https://jhfuture.github.io/tags/Vue%E4%B8%AD%E7%9A%84%E6%8A%80%E5%B7%A7/"},{"name":"Vue中的坑","slug":"Vue中的坑","permalink":"https://jhfuture.github.io/tags/Vue%E4%B8%AD%E7%9A%84%E5%9D%91/"},{"name":"Vue方法","slug":"Vue方法","permalink":"https://jhfuture.github.io/tags/Vue%E6%96%B9%E6%B3%95/"},{"name":"hexo","slug":"hexo","permalink":"https://jhfuture.github.io/tags/hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://jhfuture.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"前段三剑客","slug":"前段三剑客","permalink":"https://jhfuture.github.io/tags/%E5%89%8D%E6%AE%B5%E4%B8%89%E5%89%91%E5%AE%A2/"},{"name":"响应式开发","slug":"响应式开发","permalink":"https://jhfuture.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/"},{"name":"多态数组","slug":"多态数组","permalink":"https://jhfuture.github.io/tags/%E5%A4%9A%E6%80%81%E6%95%B0%E7%BB%84/"}]}