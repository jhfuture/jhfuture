<hr>
<p>title: 3-List接口<br>toc: true<br>tags:</p>
<ul>
<li>null<br>categories:</li>
<li>null<br>date: 2022-11-21 16:45:34</li>
</ul>
<hr>
<!--more-->

<blockquote>
<p>使用 System.out.println(arrayList); 打印 ArrayList 时，调用的也是 ArrayList 类的 &#x3D;&#x3D;toString&#x3D;&#x3D;方法</p>
</blockquote>
<h3 id="一、简要介绍"><a href="#一、简要介绍" class="headerlink" title="一、简要介绍"></a>一、简要介绍</h3><p><img src="/3-List%E6%8E%A5%E5%8F%A3/image-20221121165104877.png" alt="image-20221121165104877"></p>
<ul>
<li>有序且可重复</li>
<li>支持索引，且&#x3D;&#x3D;索引从 0 开始&#x3D;&#x3D;,可以使用 索引读取指定数据。</li>
</ul>
<h3 id="二、常用方法"><a href="#二、常用方法" class="headerlink" title="二、常用方法"></a>二、常用方法</h3><ul>
<li>void add(int index, Object ele):在 index 位置插入 ele 元素</li>
<li>boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来</li>
<li>Object get(int index):获取指定 index 位置的元素</li>
<li>int indexOf(Object obj):返回 obj 在集合中&#x3D;&#x3D;首次&#x3D;&#x3D;出现的位置</li>
<li>int lastIndexOf(Object obj):返回 obj 在当前集合中&#x3D;&#x3D;末次&#x3D;&#x3D;出现的位置</li>
<li>Object remove(&#x3D;&#x3D;int index&#x3D;&#x3D;):移除指定 index 位置的元素，并&#x3D;&#x3D;返回此元素&#x3D;&#x3D;</li>
<li>Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换. list.set(1, “玛丽”);</li>
<li>List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合</li>
</ul>
<pre><code class="java">ublic class ListMethod {
@SuppressWarnings({&quot;all&quot;})
public static void main(String[] args) {
List list = new ArrayList();
list.add(&quot;张三丰&quot;);
list.add(&quot;贾宝玉&quot;);

    
// void add(int index, Object ele):在 index 位置插入 ele 元素
//在 index = 1 的位置插入一个对象
list.add(1, &quot;韩顺平&quot;);
System.out.println(&quot;list=&quot; + list);
// boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来
List list2 = new ArrayList();
list2.add(&quot;jack&quot;);
list2.add(&quot;tom&quot;);
list.addAll(1, list2);
System.out.println(&quot;list=&quot; + list);
// Object get(int index):获取指定 index 位置的元素
//说过
// int indexOf(Object obj):返回 obj 在集合中首次出现的位置
System.out.println(list.indexOf(&quot;tom&quot;));//2
// int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置
list.add(&quot;韩顺平&quot;);
System.out.println(&quot;list=&quot; + list);
System.out.println(list.lastIndexOf(&quot;韩顺平&quot;));
// Object remove(int index):移除指定 index 位置的元素，并返回此元素
list.remove(0);
System.out.println(&quot;list=&quot; + list);
// Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换. list.set(1, &quot;玛丽&quot;);
System.out.println(&quot;list=&quot; + list);
// List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合
// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex
List returnlist = list.subList(0, 2);
System.out.println(&quot;returnlist=&quot; + returnlist);
}
}
</code></pre>
<h3 id="三、练习"><a href="#三、练习" class="headerlink" title="三、练习"></a>三、练习</h3><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><p><img src="/3-List%E6%8E%A5%E5%8F%A3/image-20221121165501932.png" alt="image-20221121165501932"></p>
<pre><code class="java">
public class ListExercise {
@SuppressWarnings({&quot;all&quot;})
public static void main(String[] args) {
/*
添加 10 个以上的元素(比如 String &quot;hello&quot; )，在 2 号位插入一个元素&quot;韩顺平教育&quot;，
获得第 5 个元素，删除第 6 个元素，修改第 7 个元素，在使用迭代器遍历集合，
要求:使用 List 的实现类 ArrayList 完成。
*/
List list = new ArrayList();
for (int i = 0; i &lt; 12; i++) {
list.add(&quot;hello&quot; + i);
}
System.out.println(&quot;list=&quot; + list);
//在 2 号位插入一个元素&quot;韩顺平教育&quot;
list.add(1, &quot;韩顺平教育&quot;);
System.out.println(&quot;list=&quot; + list);
//获得第 5 个元素
System.out.println(&quot;第五个元素=&quot; + list.get(4));
//删除第 6 个元素
list.remove(5);
System.out.println(&quot;list=&quot; + list);
//修改第 7 个元素
list.set(6, &quot;三国演义&quot;);
System.out.println(&quot;list=&quot; + list);
//在使用迭代器遍历集合
Iterator iterator = list.iterator();
while (iterator.hasNext()) {
Object obj = iterator.next();
System.out.println(&quot;obj=&quot; + obj);
}

}
}
</code></pre>
<h4 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h4><p><img src="/3-List%E6%8E%A5%E5%8F%A3/image-20221121190010416.png" alt="image-20221121190010416"></p>
<pre><code class="java">
</code></pre>
<h3 id="四、普通-for-循环"><a href="#四、普通-for-循环" class="headerlink" title="四、普通 for 循环"></a>四、普通 for 循环</h3><h4 id="what"><a href="#what" class="headerlink" title="what?"></a>what?</h4><p>使用 get 方法</p>
<h4 id="how"><a href="#how" class="headerlink" title="how"></a>how</h4><pre><code class="java"> for (int i = 0; i &lt;arrayList.size() ; i++) {
            System.out.println(arrayList.get(i));
        }
</code></pre>
<h3 id="五、注意"><a href="#五、注意" class="headerlink" title="五、注意"></a>五、注意</h3><p><img src="/3-List%E6%8E%A5%E5%8F%A3/image-20221121191931474.png" alt="image-20221121191931474"></p>
<p>线程不安全</p>
<pre><code class="java"> public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
没有 synchronized
</code></pre>
<h3 id="六、底层分析"><a href="#六、底层分析" class="headerlink" title="六、底层分析"></a>六、底层分析</h3><h4 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1)ArrayList"></a>1)ArrayList</h4><p><img src="/3-List%E6%8E%A5%E5%8F%A3/image-20221121193141042.png" alt="image-20221121193141042"></p>
<ol>
<li>不会被序列化 维护一个elementData</li>
<li>扩充<ol>
<li>0(默认构造器)—&gt;10 —&gt;15 —&gt; 22</li>
<li>8(指定)—&gt;14—-&gt;21</li>
</ol>
</li>
</ol>
<blockquote>
<p>Arrays.copy(url  , int newlength)方法。且会保留原有的数据。</p>
</blockquote>
<p><img src="/3-List%E6%8E%A5%E5%8F%A3/image-20221121195549894.png" alt="image-20221121195549894"></p>
<p><img src="/3-List%E6%8E%A5%E5%8F%A3/image-20221121195648294.png" alt="image-20221121195648294"></p>
<p><img src="/3-List%E6%8E%A5%E5%8F%A3/image-20221121195703567.png" alt="image-20221121195703567"></p>
<blockquote>
<p>一个利用移位扩容。<br><img src="/3-List%E6%8E%A5%E5%8F%A3/image-20221121195742085.png" alt="image-20221121195742085"></p>
</blockquote>
<pre><code class="java">
//

默认为空的调试代码
    
    
默认不为空的调试代码

public static void main(String[] args) {
//老韩解读源码
//注意，注意，注意，Idea 默认情况下，Debug 显示的数据是简化后的，如果希望看到完整的数据
//需要做设置. //使用无参构造器创建 ArrayList 对象
//ArrayList list = new ArrayList();
ArrayList list = new ArrayList(8);
//使用 for 给 list 集合添加 1-10 数据
for (int i = 1; i &lt;= 10; i++) {
list.add(i);
}
//使用 for 给 list 集合添加 11-15 数据
for (int i = 11; i &lt;= 15; i++) {
list.add(i);
}
list.add(100);
list.add(200);
list.add(null);
}
</code></pre>
<h4 id="2-vector"><a href="#2-vector" class="headerlink" title="2)vector"></a>2)vector</h4><h5 id="自定义扩容"><a href="#自定义扩容" class="headerlink" title="自定义扩容"></a>自定义扩容</h5><pre><code class="java">int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?capacityIncrement : oldCapacity);
=================有构造器中可以设置 increment=========================
public Vector(int initialCapacity, int capacityIncrement) {
        super();
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        this.elementData = new Object[initialCapacity];
        this.capacityIncrement = capacityIncrement;
    }
</code></pre>
<h5 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h5><pre><code class="java">@SuppressWarnings({&quot;all&quot;})
public class Vector_ {
public static void main(String[] args) {
//无参构造器
//有参数的构造
Vector vector = new Vector(8);
for (int i = 0; i &lt; 10; i++) {
vector.add(i);
韩顺平循序渐进学 Java 零基础
第 628页
}
vector.add(100);
System.out.println(&quot;vector=&quot; + vector);
//老韩解读源码
//1. new Vector() 底层
/*
public Vector() {
this(10);
}
补充：如果是 Vector vector = new Vector(8);
走的方法:
public Vector(int initialCapacity) {
this(initialCapacity, 0);
}
2. vector.add(i)
2.1 //下面这个方法就添加数据到 vector 集合
public synchronized boolean add(E e) {
modCount++;
ensureCapacityHelper(elementCount + 1);
elementData[elementCount++] = e;
return true;
}
2.2 //确定是否需要扩容 条件 ： minCapacity - elementData.length&gt;0
private void ensureCapacityHelper(int minCapacity) {
// overflow-conscious code
if (minCapacity - elementData.length &gt; 0)
韩顺平循序渐进学 Java 零基础
第 629页
grow(minCapacity);
}
2.3 //如果 需要的数组大小 不够用，就扩容 , 扩容的算法
//newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
// capacityIncrement : oldCapacity);
//就是扩容两倍. private void grow(int minCapacity) {
// overflow-conscious code
int oldCapacity = elementData.length;
int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
capacityIncrement : oldCapacity);
if (newCapacity - minCapacity &lt; 0)
newCapacity = minCapacity;
if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
newCapacity = hugeCapacity(minCapacity);
elementData = Arrays.copyOf(elementData, newCapacity);
}
*/
}
}
</code></pre>
<h4 id="3-ArrayList-和-vector"><a href="#3-ArrayList-和-vector" class="headerlink" title="3)ArrayList 和 vector"></a>3)ArrayList 和 vector</h4><p><img src="/3-List%E6%8E%A5%E5%8F%A3/image-20221121221012765.png" alt="image-20221121221012765"></p>
