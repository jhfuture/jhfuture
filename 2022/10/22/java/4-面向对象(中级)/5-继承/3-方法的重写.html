<h3 id="一、方法重写"><a href="#一、方法重写" class="headerlink" title="一、方法重写"></a>一、方法重写</h3><p>方法重写也叫方法覆盖，需要满足下面的条件</p>
<ol>
<li><p>子类的方法&#x3D;&#x3D;参数，方法名&#x3D;&#x3D;，要和父类的参数，方法名称完全一样。</p>
<ol>
<li>参数（个数&#x2F;类别，顺序都要一样），&#x3D;&#x3D;否则就是方法的多态&#x3D;&#x3D;，而不构成重写！</li>
</ol>
</li>
<li><p>子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类。</p>
<ol>
<li><p>eg: 父类返回的类型是Object,子类方法返回类型是 String</p>
<ol>
<li><p>正确—-&gt;public Object getinfo()  public String getinfo()</p>
</li>
<li><p>错误举例</p>
<ol>
<li><pre><code class="java">class  hello{
        public String say (String name){}
    }
    class  t extends hello{
        public Object say(String age){

        }
    }

error:
say(String)&#39; in &#39;com.jhfuture.object.Person.t&#39; clashes with &#39;say(String)&#39; in &#39;com.jhfuture.object.Person.hello&#39;; attempting to use incompatible return type
</code></pre>
</li>
</ol>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
<li><p>子类方法不能缩小父类方法的&#x3D;&#x3D;访问权限&#x3D;&#x3D;</p>
<ol>
<li><p>父类： void sayOk()   子类：public void sayOk() </p>
<ol>
<li><pre><code class="java"> class  hello{
        public void say (String name){}
    }
    class  t extends hello{
        private void say(String age){

        }
    }
}
---&gt;报错
   erro: &#39;say(String)&#39; in &#39;com.jhfuture.object.Person.t&#39; clashes with &#39;say(String)&#39; in &#39;com.jhfuture.object.Person.hello&#39;; attempting to assign weaker access privileges (&#39;private&#39;); was &#39;public&#39;
</code></pre>
</li>
<li></li>
</ol>
</li>
<li><p>默认—-&gt; public   public&gt;protected&gt; 默认&gt; private</p>
</li>
</ol>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>方法重写时，需要注意两个重要点，1是访问权限，2.返回类型，不同则报错。最后一个为参数，如果不同则只是方法的重载。</li>
</ol>
