<hr>
<p>title: 3-设计模式<br>toc: true<br>tags:</p>
<ul>
<li>null<br>categories:</li>
<li>null<br>date: 2023-01-04 19:53:24</li>
</ul>
<hr>
<!--more-->

<h2 id="GoF"><a href="#GoF" class="headerlink" title="GoF"></a>GoF</h2><h3 id="一、分类"><a href="#一、分类" class="headerlink" title="一、分类"></a>一、分类</h3><p>创建式</p>
<ul>
<li>工厂模式</li>
</ul>
<p>结构式</p>
<ul>
<li><p>代理模式</p>
<ul>
<li>JDK提供的可以自动生成代理对象的 proxy 类</li>
</ul>
</li>
<li><p>装饰模式</p>
<ul>
<li>io 流的包装</li>
</ul>
</li>
<li><p>适配器模式</p>
<ul>
<li>httpServlet</li>
</ul>
</li>
</ul>
<p>行为式</p>
<ul>
<li>观察者模式<ul>
<li>servlet 监听器</li>
</ul>
</li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单工厂模式的角色包括三个：</p>
<ul>
<li>抽象产品 角色</li>
<li>具体产品 角色</li>
<li>工厂类 角色</li>
</ul>
<p>简单工厂模式是 工厂方法模式的特殊一种</p>
<h2 id="6-2-简单工厂模式"><a href="#6-2-简单工厂模式" class="headerlink" title="6.2 简单工厂模式"></a>6.2 简单工厂模式</h2><p>消费者和生产者的关系。</p>
<p>简单工厂模式的优点：</p>
<ul>
<li>客户端程序&#x3D;&#x3D;不需要关心对象的创建细节&#x3D;&#x3D;，需要哪个对象时，只需要向工厂索要即可，初步实现了责任的分离。客户端只负责“消费”，工厂负责“生产”。生产和消费分离。</li>
</ul>
<p>简单工厂模式的缺点：</p>
<ul>
<li>缺点1：工厂类集中了所有产品的创造逻辑，形成一个无所不知的全能类，有人把它叫做上帝类。显然工厂类非常关键，不能出问题，一旦出问题，整个系统瘫痪。</li>
<li>缺点2：不符合OCP开闭原则，在进行系统扩展时，需要修改工厂类。</li>
</ul>
<p><strong>Spring中的BeanFactory就使用了简单工厂模式。</strong></p>
<h2 id="6-3-工厂方法模式"><a href="#6-3-工厂方法模式" class="headerlink" title="6.3 工厂方法模式"></a>6.3 工厂方法模式</h2><p>&#x3D;&#x3D;一个工厂生产一个产品&#x3D;&#x3D;</p>
<p>工厂方法模式既保留了简单工厂模式的优点，同时又解决了简单工厂模式的缺点。</p>
<p>工厂方法模式的角色包括：</p>
<ul>
<li><strong>抽象工厂角色</strong></li>
<li><strong>具体工厂角色</strong></li>
<li>抽象产品角色</li>
<li>具体产品角色</li>
</ul>
<p>我们可以看到在进行功能扩展的时候，不需要修改之前的源代码，显然工厂方法模式符合OCP原则。</p>
<p>工厂方法模式的优点：</p>
<ul>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。 </li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ul>
<p>工厂方法模式的缺点：—&gt;类爆炸</p>
<ul>
<li>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</li>
</ul>
