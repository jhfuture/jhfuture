<hr>
<p>title: 2-注解<br>toc: true<br>tags:</p>
<ul>
<li>注解<br>categories:</li>
<li>java<br>date: 2022-11-15 21:44:45</li>
</ul>
<hr>
<h3 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h3><p>注解的理解 </p>
<ol>
<li>注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。 </li>
<li>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。 </li>
<li>在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角 色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。</li>
</ol>
<p>基本的 Annotation 介绍<br>使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元<br>素<br>三个基本的 Annotation:</p>
<ol>
<li>@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法</li>
<li>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时</li>
<li>@SuppressWarnings: 抑制编译器警告</li>
</ol>
<p><img src="/2-%E6%B3%A8%E8%A7%A3/image-20221116162804499.png" alt="image-20221116162804499"></p>
<p><img src="/2-%E6%B3%A8%E8%A7%A3/image-20221116162939749.png" alt="image-20221116162939749"></p>
<h3 id="二、逐个分析"><a href="#二、逐个分析" class="headerlink" title="二、逐个分析"></a>二、逐个分析</h3><h4 id="1-override"><a href="#1-override" class="headerlink" title="1.override"></a>1.override</h4><p>重写</p>
<h4 id="2-Deprecated"><a href="#2-Deprecated" class="headerlink" title="2.Deprecated"></a>2.Deprecated</h4><ol>
<li><p>@Deprecated 修饰某个元素, 表示该元素已经过时 &#x2F;&#x2F;</p>
</li>
<li><p>即不在推荐使用，但是仍然可以使用 </p>
</li>
<li><p>查看 @Deprecated 注解类的源码 韩顺平循序渐进学 Java 零基础 第 495页</p>
</li>
<li><p>可以修饰方法，类，字段, 包, 参数 等等 </p>
</li>
<li><p>@Deprecated 可以做版本升级过渡使用 </p>
<pre><code class="java">@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
public @interface Deprecated {
}
*/
@Deprecated
class A {
@Deprecated
public int n1 = 10;
@Deprecated
public void hi(){
}
}
</code></pre>
</li>
</ol>
<h4 id="3-SuppressWarnings-抑制编译警告。"><a href="#3-SuppressWarnings-抑制编译警告。" class="headerlink" title="3. SuppressWarnings  抑制编译警告。"></a>3. SuppressWarnings  抑制编译警告。</h4><p>​    </p>
<p>&#x2F;&#x2F;1. 当我们不希望看到这些警告的时候，可以使用 SuppressWarnings 注解来抑制警告信息<br>&#x2F;&#x2F;2. 在{“”} 中，可以写入你希望抑制(不显示)警告信息</p>
<pre><code class="java">@SuppressWarnings(&quot;{all,boxing,}&quot;)
</code></pre>
<ol start="3">
<li>可以指定的警告类型有:</li>
</ol>
<ul>
<li><p>all，抑制所有警告</p>
</li>
<li><p>boxing，抑制与封装&#x2F;拆装作业相关的警告</p>
</li>
<li><p>cast，抑制与强制转型作业相关的警告</p>
</li>
<li><p>dep-ann，抑制与淘汰注释相关的警告</p>
</li>
<li><p>deprecation，抑制与淘汰的相关警告</p>
</li>
<li><p>fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告</p>
</li>
<li><p>finally，抑制与未传回 finally 区块相关的警告</p>
</li>
<li><p>hiding，抑制与隐藏变数的区域变数相关的警告</p>
</li>
<li><p>incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告</p>
</li>
<li><p>javadoc，抑制与 javadoc 相关的警告</p>
</li>
<li><p>nls，抑制与非 nls 字串文字相关的警告</p>
</li>
<li><p>null，抑制与空值分析相关的警告</p>
</li>
<li><p>rawtypes，抑制与使用 raw 类型相关的警告</p>
</li>
<li><p>resource，抑制与使用 Closeable 类型的资源相关的警告</p>
</li>
<li><p>restriction，抑制与使用不建议或禁止参照相关的警告</p>
</li>
<li><p>serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告</p>
</li>
<li><p>static-access，抑制与静态存取不正确相关的警告</p>
</li>
<li><p>static-method，抑制与可能宣告为 static 的方法相关的警告</p>
</li>
<li><p>super，抑制与置换方法相关但不含 super 呼叫的警告</p>
</li>
<li><p>synthetic-access，抑制与内部类别的存取未最佳化相关的警告</p>
</li>
<li><p>sync-override，抑制因为置换同步方法而遗漏同步化的警告</p>
</li>
<li><p>unchecked，抑制与未检查的作业相关的警告</p>
</li>
<li><p>unqualified-field-access，抑制与栏位存取不合格相关的警告</p>
</li>
<li><p>unused，抑制与未用的程式码及停用的程式码相关的警告</p>
</li>
</ul>
<ol start="4">
<li>作用范围和放置的位置有关。 —-&gt;通常放在 具体的语句&#x2F;方法&#x2F;类 &#x3D;&#x3D;上&#x3D;&#x3D;</li>
</ol>
<p> &#x2F;比如 @SuppressWarnings 放置在 main 方法，那么抑制警告的范围就是 main </p>
<p>&#x2F;&#x2F; 通常我们可以放置具体的语句, </p>
<h3 id="三、元注解"><a href="#三、元注解" class="headerlink" title="三、元注解"></a>三、元注解</h3><p><img src="/2-%E6%B3%A8%E8%A7%A3/image-20221116194503733.png" alt="image-20221116194503733"></p>
<blockquote>
<p>元注解：修饰注解的注解</p>
</blockquote>
<pre><code class="java">Target --&gt; 在哪地方使用
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
Retention --&gt; 注解的作用范围
    source 源码
    class 类
       runtime 运行时
@Retention(RetentionPolicy.SOURCE)
Documented 指定该注解是否会在 javadoc 体现
@Inherited 子类会继承父类注解。
</code></pre>
<h4 id="1-Retention"><a href="#1-Retention" class="headerlink" title="1.Retention"></a>1.Retention</h4><p><img src="/2-%E6%B3%A8%E8%A7%A3/image-20221116194743026.png" alt="image-20221116194743026"></p>
<ul>
<li>source<br>编译器使用后，直接丢弃这种策略的注释。</li>
<li>class<br>编译器将注释记录放在 class 文件中，当运行 java 程序时，jvm 不会保留注解。</li>
<li>runtime<br>编译器保留在 class 文件中，jvm 会保留，可以通过反射获取该注释。</li>
</ul>
<p><img src="/2-%E6%B3%A8%E8%A7%A3/image-20221116195312259.png" alt="image-20221116195312259"></p>
<h4 id="2-Target"><a href="#2-Target" class="headerlink" title="2.Target"></a>2.Target</h4><p><img src="/2-%E6%B3%A8%E8%A7%A3/image-20221116195730682.png" alt="image-20221116195730682"></p>
<h4 id="3-Documented"><a href="#3-Documented" class="headerlink" title="3.Documented"></a>3.Documented</h4><p><img src="/2-%E6%B3%A8%E8%A7%A3/image-20221116203123029.png" alt="image-20221116203123029"></p>
<h4 id="4-inherited"><a href="#4-inherited" class="headerlink" title="4.inherited"></a>4.inherited</h4><p><img src="/2-%E6%B3%A8%E8%A7%A3/image-20221116203139525.png" alt="image-20221116203139525"></p>
<blockquote>
<p>A 具有 inherited 注解，B是 A 的子类，那么它将自动拥有这个注解</p>
</blockquote>
